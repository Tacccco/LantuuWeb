/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzPzFmYjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/base64-js/index.js\n");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzP2I2MzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLG9EQUFXO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyxnREFBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsZ0RBQVM7O0FBRS9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbURBQW1EO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixZQUFZO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/buffer/index.js\n");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcz85MTUyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsUUFBUSxVQUFVOztBQUVsQjtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ieee754/index.js\n");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcz9lM2RiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/isarray/index.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2NlZDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/module.js\n");

/***/ }),

/***/ "./resources/js/socket.io-client.js":
/*!******************************************!*\
  !*** ./resources/js/socket.io-client.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, Buffer, module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof2(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\n/*!\n * Socket.IO v3.0.3\n * (c) 2014-2020 Guillermo Rauch\n * Released under the MIT License.\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (( false ? undefined : _typeof2(exports)) === 'object' && ( false ? undefined : _typeof2(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}\n})(function () {\n  if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else {\n    return Function('return this')();\n  }\n}(), function () {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            enumerable: true,\n            get: getter\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // define __esModule on exports\n\n      /******/\n\n\n      __webpack_require__.r = function (exports) {\n        /******/\n        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n          /******/\n          Object.defineProperty(exports, Symbol.toStringTag, {\n            value: 'Module'\n          });\n          /******/\n        }\n        /******/\n\n\n        Object.defineProperty(exports, '__esModule', {\n          value: true\n        });\n        /******/\n      };\n      /******/\n\n      /******/\n      // create a fake namespace object\n\n      /******/\n      // mode & 1: value is a module id, require it\n\n      /******/\n      // mode & 2: merge all properties of value into the ns\n\n      /******/\n      // mode & 4: return value when already ns object\n\n      /******/\n      // mode & 8|1: behave like require\n\n      /******/\n\n\n      __webpack_require__.t = function (value, mode) {\n        /******/\n        if (mode & 1) value = __webpack_require__(value);\n        /******/\n\n        if (mode & 8) return value;\n        /******/\n\n        if (mode & 4 && _typeof2(value) === 'object' && value && value.__esModule) return value;\n        /******/\n\n        var ns = Object.create(null);\n        /******/\n\n        __webpack_require__.r(ns);\n        /******/\n\n\n        Object.defineProperty(ns, 'default', {\n          enumerable: true,\n          value: value\n        });\n        /******/\n\n        if (mode & 2 && typeof value != 'string') for (var key in value) {\n          __webpack_require__.d(ns, key, function (key) {\n            return value[key];\n          }.bind(null, key));\n        }\n        /******/\n\n        return ns;\n        /******/\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = \"./build/index.js\");\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    {\n      /***/\n      \"./build/index.js\":\n      /*!************************!*\\\n        !*** ./build/index.js ***!\n        \\************************/\n\n      /*! no static exports found */\n\n      /***/\n      function buildIndexJs(module, exports, __webpack_require__) {\n        \"use strict\";\n\n        function _typeof(obj) {\n          \"@babel/helpers - typeof\";\n\n          if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n              return typeof obj;\n            };\n          } else {\n            _typeof = function _typeof(obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n          }\n\n          return _typeof(obj);\n        }\n\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.Socket = exports.io = exports.Manager = exports.protocol = void 0;\n\n        var url_1 = __webpack_require__(\n        /*! ./url */\n        \"./build/url.js\");\n\n        var manager_1 = __webpack_require__(\n        /*! ./manager */\n        \"./build/manager.js\");\n\n        var socket_1 = __webpack_require__(\n        /*! ./socket */\n        \"./build/socket.js\");\n\n        Object.defineProperty(exports, \"Socket\", {\n          enumerable: true,\n          get: function get() {\n            return socket_1.Socket;\n          }\n        });\n\n        var debug = __webpack_require__(\n        /*! debug */\n        \"./node_modules/debug/src/browser.js\")(\"socket.io-client\");\n        /**\n         * Module exports.\n         */\n\n\n        module.exports = exports = lookup;\n        /**\n         * Managers cache.\n         */\n\n        var cache = exports.managers = {};\n\n        function lookup(uri, opts) {\n          if (_typeof(uri) === \"object\") {\n            opts = uri;\n            uri = undefined;\n          }\n\n          opts = opts || {};\n          var parsed = url_1.url(uri);\n          var source = parsed.source;\n          var id = parsed.id;\n          var path = parsed.path;\n          var sameNamespace = cache[id] && path in cache[id].nsps;\n          var newConnection = opts.forceNew || opts[\"force new connection\"] || false === opts.multiplex || sameNamespace;\n          var io;\n\n          if (newConnection) {\n            debug(\"ignoring socket cache for %s\", source);\n            io = new manager_1.Manager(source, opts);\n          } else {\n            if (!cache[id]) {\n              debug(\"new io instance for %s\", source);\n              cache[id] = new manager_1.Manager(source, opts);\n            }\n\n            io = cache[id];\n          }\n\n          if (parsed.query && !opts.query) {\n            opts.query = parsed.query;\n          }\n\n          return io.socket(parsed.path, opts);\n        }\n\n        exports.io = lookup;\n        /**\n         * Protocol version.\n         *\n         * @public\n         */\n\n        var socket_io_parser_1 = __webpack_require__(\n        /*! socket.io-parser */\n        \"./node_modules/socket.io-parser/dist/index.js\");\n\n        Object.defineProperty(exports, \"protocol\", {\n          enumerable: true,\n          get: function get() {\n            return socket_io_parser_1.protocol;\n          }\n        });\n        /**\n         * `connect`.\n         *\n         * @param {String} uri\n         * @public\n         */\n\n        exports.connect = lookup;\n        /**\n         * Expose constructors for standalone build.\n         *\n         * @public\n         */\n\n        var manager_2 = __webpack_require__(\n        /*! ./manager */\n        \"./build/manager.js\");\n\n        Object.defineProperty(exports, \"Manager\", {\n          enumerable: true,\n          get: function get() {\n            return manager_2.Manager;\n          }\n        });\n        /***/\n      },\n\n      /***/\n      \"./build/manager.js\":\n      /*!**************************!*\\\n        !*** ./build/manager.js ***!\n        \\**************************/\n\n      /*! no static exports found */\n\n      /***/\n      function buildManagerJs(module, exports, __webpack_require__) {\n        \"use strict\";\n\n        function _typeof(obj) {\n          \"@babel/helpers - typeof\";\n\n          if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n              return typeof obj;\n            };\n          } else {\n            _typeof = function _typeof(obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n          }\n\n          return _typeof(obj);\n        }\n\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        function _defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        function _createClass(Constructor, protoProps, staticProps) {\n          if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) _defineProperties(Constructor, staticProps);\n          return Constructor;\n        }\n\n        function _get(target, property, receiver) {\n          if (typeof Reflect !== \"undefined\" && Reflect.get) {\n            _get = Reflect.get;\n          } else {\n            _get = function _get(target, property, receiver) {\n              var base = _superPropBase(target, property);\n\n              if (!base) return;\n              var desc = Object.getOwnPropertyDescriptor(base, property);\n\n              if (desc.get) {\n                return desc.get.call(receiver);\n              }\n\n              return desc.value;\n            };\n          }\n\n          return _get(target, property, receiver || target);\n        }\n\n        function _superPropBase(object, property) {\n          while (!Object.prototype.hasOwnProperty.call(object, property)) {\n            object = _getPrototypeOf(object);\n            if (object === null) break;\n          }\n\n          return object;\n        }\n\n        function _inherits(subClass, superClass) {\n          if (typeof superClass !== \"function\" && superClass !== null) {\n            throw new TypeError(\"Super expression must either be null or a function\");\n          }\n\n          subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n              value: subClass,\n              writable: true,\n              configurable: true\n            }\n          });\n          if (superClass) _setPrototypeOf(subClass, superClass);\n        }\n\n        function _setPrototypeOf(o, p) {\n          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n            o.__proto__ = p;\n            return o;\n          };\n\n          return _setPrototypeOf(o, p);\n        }\n\n        function _createSuper(Derived) {\n          var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n          return function _createSuperInternal() {\n            var Super = _getPrototypeOf(Derived),\n                result;\n\n            if (hasNativeReflectConstruct) {\n              var NewTarget = _getPrototypeOf(this).constructor;\n\n              result = Reflect.construct(Super, arguments, NewTarget);\n            } else {\n              result = Super.apply(this, arguments);\n            }\n\n            return _possibleConstructorReturn(this, result);\n          };\n        }\n\n        function _possibleConstructorReturn(self, call) {\n          if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n            return call;\n          }\n\n          return _assertThisInitialized(self);\n        }\n\n        function _assertThisInitialized(self) {\n          if (self === void 0) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          }\n\n          return self;\n        }\n\n        function _isNativeReflectConstruct() {\n          if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n          if (Reflect.construct.sham) return false;\n          if (typeof Proxy === \"function\") return true;\n\n          try {\n            Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n            return true;\n          } catch (e) {\n            return false;\n          }\n        }\n\n        function _getPrototypeOf(o) {\n          _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n            return o.__proto__ || Object.getPrototypeOf(o);\n          };\n          return _getPrototypeOf(o);\n        }\n\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.Manager = void 0;\n\n        var eio = __webpack_require__(\n        /*! engine.io-client */\n        \"./node_modules/engine.io-client/lib/index.js\");\n\n        var socket_1 = __webpack_require__(\n        /*! ./socket */\n        \"./build/socket.js\");\n\n        var Emitter = __webpack_require__(\n        /*! component-emitter */\n        \"./node_modules/component-emitter/index.js\");\n\n        var parser = __webpack_require__(\n        /*! socket.io-parser */\n        \"./node_modules/socket.io-parser/dist/index.js\");\n\n        var on_1 = __webpack_require__(\n        /*! ./on */\n        \"./build/on.js\");\n\n        var bind = __webpack_require__(\n        /*! component-bind */\n        \"./node_modules/component-bind/index.js\");\n\n        var Backoff = __webpack_require__(\n        /*! backo2 */\n        \"./node_modules/backo2/index.js\");\n\n        var debug = __webpack_require__(\n        /*! debug */\n        \"./node_modules/debug/src/browser.js\")(\"socket.io-client:manager\");\n\n        var Manager = /*#__PURE__*/function (_Emitter) {\n          _inherits(Manager, _Emitter);\n\n          var _super = _createSuper(Manager);\n\n          function Manager(uri, opts) {\n            var _this;\n\n            _classCallCheck(this, Manager);\n\n            _this = _super.call(this);\n            _this.nsps = {};\n            _this.subs = [];\n            _this.connecting = [];\n\n            if (uri && \"object\" === _typeof(uri)) {\n              opts = uri;\n              uri = undefined;\n            }\n\n            opts = opts || {};\n            opts.path = opts.path || \"/socket.io\";\n            _this.opts = opts;\n\n            _this.reconnection(opts.reconnection !== false);\n\n            _this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n\n            _this.reconnectionDelay(opts.reconnectionDelay || 1000);\n\n            _this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n\n            _this.randomizationFactor(opts.randomizationFactor || 0.5);\n\n            _this.backoff = new Backoff({\n              min: _this.reconnectionDelay(),\n              max: _this.reconnectionDelayMax(),\n              jitter: _this.randomizationFactor()\n            });\n\n            _this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n\n            _this._readyState = \"closed\";\n            _this.uri = uri;\n\n            var _parser = opts.parser || parser;\n\n            _this.encoder = new _parser.Encoder();\n            _this.decoder = new _parser.Decoder();\n            _this._autoConnect = opts.autoConnect !== false;\n            if (_this._autoConnect) _this.open();\n            return _this;\n          }\n\n          _createClass(Manager, [{\n            key: \"reconnection\",\n            value: function reconnection(v) {\n              if (!arguments.length) return this._reconnection;\n              this._reconnection = !!v;\n              return this;\n            }\n          }, {\n            key: \"reconnectionAttempts\",\n            value: function reconnectionAttempts(v) {\n              if (v === undefined) return this._reconnectionAttempts;\n              this._reconnectionAttempts = v;\n              return this;\n            }\n          }, {\n            key: \"reconnectionDelay\",\n            value: function reconnectionDelay(v) {\n              if (v === undefined) return this._reconnectionDelay;\n              this._reconnectionDelay = v;\n              this.backoff && this.backoff.setMin(v);\n              return this;\n            }\n          }, {\n            key: \"randomizationFactor\",\n            value: function randomizationFactor(v) {\n              if (v === undefined) return this._randomizationFactor;\n              this._randomizationFactor = v;\n              this.backoff && this.backoff.setJitter(v);\n              return this;\n            }\n          }, {\n            key: \"reconnectionDelayMax\",\n            value: function reconnectionDelayMax(v) {\n              if (v === undefined) return this._reconnectionDelayMax;\n              this._reconnectionDelayMax = v;\n              this.backoff && this.backoff.setMax(v);\n              return this;\n            }\n          }, {\n            key: \"timeout\",\n            value: function timeout(v) {\n              if (!arguments.length) return this._timeout;\n              this._timeout = v;\n              return this;\n            }\n            /**\n             * Starts trying to reconnect if reconnection is enabled and we have not\n             * started reconnecting yet\n             *\n             * @private\n             */\n\n          }, {\n            key: \"maybeReconnectOnOpen\",\n            value: function maybeReconnectOnOpen() {\n              // Only try to reconnect if it's the first time we're connecting\n              if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {\n                // keeps reconnection from firing twice for the same reconnection loop\n                this.reconnect();\n              }\n            }\n            /**\n             * Sets the current transport `socket`.\n             *\n             * @param {Function} fn - optional, callback\n             * @return {Manager} self\n             * @public\n             */\n\n          }, {\n            key: \"open\",\n            value: function open(fn) {\n              var _this2 = this;\n\n              debug(\"readyState %s\", this._readyState);\n              if (~this._readyState.indexOf(\"open\")) return this;\n              debug(\"opening %s\", this.uri);\n              this.engine = eio(this.uri, this.opts);\n              var socket = this.engine;\n              var self = this;\n              this._readyState = \"opening\";\n              this.skipReconnect = false; // emit `open`\n\n              var openSub = on_1.on(socket, \"open\", function () {\n                self.onopen();\n                fn && fn();\n              }); // emit `error`\n\n              var errorSub = on_1.on(socket, \"error\", function (err) {\n                debug(\"error\");\n                self.cleanup();\n                self._readyState = \"closed\";\n\n                _get(_getPrototypeOf(Manager.prototype), \"emit\", _this2).call(_this2, \"error\", err);\n\n                if (fn) {\n                  fn(err);\n                } else {\n                  // Only do this if there is no fn to handle the error\n                  self.maybeReconnectOnOpen();\n                }\n              });\n\n              if (false !== this._timeout) {\n                var timeout = this._timeout;\n                debug(\"connect attempt will timeout after %d\", timeout);\n\n                if (timeout === 0) {\n                  openSub.destroy(); // prevents a race condition with the 'open' event\n                } // set timer\n\n\n                var timer = setTimeout(function () {\n                  debug(\"connect attempt timed out after %d\", timeout);\n                  openSub.destroy();\n                  socket.close();\n                  socket.emit(\"error\", new Error(\"timeout\"));\n                }, timeout);\n                this.subs.push({\n                  destroy: function destroy() {\n                    clearTimeout(timer);\n                  }\n                });\n              }\n\n              this.subs.push(openSub);\n              this.subs.push(errorSub);\n              return this;\n            }\n            /**\n             * Alias for open()\n             *\n             * @return {Manager} self\n             * @public\n             */\n\n          }, {\n            key: \"connect\",\n            value: function connect(fn) {\n              return this.open(fn);\n            }\n            /**\n             * Called upon transport open.\n             *\n             * @private\n             */\n\n          }, {\n            key: \"onopen\",\n            value: function onopen() {\n              debug(\"open\"); // clear old subs\n\n              this.cleanup(); // mark as open\n\n              this._readyState = \"open\";\n\n              _get(_getPrototypeOf(Manager.prototype), \"emit\", this).call(this, \"open\"); // add new subs\n\n\n              var socket = this.engine;\n              this.subs.push(on_1.on(socket, \"data\", bind(this, \"ondata\")));\n              this.subs.push(on_1.on(socket, \"ping\", bind(this, \"onping\")));\n              this.subs.push(on_1.on(socket, \"error\", bind(this, \"onerror\")));\n              this.subs.push(on_1.on(socket, \"close\", bind(this, \"onclose\")));\n              this.subs.push(on_1.on(this.decoder, \"decoded\", bind(this, \"ondecoded\")));\n            }\n            /**\n             * Called upon a ping.\n             *\n             * @private\n             */\n\n          }, {\n            key: \"onping\",\n            value: function onping() {\n              _get(_getPrototypeOf(Manager.prototype), \"emit\", this).call(this, \"ping\");\n            }\n            /**\n             * Called with data.\n             *\n             * @private\n             */\n\n          }, {\n            key: \"ondata\",\n            value: function ondata(data) {\n              this.decoder.add(data);\n            }\n            /**\n             * Called when parser fully decodes a packet.\n             *\n             * @private\n             */\n\n          }, {\n            key: \"ondecoded\",\n            value: function ondecoded(packet) {\n              _get(_getPrototypeOf(Manager.prototype), \"emit\", this).call(this, \"packet\", packet);\n            }\n            /**\n             * Called upon socket error.\n             *\n             * @private\n             */\n\n          }, {\n            key: \"onerror\",\n            value: function onerror(err) {\n              debug(\"error\", err);\n\n              _get(_getPrototypeOf(Manager.prototype), \"emit\", this).call(this, \"error\", err);\n            }\n            /**\n             * Creates a new socket for the given `nsp`.\n             *\n             * @return {Socket}\n             * @public\n             */\n\n          }, {\n            key: \"socket\",\n            value: function socket(nsp, opts) {\n              var socket = this.nsps[nsp];\n\n              if (!socket) {\n                socket = new socket_1.Socket(this, nsp, opts);\n                this.nsps[nsp] = socket;\n                var self = this;\n                socket.on(\"connecting\", onConnecting);\n\n                if (this._autoConnect) {\n                  // manually call here since connecting event is fired before listening\n                  onConnecting();\n                }\n              }\n\n              function onConnecting() {\n                if (!~self.connecting.indexOf(socket)) {\n                  self.connecting.push(socket);\n                }\n              }\n\n              return socket;\n            }\n            /**\n             * Called upon a socket close.\n             *\n             * @param {Socket} socket\n             * @private\n             */\n\n          }, {\n            key: \"_destroy\",\n            value: function _destroy(socket) {\n              var index = this.connecting.indexOf(socket);\n              if (~index) this.connecting.splice(index, 1);\n              if (this.connecting.length) return;\n\n              this._close();\n            }\n            /**\n             * Writes a packet.\n             *\n             * @param {Object} packet\n             * @private\n             */\n\n          }, {\n            key: \"_packet\",\n            value: function _packet(packet) {\n              debug(\"writing packet %j\", packet);\n              if (packet.query && packet.type === 0) packet.nsp += \"?\" + packet.query;\n              var encodedPackets = this.encoder.encode(packet);\n\n              for (var i = 0; i < encodedPackets.length; i++) {\n                this.engine.write(encodedPackets[i], packet.options);\n              }\n            }\n            /**\n             * Clean up transport subscriptions and packet buffer.\n             *\n             * @private\n             */\n\n          }, {\n            key: \"cleanup\",\n            value: function cleanup() {\n              debug(\"cleanup\");\n              var subsLength = this.subs.length;\n\n              for (var i = 0; i < subsLength; i++) {\n                var sub = this.subs.shift();\n                sub.destroy();\n              }\n\n              this.decoder.destroy();\n            }\n            /**\n             * Close the current socket.\n             *\n             * @private\n             */\n\n          }, {\n            key: \"_close\",\n            value: function _close() {\n              debug(\"disconnect\");\n              this.skipReconnect = true;\n              this._reconnecting = false;\n\n              if (\"opening\" === this._readyState) {\n                // `onclose` will not fire because\n                // an open event never happened\n                this.cleanup();\n              }\n\n              this.backoff.reset();\n              this._readyState = \"closed\";\n              if (this.engine) this.engine.close();\n            }\n            /**\n             * Alias for close()\n             *\n             * @private\n             */\n\n          }, {\n            key: \"disconnect\",\n            value: function disconnect() {\n              return this._close();\n            }\n            /**\n             * Called upon engine close.\n             *\n             * @private\n             */\n\n          }, {\n            key: \"onclose\",\n            value: function onclose(reason) {\n              debug(\"onclose\");\n              this.cleanup();\n              this.backoff.reset();\n              this._readyState = \"closed\";\n\n              _get(_getPrototypeOf(Manager.prototype), \"emit\", this).call(this, \"close\", reason);\n\n              if (this._reconnection && !this.skipReconnect) {\n                this.reconnect();\n              }\n            }\n            /**\n             * Attempt a reconnection.\n             *\n             * @private\n             */\n\n          }, {\n            key: \"reconnect\",\n            value: function reconnect() {\n              var _this3 = this;\n\n              if (this._reconnecting || this.skipReconnect) return this;\n              var self = this;\n\n              if (this.backoff.attempts >= this._reconnectionAttempts) {\n                debug(\"reconnect failed\");\n                this.backoff.reset();\n\n                _get(_getPrototypeOf(Manager.prototype), \"emit\", this).call(this, \"reconnect_failed\");\n\n                this._reconnecting = false;\n              } else {\n                var delay = this.backoff.duration();\n                debug(\"will wait %dms before reconnect attempt\", delay);\n                this._reconnecting = true;\n                var timer = setTimeout(function () {\n                  if (self.skipReconnect) return;\n                  debug(\"attempting reconnect\");\n\n                  _get(_getPrototypeOf(Manager.prototype), \"emit\", _this3).call(_this3, \"reconnect_attempt\", self.backoff.attempts); // check again for the case socket closed in above events\n\n\n                  if (self.skipReconnect) return;\n                  self.open(function (err) {\n                    if (err) {\n                      debug(\"reconnect attempt error\");\n                      self._reconnecting = false;\n                      self.reconnect();\n\n                      _get(_getPrototypeOf(Manager.prototype), \"emit\", _this3).call(_this3, \"reconnect_error\", err);\n                    } else {\n                      debug(\"reconnect success\");\n                      self.onreconnect();\n                    }\n                  });\n                }, delay);\n                this.subs.push({\n                  destroy: function destroy() {\n                    clearTimeout(timer);\n                  }\n                });\n              }\n            }\n            /**\n             * Called upon successful reconnect.\n             *\n             * @private\n             */\n\n          }, {\n            key: \"onreconnect\",\n            value: function onreconnect() {\n              var attempt = this.backoff.attempts;\n              this._reconnecting = false;\n              this.backoff.reset();\n\n              _get(_getPrototypeOf(Manager.prototype), \"emit\", this).call(this, \"reconnect\", attempt);\n            }\n          }]);\n\n          return Manager;\n        }(Emitter);\n\n        exports.Manager = Manager;\n        /***/\n      },\n\n      /***/\n      \"./build/on.js\":\n      /*!*********************!*\\\n        !*** ./build/on.js ***!\n        \\*********************/\n\n      /*! no static exports found */\n\n      /***/\n      function buildOnJs(module, exports, __webpack_require__) {\n        \"use strict\";\n\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.on = void 0;\n\n        function on(obj, ev, fn) {\n          obj.on(ev, fn);\n          return {\n            destroy: function destroy() {\n              obj.removeListener(ev, fn);\n            }\n          };\n        }\n\n        exports.on = on;\n        /***/\n      },\n\n      /***/\n      \"./build/socket.js\":\n      /*!*************************!*\\\n        !*** ./build/socket.js ***!\n        \\*************************/\n\n      /*! no static exports found */\n\n      /***/\n      function buildSocketJs(module, exports, __webpack_require__) {\n        \"use strict\";\n\n        function _typeof(obj) {\n          \"@babel/helpers - typeof\";\n\n          if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n              return typeof obj;\n            };\n          } else {\n            _typeof = function _typeof(obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n          }\n\n          return _typeof(obj);\n        }\n\n        function _createForOfIteratorHelper(o, allowArrayLike) {\n          var it;\n\n          if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n            if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n              if (it) o = it;\n              var i = 0;\n\n              var F = function F() {};\n\n              return {\n                s: F,\n                n: function n() {\n                  if (i >= o.length) return {\n                    done: true\n                  };\n                  return {\n                    done: false,\n                    value: o[i++]\n                  };\n                },\n                e: function e(_e) {\n                  throw _e;\n                },\n                f: F\n              };\n            }\n\n            throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n          }\n\n          var normalCompletion = true,\n              didErr = false,\n              err;\n          return {\n            s: function s() {\n              it = o[Symbol.iterator]();\n            },\n            n: function n() {\n              var step = it.next();\n              normalCompletion = step.done;\n              return step;\n            },\n            e: function e(_e2) {\n              didErr = true;\n              err = _e2;\n            },\n            f: function f() {\n              try {\n                if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n              } finally {\n                if (didErr) throw err;\n              }\n            }\n          };\n        }\n\n        function _unsupportedIterableToArray(o, minLen) {\n          if (!o) return;\n          if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n          var n = Object.prototype.toString.call(o).slice(8, -1);\n          if (n === \"Object\" && o.constructor) n = o.constructor.name;\n          if (n === \"Map\" || n === \"Set\") return Array.from(o);\n          if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n        }\n\n        function _arrayLikeToArray(arr, len) {\n          if (len == null || len > arr.length) len = arr.length;\n\n          for (var i = 0, arr2 = new Array(len); i < len; i++) {\n            arr2[i] = arr[i];\n          }\n\n          return arr2;\n        }\n\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        function _defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        function _createClass(Constructor, protoProps, staticProps) {\n          if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) _defineProperties(Constructor, staticProps);\n          return Constructor;\n        }\n\n        function _get(target, property, receiver) {\n          if (typeof Reflect !== \"undefined\" && Reflect.get) {\n            _get = Reflect.get;\n          } else {\n            _get = function _get(target, property, receiver) {\n              var base = _superPropBase(target, property);\n\n              if (!base) return;\n              var desc = Object.getOwnPropertyDescriptor(base, property);\n\n              if (desc.get) {\n                return desc.get.call(receiver);\n              }\n\n              return desc.value;\n            };\n          }\n\n          return _get(target, property, receiver || target);\n        }\n\n        function _superPropBase(object, property) {\n          while (!Object.prototype.hasOwnProperty.call(object, property)) {\n            object = _getPrototypeOf(object);\n            if (object === null) break;\n          }\n\n          return object;\n        }\n\n        function _inherits(subClass, superClass) {\n          if (typeof superClass !== \"function\" && superClass !== null) {\n            throw new TypeError(\"Super expression must either be null or a function\");\n          }\n\n          subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n              value: subClass,\n              writable: true,\n              configurable: true\n            }\n          });\n          if (superClass) _setPrototypeOf(subClass, superClass);\n        }\n\n        function _setPrototypeOf(o, p) {\n          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n            o.__proto__ = p;\n            return o;\n          };\n\n          return _setPrototypeOf(o, p);\n        }\n\n        function _createSuper(Derived) {\n          var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n          return function _createSuperInternal() {\n            var Super = _getPrototypeOf(Derived),\n                result;\n\n            if (hasNativeReflectConstruct) {\n              var NewTarget = _getPrototypeOf(this).constructor;\n\n              result = Reflect.construct(Super, arguments, NewTarget);\n            } else {\n              result = Super.apply(this, arguments);\n            }\n\n            return _possibleConstructorReturn(this, result);\n          };\n        }\n\n        function _possibleConstructorReturn(self, call) {\n          if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n            return call;\n          }\n\n          return _assertThisInitialized(self);\n        }\n\n        function _assertThisInitialized(self) {\n          if (self === void 0) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          }\n\n          return self;\n        }\n\n        function _isNativeReflectConstruct() {\n          if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n          if (Reflect.construct.sham) return false;\n          if (typeof Proxy === \"function\") return true;\n\n          try {\n            Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n            return true;\n          } catch (e) {\n            return false;\n          }\n        }\n\n        function _getPrototypeOf(o) {\n          _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n            return o.__proto__ || Object.getPrototypeOf(o);\n          };\n          return _getPrototypeOf(o);\n        }\n\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.Socket = void 0;\n\n        var socket_io_parser_1 = __webpack_require__(\n        /*! socket.io-parser */\n        \"./node_modules/socket.io-parser/dist/index.js\");\n\n        var Emitter = __webpack_require__(\n        /*! component-emitter */\n        \"./node_modules/component-emitter/index.js\");\n\n        var on_1 = __webpack_require__(\n        /*! ./on */\n        \"./build/on.js\");\n\n        var bind = __webpack_require__(\n        /*! component-bind */\n        \"./node_modules/component-bind/index.js\");\n\n        var debug = __webpack_require__(\n        /*! debug */\n        \"./node_modules/debug/src/browser.js\")(\"socket.io-client:socket\");\n        /**\n         * Internal events.\n         * These events can't be emitted by the user.\n         */\n\n\n        var RESERVED_EVENTS = {\n          connect: 1,\n          connect_error: 1,\n          disconnect: 1,\n          disconnecting: 1,\n          // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n          newListener: 1,\n          removeListener: 1\n        };\n\n        var Socket = /*#__PURE__*/function (_Emitter) {\n          _inherits(Socket, _Emitter);\n\n          var _super = _createSuper(Socket);\n          /**\n           * `Socket` constructor.\n           *\n           * @public\n           */\n\n\n          function Socket(io, nsp, opts) {\n            var _this;\n\n            _classCallCheck(this, Socket);\n\n            _this = _super.call(this);\n            _this.ids = 0;\n            _this.acks = {};\n            _this.receiveBuffer = [];\n            _this.sendBuffer = [];\n            _this.flags = {};\n            _this.io = io;\n            _this.nsp = nsp;\n            _this.ids = 0;\n            _this.acks = {};\n            _this.receiveBuffer = [];\n            _this.sendBuffer = [];\n            _this.connected = false;\n            _this.disconnected = true;\n            _this.flags = {};\n\n            if (opts && opts.auth) {\n              _this.auth = opts.auth;\n            }\n\n            if (_this.io._autoConnect) _this.open();\n            return _this;\n          }\n          /**\n           * Subscribe to open, close and packet events\n           *\n           * @private\n           */\n\n\n          _createClass(Socket, [{\n            key: \"subEvents\",\n            value: function subEvents() {\n              if (this.subs) return;\n              var io = this.io;\n              this.subs = [on_1.on(io, \"open\", bind(this, \"onopen\")), on_1.on(io, \"packet\", bind(this, \"onpacket\")), on_1.on(io, \"close\", bind(this, \"onclose\"))];\n            }\n            /**\n             * \"Opens\" the socket.\n             *\n             * @public\n             */\n\n          }, {\n            key: \"connect\",\n            value: function connect() {\n              if (this.connected) return this;\n              this.subEvents();\n              if (!this.io._reconnecting) this.io.open(); // ensure open\n\n              if (\"open\" === this.io._readyState) this.onopen();\n              return this;\n            }\n            /**\n             * Alias for connect()\n             */\n\n          }, {\n            key: \"open\",\n            value: function open() {\n              return this.connect();\n            }\n            /**\n             * Sends a `message` event.\n             *\n             * @return {Socket} self\n             * @public\n             */\n\n          }, {\n            key: \"send\",\n            value: function send() {\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n\n              args.unshift(\"message\");\n              this.emit.apply(this, args);\n              return this;\n            }\n            /**\n             * Override `emit`.\n             * If the event is in `events`, it's emitted normally.\n             *\n             * @param {String} ev - event name\n             * @return {Socket} self\n             * @public\n             */\n\n          }, {\n            key: \"emit\",\n            value: function emit(ev) {\n              if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n                throw new Error('\"' + ev + '\" is a reserved event name');\n              }\n\n              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                args[_key2 - 1] = arguments[_key2];\n              }\n\n              args.unshift(ev);\n              var packet = {\n                type: socket_io_parser_1.PacketType.EVENT,\n                data: args\n              };\n              packet.options = {};\n              packet.options.compress = this.flags.compress !== false; // event ack callback\n\n              if (\"function\" === typeof args[args.length - 1]) {\n                debug(\"emitting packet with ack id %d\", this.ids);\n                this.acks[this.ids] = args.pop();\n                packet.id = this.ids++;\n              }\n\n              var isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;\n              var discardPacket = this.flags[\"volatile\"] && (!isTransportWritable || !this.connected);\n\n              if (discardPacket) {\n                debug(\"discard packet as the transport is not currently writable\");\n              } else if (this.connected) {\n                this.packet(packet);\n              } else {\n                this.sendBuffer.push(packet);\n              }\n\n              this.flags = {};\n              return this;\n            }\n            /**\n             * Sends a packet.\n             *\n             * @param {Object} packet\n             * @private\n             */\n\n          }, {\n            key: \"packet\",\n            value: function packet(_packet) {\n              _packet.nsp = this.nsp;\n\n              this.io._packet(_packet);\n            }\n            /**\n             * Called upon engine `open`.\n             *\n             * @private\n             */\n\n          }, {\n            key: \"onopen\",\n            value: function onopen() {\n              var _this2 = this;\n\n              debug(\"transport is open - connecting\");\n\n              if (typeof this.auth == \"function\") {\n                this.auth(function (data) {\n                  _this2.packet({\n                    type: socket_io_parser_1.PacketType.CONNECT,\n                    data: data\n                  });\n                });\n              } else {\n                this.packet({\n                  type: socket_io_parser_1.PacketType.CONNECT,\n                  data: this.auth\n                });\n              }\n            }\n            /**\n             * Called upon engine `close`.\n             *\n             * @param {String} reason\n             * @private\n             */\n\n          }, {\n            key: \"onclose\",\n            value: function onclose(reason) {\n              debug(\"close (%s)\", reason);\n              this.connected = false;\n              this.disconnected = true;\n              delete this.id;\n\n              _get(_getPrototypeOf(Socket.prototype), \"emit\", this).call(this, \"disconnect\", reason);\n            }\n            /**\n             * Called with socket packet.\n             *\n             * @param {Object} packet\n             * @private\n             */\n\n          }, {\n            key: \"onpacket\",\n            value: function onpacket(packet) {\n              var sameNamespace = packet.nsp === this.nsp;\n              if (!sameNamespace) return;\n\n              switch (packet.type) {\n                case socket_io_parser_1.PacketType.CONNECT:\n                  var id = packet.data.sid;\n                  this.onconnect(id);\n                  break;\n\n                case socket_io_parser_1.PacketType.EVENT:\n                  this.onevent(packet);\n                  break;\n\n                case socket_io_parser_1.PacketType.BINARY_EVENT:\n                  this.onevent(packet);\n                  break;\n\n                case socket_io_parser_1.PacketType.ACK:\n                  this.onack(packet);\n                  break;\n\n                case socket_io_parser_1.PacketType.BINARY_ACK:\n                  this.onack(packet);\n                  break;\n\n                case socket_io_parser_1.PacketType.DISCONNECT:\n                  this.ondisconnect();\n                  break;\n\n                case socket_io_parser_1.PacketType.CONNECT_ERROR:\n                  var err = new Error(packet.data.message); // @ts-ignore\n\n                  err.data = packet.data.data;\n\n                  _get(_getPrototypeOf(Socket.prototype), \"emit\", this).call(this, \"connect_error\", err);\n\n                  break;\n              }\n            }\n            /**\n             * Called upon a server event.\n             *\n             * @param {Object} packet\n             * @private\n             */\n\n          }, {\n            key: \"onevent\",\n            value: function onevent(packet) {\n              var args = packet.data || [];\n              debug(\"emitting event %j\", args);\n\n              if (null != packet.id) {\n                debug(\"attaching ack callback to event\");\n                args.push(this.ack(packet.id));\n              }\n\n              if (this.connected) {\n                this.emitEvent(args);\n              } else {\n                this.receiveBuffer.push(args);\n              }\n            }\n          }, {\n            key: \"emitEvent\",\n            value: function emitEvent(args) {\n              if (this._anyListeners && this._anyListeners.length) {\n                var listeners = this._anyListeners.slice();\n\n                var _iterator = _createForOfIteratorHelper(listeners),\n                    _step;\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    var listener = _step.value;\n                    listener.apply(this, args);\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n              }\n\n              _get(_getPrototypeOf(Socket.prototype), \"emit\", this).apply(this, args);\n            }\n            /**\n             * Produces an ack callback to emit with an event.\n             *\n             * @private\n             */\n\n          }, {\n            key: \"ack\",\n            value: function ack(id) {\n              var self = this;\n              var sent = false;\n              return function () {\n                // prevent double callbacks\n                if (sent) return;\n                sent = true;\n\n                for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n                  args[_key3] = arguments[_key3];\n                }\n\n                debug(\"sending ack %j\", args);\n                self.packet({\n                  type: socket_io_parser_1.PacketType.ACK,\n                  id: id,\n                  data: args\n                });\n              };\n            }\n            /**\n             * Called upon a server acknowlegement.\n             *\n             * @param {Object} packet\n             * @private\n             */\n\n          }, {\n            key: \"onack\",\n            value: function onack(packet) {\n              var ack = this.acks[packet.id];\n\n              if (\"function\" === typeof ack) {\n                debug(\"calling ack %s with %j\", packet.id, packet.data);\n                ack.apply(this, packet.data);\n                delete this.acks[packet.id];\n              } else {\n                debug(\"bad ack %s\", packet.id);\n              }\n            }\n            /**\n             * Called upon server connect.\n             *\n             * @private\n             */\n\n          }, {\n            key: \"onconnect\",\n            value: function onconnect(id) {\n              this.id = id;\n              this.connected = true;\n              this.disconnected = false;\n\n              _get(_getPrototypeOf(Socket.prototype), \"emit\", this).call(this, \"connect\");\n\n              this.emitBuffered();\n            }\n            /**\n             * Emit buffered events (received and emitted).\n             *\n             * @private\n             */\n\n          }, {\n            key: \"emitBuffered\",\n            value: function emitBuffered() {\n              for (var i = 0; i < this.receiveBuffer.length; i++) {\n                this.emitEvent(this.receiveBuffer[i]);\n              }\n\n              this.receiveBuffer = [];\n\n              for (var _i = 0; _i < this.sendBuffer.length; _i++) {\n                this.packet(this.sendBuffer[_i]);\n              }\n\n              this.sendBuffer = [];\n            }\n            /**\n             * Called upon server disconnect.\n             *\n             * @private\n             */\n\n          }, {\n            key: \"ondisconnect\",\n            value: function ondisconnect() {\n              debug(\"server disconnect (%s)\", this.nsp);\n              this.destroy();\n              this.onclose(\"io server disconnect\");\n            }\n            /**\n             * Called upon forced client/server side disconnections,\n             * this method ensures the manager stops tracking us and\n             * that reconnections don't get triggered for this.\n             *\n             * @private\n             */\n\n          }, {\n            key: \"destroy\",\n            value: function destroy() {\n              if (this.subs) {\n                // clean subscriptions to avoid reconnections\n                for (var i = 0; i < this.subs.length; i++) {\n                  this.subs[i].destroy();\n                }\n\n                this.subs = null;\n              }\n\n              this.io._destroy(this);\n            }\n            /**\n             * Disconnects the socket manually.\n             *\n             * @return {Socket} self\n             * @public\n             */\n\n          }, {\n            key: \"disconnect\",\n            value: function disconnect() {\n              if (this.connected) {\n                debug(\"performing disconnect (%s)\", this.nsp);\n                this.packet({\n                  type: socket_io_parser_1.PacketType.DISCONNECT\n                });\n              } // remove socket from pool\n\n\n              this.destroy();\n\n              if (this.connected) {\n                // fire events\n                this.onclose(\"io client disconnect\");\n              }\n\n              return this;\n            }\n            /**\n             * Alias for disconnect()\n             *\n             * @return {Socket} self\n             * @public\n             */\n\n          }, {\n            key: \"close\",\n            value: function close() {\n              return this.disconnect();\n            }\n            /**\n             * Sets the compress flag.\n             *\n             * @param {Boolean} compress - if `true`, compresses the sending data\n             * @return {Socket} self\n             * @public\n             */\n\n          }, {\n            key: \"compress\",\n            value: function compress(_compress) {\n              this.flags.compress = _compress;\n              return this;\n            }\n            /**\n             * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n             * ready to send messages.\n             *\n             * @returns {Socket} self\n             * @public\n             */\n\n          }, {\n            key: \"onAny\",\n\n            /**\n             * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n             * callback.\n             *\n             * @param listener\n             * @public\n             */\n            value: function onAny(listener) {\n              this._anyListeners = this._anyListeners || [];\n\n              this._anyListeners.push(listener);\n\n              return this;\n            }\n            /**\n             * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n             * callback. The listener is added to the beginning of the listeners array.\n             *\n             * @param listener\n             * @public\n             */\n\n          }, {\n            key: \"prependAny\",\n            value: function prependAny(listener) {\n              this._anyListeners = this._anyListeners || [];\n\n              this._anyListeners.unshift(listener);\n\n              return this;\n            }\n            /**\n             * Removes the listener that will be fired when any event is emitted.\n             *\n             * @param listener\n             * @public\n             */\n\n          }, {\n            key: \"offAny\",\n            value: function offAny(listener) {\n              if (!this._anyListeners) {\n                return this;\n              }\n\n              if (listener) {\n                var listeners = this._anyListeners;\n\n                for (var i = 0; i < listeners.length; i++) {\n                  if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                  }\n                }\n              } else {\n                this._anyListeners = [];\n              }\n\n              return this;\n            }\n            /**\n             * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n             * e.g. to remove listeners.\n             *\n             * @public\n             */\n\n          }, {\n            key: \"listenersAny\",\n            value: function listenersAny() {\n              return this._anyListeners || [];\n            }\n          }, {\n            key: \"volatile\",\n            get: function get() {\n              this.flags[\"volatile\"] = true;\n              return this;\n            }\n          }]);\n\n          return Socket;\n        }(Emitter);\n\n        exports.Socket = Socket;\n        /***/\n      },\n\n      /***/\n      \"./build/url.js\":\n      /*!**********************!*\\\n        !*** ./build/url.js ***!\n        \\**********************/\n\n      /*! no static exports found */\n\n      /***/\n      function buildUrlJs(module, exports, __webpack_require__) {\n        \"use strict\";\n\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.url = void 0;\n\n        var parseuri = __webpack_require__(\n        /*! parseuri */\n        \"./node_modules/parseuri/index.js\");\n\n        var debug = __webpack_require__(\n        /*! debug */\n        \"./node_modules/debug/src/browser.js\")(\"socket.io-client:url\");\n        /**\n         * URL parser.\n         *\n         * @param {String} uri - url\n         * @param {Object} loc - An object meant to mimic window.location.\n         *                 Defaults to window.location.\n         * @public\n         */\n\n\n        function url(uri, loc) {\n          var obj = uri; // default to window.location\n\n          loc = loc || typeof location !== \"undefined\" && location;\n          if (null == uri) uri = loc.protocol + \"//\" + loc.host; // relative path support\n\n          if (\"string\" === typeof uri) {\n            if (\"/\" === uri.charAt(0)) {\n              if (\"/\" === uri.charAt(1)) {\n                uri = loc.protocol + uri;\n              } else {\n                uri = loc.host + uri;\n              }\n            }\n\n            if (!/^(https?|wss?):\\/\\//.test(uri)) {\n              debug(\"protocol-less url %s\", uri);\n\n              if (\"undefined\" !== typeof loc) {\n                uri = loc.protocol + \"//\" + uri;\n              } else {\n                uri = \"https://\" + uri;\n              }\n            } // parse\n\n\n            debug(\"parse %s\", uri);\n            obj = parseuri(uri);\n          } // make sure we treat `localhost:80` and `localhost` equally\n\n\n          if (!obj.port) {\n            if (/^(http|ws)$/.test(obj.protocol)) {\n              obj.port = \"80\";\n            } else if (/^(http|ws)s$/.test(obj.protocol)) {\n              obj.port = \"443\";\n            }\n          }\n\n          obj.path = obj.path || \"/\";\n          var ipv6 = obj.host.indexOf(\":\") !== -1;\n          var host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host; // define unique id\n\n          obj.id = obj.protocol + \"://\" + host + \":\" + obj.port; // define href\n\n          obj.href = obj.protocol + \"://\" + host + (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n          return obj;\n        }\n\n        exports.url = url;\n        /***/\n      },\n\n      /***/\n      \"./node_modules/backo2/index.js\":\n      /*!**************************************!*\\\n        !*** ./node_modules/backo2/index.js ***!\n        \\**************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesBacko2IndexJs(module, exports) {\n        /**\n         * Expose `Backoff`.\n         */\n        module.exports = Backoff;\n        /**\n         * Initialize backoff timer with `opts`.\n         *\n         * - `min` initial timeout in milliseconds [100]\n         * - `max` max timeout [10000]\n         * - `jitter` [0]\n         * - `factor` [2]\n         *\n         * @param {Object} opts\n         * @api public\n         */\n\n        function Backoff(opts) {\n          opts = opts || {};\n          this.ms = opts.min || 100;\n          this.max = opts.max || 10000;\n          this.factor = opts.factor || 2;\n          this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n          this.attempts = 0;\n        }\n        /**\n         * Return the backoff duration.\n         *\n         * @return {Number}\n         * @api public\n         */\n\n\n        Backoff.prototype.duration = function () {\n          var ms = this.ms * Math.pow(this.factor, this.attempts++);\n\n          if (this.jitter) {\n            var rand = Math.random();\n            var deviation = Math.floor(rand * this.jitter * ms);\n            ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;\n          }\n\n          return Math.min(ms, this.max) | 0;\n        };\n        /**\n         * Reset the number of attempts.\n         *\n         * @api public\n         */\n\n\n        Backoff.prototype.reset = function () {\n          this.attempts = 0;\n        };\n        /**\n         * Set the minimum duration\n         *\n         * @api public\n         */\n\n\n        Backoff.prototype.setMin = function (min) {\n          this.ms = min;\n        };\n        /**\n         * Set the maximum duration\n         *\n         * @api public\n         */\n\n\n        Backoff.prototype.setMax = function (max) {\n          this.max = max;\n        };\n        /**\n         * Set the jitter\n         *\n         * @api public\n         */\n\n\n        Backoff.prototype.setJitter = function (jitter) {\n          this.jitter = jitter;\n        };\n        /***/\n\n      },\n\n      /***/\n      \"./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js\":\n      /*!*******************************************************************!*\\\n        !*** ./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js ***!\n        \\*******************************************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesBase64ArraybufferLibBase64ArraybufferJs(module, exports) {\n        /*\n         * base64-arraybuffer\n         * https://github.com/niklasvh/base64-arraybuffer\n         *\n         * Copyright (c) 2012 Niklas von Hertzen\n         * Licensed under the MIT license.\n         */\n        (function () {\n          \"use strict\";\n\n          var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; // Use a lookup table to find the index.\n\n          var lookup = new Uint8Array(256);\n\n          for (var i = 0; i < chars.length; i++) {\n            lookup[chars.charCodeAt(i)] = i;\n          }\n\n          exports.encode = function (arraybuffer) {\n            var bytes = new Uint8Array(arraybuffer),\n                i,\n                len = bytes.length,\n                base64 = \"\";\n\n            for (i = 0; i < len; i += 3) {\n              base64 += chars[bytes[i] >> 2];\n              base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n              base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n              base64 += chars[bytes[i + 2] & 63];\n            }\n\n            if (len % 3 === 2) {\n              base64 = base64.substring(0, base64.length - 1) + \"=\";\n            } else if (len % 3 === 1) {\n              base64 = base64.substring(0, base64.length - 2) + \"==\";\n            }\n\n            return base64;\n          };\n\n          exports.decode = function (base64) {\n            var bufferLength = base64.length * 0.75,\n                len = base64.length,\n                i,\n                p = 0,\n                encoded1,\n                encoded2,\n                encoded3,\n                encoded4;\n\n            if (base64[base64.length - 1] === \"=\") {\n              bufferLength--;\n\n              if (base64[base64.length - 2] === \"=\") {\n                bufferLength--;\n              }\n            }\n\n            var arraybuffer = new ArrayBuffer(bufferLength),\n                bytes = new Uint8Array(arraybuffer);\n\n            for (i = 0; i < len; i += 4) {\n              encoded1 = lookup[base64.charCodeAt(i)];\n              encoded2 = lookup[base64.charCodeAt(i + 1)];\n              encoded3 = lookup[base64.charCodeAt(i + 2)];\n              encoded4 = lookup[base64.charCodeAt(i + 3)];\n              bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n              bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n              bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n            }\n\n            return arraybuffer;\n          };\n        })();\n        /***/\n\n      },\n\n      /***/\n      \"./node_modules/component-bind/index.js\":\n      /*!**********************************************!*\\\n        !*** ./node_modules/component-bind/index.js ***!\n        \\**********************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesComponentBindIndexJs(module, exports) {\n        /**\n         * Slice reference.\n         */\n        var slice = [].slice;\n        /**\n         * Bind `obj` to `fn`.\n         *\n         * @param {Object} obj\n         * @param {Function|String} fn or string\n         * @return {Function}\n         * @api public\n         */\n\n        module.exports = function (obj, fn) {\n          if ('string' == typeof fn) fn = obj[fn];\n          if ('function' != typeof fn) throw new Error('bind() requires a function');\n          var args = slice.call(arguments, 2);\n          return function () {\n            return fn.apply(obj, args.concat(slice.call(arguments)));\n          };\n        };\n        /***/\n\n      },\n\n      /***/\n      \"./node_modules/component-emitter/index.js\":\n      /*!*************************************************!*\\\n        !*** ./node_modules/component-emitter/index.js ***!\n        \\*************************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesComponentEmitterIndexJs(module, exports, __webpack_require__) {\n        /**\r\n         * Expose `Emitter`.\r\n         */\n        if (true) {\n          module.exports = Emitter;\n        }\n        /**\r\n         * Initialize a new `Emitter`.\r\n         *\r\n         * @api public\r\n         */\n\n\n        function Emitter(obj) {\n          if (obj) return mixin(obj);\n        }\n\n        ;\n        /**\r\n         * Mixin the emitter properties.\r\n         *\r\n         * @param {Object} obj\r\n         * @return {Object}\r\n         * @api private\r\n         */\n\n        function mixin(obj) {\n          for (var key in Emitter.prototype) {\n            obj[key] = Emitter.prototype[key];\n          }\n\n          return obj;\n        }\n        /**\r\n         * Listen on the given `event` with `fn`.\r\n         *\r\n         * @param {String} event\r\n         * @param {Function} fn\r\n         * @return {Emitter}\r\n         * @api public\r\n         */\n\n\n        Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {\n          this._callbacks = this._callbacks || {};\n          (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);\n          return this;\n        };\n        /**\r\n         * Adds an `event` listener that will be invoked a single\r\n         * time then automatically removed.\r\n         *\r\n         * @param {String} event\r\n         * @param {Function} fn\r\n         * @return {Emitter}\r\n         * @api public\r\n         */\n\n\n        Emitter.prototype.once = function (event, fn) {\n          function on() {\n            this.off(event, on);\n            fn.apply(this, arguments);\n          }\n\n          on.fn = fn;\n          this.on(event, on);\n          return this;\n        };\n        /**\r\n         * Remove the given callback for `event` or all\r\n         * registered callbacks.\r\n         *\r\n         * @param {String} event\r\n         * @param {Function} fn\r\n         * @return {Emitter}\r\n         * @api public\r\n         */\n\n\n        Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {\n          this._callbacks = this._callbacks || {}; // all\n\n          if (0 == arguments.length) {\n            this._callbacks = {};\n            return this;\n          } // specific event\n\n\n          var callbacks = this._callbacks['$' + event];\n          if (!callbacks) return this; // remove all handlers\n\n          if (1 == arguments.length) {\n            delete this._callbacks['$' + event];\n            return this;\n          } // remove specific handler\n\n\n          var cb;\n\n          for (var i = 0; i < callbacks.length; i++) {\n            cb = callbacks[i];\n\n            if (cb === fn || cb.fn === fn) {\n              callbacks.splice(i, 1);\n              break;\n            }\n          } // Remove event specific arrays for event types that no\n          // one is subscribed for to avoid memory leak.\n\n\n          if (callbacks.length === 0) {\n            delete this._callbacks['$' + event];\n          }\n\n          return this;\n        };\n        /**\r\n         * Emit `event` with the given args.\r\n         *\r\n         * @param {String} event\r\n         * @param {Mixed} ...\r\n         * @return {Emitter}\r\n         */\n\n\n        Emitter.prototype.emit = function (event) {\n          this._callbacks = this._callbacks || {};\n          var args = new Array(arguments.length - 1),\n              callbacks = this._callbacks['$' + event];\n\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n\n          if (callbacks) {\n            callbacks = callbacks.slice(0);\n\n            for (var i = 0, len = callbacks.length; i < len; ++i) {\n              callbacks[i].apply(this, args);\n            }\n          }\n\n          return this;\n        };\n        /**\r\n         * Return array of callbacks for `event`.\r\n         *\r\n         * @param {String} event\r\n         * @return {Array}\r\n         * @api public\r\n         */\n\n\n        Emitter.prototype.listeners = function (event) {\n          this._callbacks = this._callbacks || {};\n          return this._callbacks['$' + event] || [];\n        };\n        /**\r\n         * Check if this emitter has `event` handlers.\r\n         *\r\n         * @param {String} event\r\n         * @return {Boolean}\r\n         * @api public\r\n         */\n\n\n        Emitter.prototype.hasListeners = function (event) {\n          return !!this.listeners(event).length;\n        };\n        /***/\n\n      },\n\n      /***/\n      \"./node_modules/debug/src/browser.js\":\n      /*!*******************************************!*\\\n        !*** ./node_modules/debug/src/browser.js ***!\n        \\*******************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesDebugSrcBrowserJs(module, exports, __webpack_require__) {\n        /* WEBPACK VAR INJECTION */\n        (function (process) {\n          function _typeof(obj) {\n            \"@babel/helpers - typeof\";\n\n            if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n              _typeof = function _typeof(obj) {\n                return typeof obj;\n              };\n            } else {\n              _typeof = function _typeof(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n              };\n            }\n\n            return _typeof(obj);\n          }\n          /* eslint-env browser */\n\n          /**\n           * This is the web browser implementation of `debug()`.\n           */\n\n\n          exports.log = log;\n          exports.formatArgs = formatArgs;\n          exports.save = save;\n          exports.load = load;\n          exports.useColors = useColors;\n          exports.storage = localstorage();\n          /**\n           * Colors.\n           */\n\n          exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n          /**\n           * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n           * and the Firebug extension (any Firefox version) are known\n           * to support \"%c\" CSS customizations.\n           *\n           * TODO: add a `localStorage` variable to explicitly enable/disable colors\n           */\n          // eslint-disable-next-line complexity\n\n          function useColors() {\n            // NB: In an Electron preload script, document will be defined but not fully\n            // initialized. Since we know we're in Chrome, we'll just detect this case\n            // explicitly\n            if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n              return true;\n            } // Internet Explorer and Edge do not support colors.\n\n\n            if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n              return false;\n            } // Is webkit? http://stackoverflow.com/a/16459606/376773\n            // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\n\n            return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n            typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\n            // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n            typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n            typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n          }\n          /**\n           * Colorize log arguments if enabled.\n           *\n           * @api public\n           */\n\n\n          function formatArgs(args) {\n            args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);\n\n            if (!this.useColors) {\n              return;\n            }\n\n            var c = 'color: ' + this.color;\n            args.splice(1, 0, c, 'color: inherit'); // The final \"%c\" is somewhat tricky, because there could be other\n            // arguments passed either before or after the %c, so we need to\n            // figure out the correct index to insert the CSS into\n\n            var index = 0;\n            var lastC = 0;\n            args[0].replace(/%[a-zA-Z%]/g, function (match) {\n              if (match === '%%') {\n                return;\n              }\n\n              index++;\n\n              if (match === '%c') {\n                // We only are interested in the *last* %c\n                // (the user may have provided their own)\n                lastC = index;\n              }\n            });\n            args.splice(lastC, 0, c);\n          }\n          /**\n           * Invokes `console.log()` when available.\n           * No-op when `console.log` is not a \"function\".\n           *\n           * @api public\n           */\n\n\n          function log() {\n            var _console; // This hackery is required for IE8/9, where\n            // the `console.log` function doesn't have 'apply'\n\n\n            return (typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);\n          }\n          /**\n           * Save `namespaces`.\n           *\n           * @param {String} namespaces\n           * @api private\n           */\n\n\n          function save(namespaces) {\n            try {\n              if (namespaces) {\n                exports.storage.setItem('debug', namespaces);\n              } else {\n                exports.storage.removeItem('debug');\n              }\n            } catch (error) {// Swallow\n              // XXX (@Qix-) should we be logging these?\n            }\n          }\n          /**\n           * Load `namespaces`.\n           *\n           * @return {String} returns the previously persisted debug modes\n           * @api private\n           */\n\n\n          function load() {\n            var r;\n\n            try {\n              r = exports.storage.getItem('debug');\n            } catch (error) {// Swallow\n              // XXX (@Qix-) should we be logging these?\n            } // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\n\n            if (!r && typeof process !== 'undefined' && 'env' in process) {\n              r = process.env.DEBUG;\n            }\n\n            return r;\n          }\n          /**\n           * Localstorage attempts to return the localstorage.\n           *\n           * This is necessary because safari throws\n           * when a user disables cookies/localstorage\n           * and you attempt to access it.\n           *\n           * @return {LocalStorage}\n           * @api private\n           */\n\n\n          function localstorage() {\n            try {\n              // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n              // The Browser also has localStorage in the global context.\n              return localStorage;\n            } catch (error) {// Swallow\n              // XXX (@Qix-) should we be logging these?\n            }\n          }\n\n          module.exports = __webpack_require__(\n          /*! ./common */\n          \"./node_modules/debug/src/common.js\")(exports);\n          var formatters = module.exports.formatters;\n          /**\n           * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n           */\n\n          formatters.j = function (v) {\n            try {\n              return JSON.stringify(v);\n            } catch (error) {\n              return '[UnexpectedJSONParseError]: ' + error.message;\n            }\n          };\n          /* WEBPACK VAR INJECTION */\n\n        }).call(this, __webpack_require__(\n        /*! ./../../process/browser.js */\n        \"./node_modules/process/browser.js\"));\n        /***/\n      },\n\n      /***/\n      \"./node_modules/debug/src/common.js\":\n      /*!******************************************!*\\\n        !*** ./node_modules/debug/src/common.js ***!\n        \\******************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesDebugSrcCommonJs(module, exports, __webpack_require__) {\n        function _toConsumableArray(arr) {\n          return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n        }\n\n        function _nonIterableSpread() {\n          throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n        }\n\n        function _unsupportedIterableToArray(o, minLen) {\n          if (!o) return;\n          if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n          var n = Object.prototype.toString.call(o).slice(8, -1);\n          if (n === \"Object\" && o.constructor) n = o.constructor.name;\n          if (n === \"Map\" || n === \"Set\") return Array.from(o);\n          if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n        }\n\n        function _iterableToArray(iter) {\n          if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n        }\n\n        function _arrayWithoutHoles(arr) {\n          if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n        }\n\n        function _arrayLikeToArray(arr, len) {\n          if (len == null || len > arr.length) len = arr.length;\n\n          for (var i = 0, arr2 = new Array(len); i < len; i++) {\n            arr2[i] = arr[i];\n          }\n\n          return arr2;\n        }\n        /**\n         * This is the common logic for both the Node.js and web browser\n         * implementations of `debug()`.\n         */\n\n\n        function setup(env) {\n          createDebug.debug = createDebug;\n          createDebug[\"default\"] = createDebug;\n          createDebug.coerce = coerce;\n          createDebug.disable = disable;\n          createDebug.enable = enable;\n          createDebug.enabled = enabled;\n          createDebug.humanize = __webpack_require__(\n          /*! ms */\n          \"./node_modules/ms/index.js\");\n          Object.keys(env).forEach(function (key) {\n            createDebug[key] = env[key];\n          });\n          /**\n          * Active `debug` instances.\n          */\n\n          createDebug.instances = [];\n          /**\n          * The currently active debug mode names, and names to skip.\n          */\n\n          createDebug.names = [];\n          createDebug.skips = [];\n          /**\n          * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n          *\n          * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n          */\n\n          createDebug.formatters = {};\n          /**\n          * Selects a color for a debug namespace\n          * @param {String} namespace The namespace string for the for the debug instance to be colored\n          * @return {Number|String} An ANSI color code for the given namespace\n          * @api private\n          */\n\n          function selectColor(namespace) {\n            var hash = 0;\n\n            for (var i = 0; i < namespace.length; i++) {\n              hash = (hash << 5) - hash + namespace.charCodeAt(i);\n              hash |= 0; // Convert to 32bit integer\n            }\n\n            return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n          }\n\n          createDebug.selectColor = selectColor;\n          /**\n          * Create a debugger with the given `namespace`.\n          *\n          * @param {String} namespace\n          * @return {Function}\n          * @api public\n          */\n\n          function createDebug(namespace) {\n            var prevTime;\n\n            function debug() {\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              } // Disabled?\n\n\n              if (!debug.enabled) {\n                return;\n              }\n\n              var self = debug; // Set `diff` timestamp\n\n              var curr = Number(new Date());\n              var ms = curr - (prevTime || curr);\n              self.diff = ms;\n              self.prev = prevTime;\n              self.curr = curr;\n              prevTime = curr;\n              args[0] = createDebug.coerce(args[0]);\n\n              if (typeof args[0] !== 'string') {\n                // Anything else let's inspect with %O\n                args.unshift('%O');\n              } // Apply any `formatters` transformations\n\n\n              var index = 0;\n              args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n                // If we encounter an escaped % then don't increase the array index\n                if (match === '%%') {\n                  return match;\n                }\n\n                index++;\n                var formatter = createDebug.formatters[format];\n\n                if (typeof formatter === 'function') {\n                  var val = args[index];\n                  match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`\n\n                  args.splice(index, 1);\n                  index--;\n                }\n\n                return match;\n              }); // Apply env-specific formatting (colors, etc.)\n\n              createDebug.formatArgs.call(self, args);\n              var logFn = self.log || createDebug.log;\n              logFn.apply(self, args);\n            }\n\n            debug.namespace = namespace;\n            debug.enabled = createDebug.enabled(namespace);\n            debug.useColors = createDebug.useColors();\n            debug.color = selectColor(namespace);\n            debug.destroy = destroy;\n            debug.extend = extend; // Debug.formatArgs = formatArgs;\n            // debug.rawLog = rawLog;\n            // env-specific initialization logic for debug instances\n\n            if (typeof createDebug.init === 'function') {\n              createDebug.init(debug);\n            }\n\n            createDebug.instances.push(debug);\n            return debug;\n          }\n\n          function destroy() {\n            var index = createDebug.instances.indexOf(this);\n\n            if (index !== -1) {\n              createDebug.instances.splice(index, 1);\n              return true;\n            }\n\n            return false;\n          }\n\n          function extend(namespace, delimiter) {\n            var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n            newDebug.log = this.log;\n            return newDebug;\n          }\n          /**\n          * Enables a debug mode by namespaces. This can include modes\n          * separated by a colon and wildcards.\n          *\n          * @param {String} namespaces\n          * @api public\n          */\n\n\n          function enable(namespaces) {\n            createDebug.save(namespaces);\n            createDebug.names = [];\n            createDebug.skips = [];\n            var i;\n            var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n            var len = split.length;\n\n            for (i = 0; i < len; i++) {\n              if (!split[i]) {\n                // ignore empty strings\n                continue;\n              }\n\n              namespaces = split[i].replace(/\\*/g, '.*?');\n\n              if (namespaces[0] === '-') {\n                createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n              } else {\n                createDebug.names.push(new RegExp('^' + namespaces + '$'));\n              }\n            }\n\n            for (i = 0; i < createDebug.instances.length; i++) {\n              var instance = createDebug.instances[i];\n              instance.enabled = createDebug.enabled(instance.namespace);\n            }\n          }\n          /**\n          * Disable debug output.\n          *\n          * @return {String} namespaces\n          * @api public\n          */\n\n\n          function disable() {\n            var namespaces = [].concat(_toConsumableArray(createDebug.names.map(toNamespace)), _toConsumableArray(createDebug.skips.map(toNamespace).map(function (namespace) {\n              return '-' + namespace;\n            }))).join(',');\n            createDebug.enable('');\n            return namespaces;\n          }\n          /**\n          * Returns true if the given mode name is enabled, false otherwise.\n          *\n          * @param {String} name\n          * @return {Boolean}\n          * @api public\n          */\n\n\n          function enabled(name) {\n            if (name[name.length - 1] === '*') {\n              return true;\n            }\n\n            var i;\n            var len;\n\n            for (i = 0, len = createDebug.skips.length; i < len; i++) {\n              if (createDebug.skips[i].test(name)) {\n                return false;\n              }\n            }\n\n            for (i = 0, len = createDebug.names.length; i < len; i++) {\n              if (createDebug.names[i].test(name)) {\n                return true;\n              }\n            }\n\n            return false;\n          }\n          /**\n          * Convert regexp to namespace\n          *\n          * @param {RegExp} regxep\n          * @return {String} namespace\n          * @api private\n          */\n\n\n          function toNamespace(regexp) {\n            return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, '*');\n          }\n          /**\n          * Coerce `val`.\n          *\n          * @param {Mixed} val\n          * @return {Mixed}\n          * @api private\n          */\n\n\n          function coerce(val) {\n            if (val instanceof Error) {\n              return val.stack || val.message;\n            }\n\n            return val;\n          }\n\n          createDebug.enable(createDebug.load());\n          return createDebug;\n        }\n\n        module.exports = setup;\n        /***/\n      },\n\n      /***/\n      \"./node_modules/engine.io-client/lib/globalThis.browser.js\":\n      /*!*****************************************************************!*\\\n        !*** ./node_modules/engine.io-client/lib/globalThis.browser.js ***!\n        \\*****************************************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesEngineIoClientLibGlobalThisBrowserJs(module, exports) {\n        module.exports = function () {\n          if (typeof self !== \"undefined\") {\n            return self;\n          } else if (typeof window !== \"undefined\") {\n            return window;\n          } else {\n            return Function(\"return this\")();\n          }\n        }();\n        /***/\n\n      },\n\n      /***/\n      \"./node_modules/engine.io-client/lib/index.js\":\n      /*!****************************************************!*\\\n        !*** ./node_modules/engine.io-client/lib/index.js ***!\n        \\****************************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesEngineIoClientLibIndexJs(module, exports, __webpack_require__) {\n        var Socket = __webpack_require__(\n        /*! ./socket */\n        \"./node_modules/engine.io-client/lib/socket.js\");\n\n        module.exports = function (uri, opts) {\n          return new Socket(uri, opts);\n        };\n        /**\n         * Expose deps for legacy compatibility\n         * and standalone browser access.\n         */\n\n\n        module.exports.Socket = Socket;\n        module.exports.protocol = Socket.protocol; // this is an int\n\n        module.exports.Transport = __webpack_require__(\n        /*! ./transport */\n        \"./node_modules/engine.io-client/lib/transport.js\");\n        module.exports.transports = __webpack_require__(\n        /*! ./transports/index */\n        \"./node_modules/engine.io-client/lib/transports/index.js\");\n        module.exports.parser = __webpack_require__(\n        /*! engine.io-parser */\n        \"./node_modules/engine.io-parser/lib/index.js\");\n        /***/\n      },\n\n      /***/\n      \"./node_modules/engine.io-client/lib/socket.js\":\n      /*!*****************************************************!*\\\n        !*** ./node_modules/engine.io-client/lib/socket.js ***!\n        \\*****************************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesEngineIoClientLibSocketJs(module, exports, __webpack_require__) {\n        function _extends() {\n          _extends = Object.assign || function (target) {\n            for (var i = 1; i < arguments.length; i++) {\n              var source = arguments[i];\n\n              for (var key in source) {\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                  target[key] = source[key];\n                }\n              }\n            }\n\n            return target;\n          };\n\n          return _extends.apply(this, arguments);\n        }\n\n        function _typeof(obj) {\n          \"@babel/helpers - typeof\";\n\n          if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n              return typeof obj;\n            };\n          } else {\n            _typeof = function _typeof(obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n          }\n\n          return _typeof(obj);\n        }\n\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        function _defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        function _createClass(Constructor, protoProps, staticProps) {\n          if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) _defineProperties(Constructor, staticProps);\n          return Constructor;\n        }\n\n        function _inherits(subClass, superClass) {\n          if (typeof superClass !== \"function\" && superClass !== null) {\n            throw new TypeError(\"Super expression must either be null or a function\");\n          }\n\n          subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n              value: subClass,\n              writable: true,\n              configurable: true\n            }\n          });\n          if (superClass) _setPrototypeOf(subClass, superClass);\n        }\n\n        function _setPrototypeOf(o, p) {\n          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n            o.__proto__ = p;\n            return o;\n          };\n\n          return _setPrototypeOf(o, p);\n        }\n\n        function _createSuper(Derived) {\n          var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n          return function _createSuperInternal() {\n            var Super = _getPrototypeOf(Derived),\n                result;\n\n            if (hasNativeReflectConstruct) {\n              var NewTarget = _getPrototypeOf(this).constructor;\n\n              result = Reflect.construct(Super, arguments, NewTarget);\n            } else {\n              result = Super.apply(this, arguments);\n            }\n\n            return _possibleConstructorReturn(this, result);\n          };\n        }\n\n        function _possibleConstructorReturn(self, call) {\n          if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n            return call;\n          }\n\n          return _assertThisInitialized(self);\n        }\n\n        function _assertThisInitialized(self) {\n          if (self === void 0) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          }\n\n          return self;\n        }\n\n        function _isNativeReflectConstruct() {\n          if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n          if (Reflect.construct.sham) return false;\n          if (typeof Proxy === \"function\") return true;\n\n          try {\n            Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n            return true;\n          } catch (e) {\n            return false;\n          }\n        }\n\n        function _getPrototypeOf(o) {\n          _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n            return o.__proto__ || Object.getPrototypeOf(o);\n          };\n          return _getPrototypeOf(o);\n        }\n\n        var transports = __webpack_require__(\n        /*! ./transports/index */\n        \"./node_modules/engine.io-client/lib/transports/index.js\");\n\n        var Emitter = __webpack_require__(\n        /*! component-emitter */\n        \"./node_modules/component-emitter/index.js\");\n\n        var debug = __webpack_require__(\n        /*! debug */\n        \"./node_modules/debug/src/browser.js\")(\"engine.io-client:socket\");\n\n        var parser = __webpack_require__(\n        /*! engine.io-parser */\n        \"./node_modules/engine.io-parser/lib/index.js\");\n\n        var parseuri = __webpack_require__(\n        /*! parseuri */\n        \"./node_modules/parseuri/index.js\");\n\n        var parseqs = __webpack_require__(\n        /*! parseqs */\n        \"./node_modules/parseqs/index.js\");\n\n        var Socket = /*#__PURE__*/function (_Emitter) {\n          _inherits(Socket, _Emitter);\n\n          var _super = _createSuper(Socket);\n          /**\n           * Socket constructor.\n           *\n           * @param {String|Object} uri or options\n           * @param {Object} options\n           * @api public\n           */\n\n\n          function Socket(uri) {\n            var _this;\n\n            var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            _classCallCheck(this, Socket);\n\n            _this = _super.call(this);\n\n            if (uri && \"object\" === _typeof(uri)) {\n              opts = uri;\n              uri = null;\n            }\n\n            if (uri) {\n              uri = parseuri(uri);\n              opts.hostname = uri.host;\n              opts.secure = uri.protocol === \"https\" || uri.protocol === \"wss\";\n              opts.port = uri.port;\n              if (uri.query) opts.query = uri.query;\n            } else if (opts.host) {\n              opts.hostname = parseuri(opts.host).host;\n            }\n\n            _this.secure = null != opts.secure ? opts.secure : typeof location !== \"undefined\" && \"https:\" === location.protocol;\n\n            if (opts.hostname && !opts.port) {\n              // if no port is specified manually, use the protocol default\n              opts.port = _this.secure ? \"443\" : \"80\";\n            }\n\n            _this.hostname = opts.hostname || (typeof location !== \"undefined\" ? location.hostname : \"localhost\");\n            _this.port = opts.port || (typeof location !== \"undefined\" && location.port ? location.port : _this.secure ? 443 : 80);\n            _this.transports = opts.transports || [\"polling\", \"websocket\"];\n            _this.readyState = \"\";\n            _this.writeBuffer = [];\n            _this.prevBufferLen = 0;\n            _this.opts = _extends({\n              path: \"/engine.io\",\n              agent: false,\n              withCredentials: false,\n              upgrade: true,\n              jsonp: true,\n              timestampParam: \"t\",\n              policyPort: 843,\n              rememberUpgrade: false,\n              rejectUnauthorized: true,\n              perMessageDeflate: {\n                threshold: 1024\n              },\n              transportOptions: {}\n            }, opts);\n            _this.opts.path = _this.opts.path.replace(/\\/$/, \"\") + \"/\";\n\n            if (typeof _this.opts.query === \"string\") {\n              _this.opts.query = parseqs.decode(_this.opts.query);\n            } // set on handshake\n\n\n            _this.id = null;\n            _this.upgrades = null;\n            _this.pingInterval = null;\n            _this.pingTimeout = null; // set on heartbeat\n\n            _this.pingTimeoutTimer = null;\n\n            _this.open();\n\n            return _this;\n          }\n          /**\n           * Creates transport of the given type.\n           *\n           * @param {String} transport name\n           * @return {Transport}\n           * @api private\n           */\n\n\n          _createClass(Socket, [{\n            key: \"createTransport\",\n            value: function createTransport(name) {\n              debug('creating transport \"%s\"', name);\n              var query = clone(this.opts.query); // append engine.io protocol identifier\n\n              query.EIO = parser.protocol; // transport name\n\n              query.transport = name; // session id if we already have one\n\n              if (this.id) query.sid = this.id;\n\n              var opts = _extends({}, this.opts.transportOptions[name], this.opts, {\n                query: query,\n                socket: this,\n                hostname: this.hostname,\n                secure: this.secure,\n                port: this.port\n              });\n\n              debug(\"options: %j\", opts);\n              return new transports[name](opts);\n            }\n            /**\n             * Initializes transport to use and starts probe.\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"open\",\n            value: function open() {\n              var transport;\n\n              if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf(\"websocket\") !== -1) {\n                transport = \"websocket\";\n              } else if (0 === this.transports.length) {\n                // Emit error on next tick so it can be listened to\n                var self = this;\n                setTimeout(function () {\n                  self.emit(\"error\", \"No transports available\");\n                }, 0);\n                return;\n              } else {\n                transport = this.transports[0];\n              }\n\n              this.readyState = \"opening\"; // Retry with the next transport if the transport is disabled (jsonp: false)\n\n              try {\n                transport = this.createTransport(transport);\n              } catch (e) {\n                debug(\"error while creating transport: %s\", e);\n                this.transports.shift();\n                this.open();\n                return;\n              }\n\n              transport.open();\n              this.setTransport(transport);\n            }\n            /**\n             * Sets the current transport. Disables the existing one (if any).\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"setTransport\",\n            value: function setTransport(transport) {\n              debug(\"setting transport %s\", transport.name);\n              var self = this;\n\n              if (this.transport) {\n                debug(\"clearing existing transport %s\", this.transport.name);\n                this.transport.removeAllListeners();\n              } // set up transport\n\n\n              this.transport = transport; // set up transport listeners\n\n              transport.on(\"drain\", function () {\n                self.onDrain();\n              }).on(\"packet\", function (packet) {\n                self.onPacket(packet);\n              }).on(\"error\", function (e) {\n                self.onError(e);\n              }).on(\"close\", function () {\n                self.onClose(\"transport close\");\n              });\n            }\n            /**\n             * Probes a transport.\n             *\n             * @param {String} transport name\n             * @api private\n             */\n\n          }, {\n            key: \"probe\",\n            value: function probe(name) {\n              debug('probing transport \"%s\"', name);\n              var transport = this.createTransport(name, {\n                probe: 1\n              });\n              var failed = false;\n              var self = this;\n              Socket.priorWebsocketSuccess = false;\n\n              function onTransportOpen() {\n                if (self.onlyBinaryUpgrades) {\n                  var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;\n                  failed = failed || upgradeLosesBinary;\n                }\n\n                if (failed) return;\n                debug('probe transport \"%s\" opened', name);\n                transport.send([{\n                  type: \"ping\",\n                  data: \"probe\"\n                }]);\n                transport.once(\"packet\", function (msg) {\n                  if (failed) return;\n\n                  if (\"pong\" === msg.type && \"probe\" === msg.data) {\n                    debug('probe transport \"%s\" pong', name);\n                    self.upgrading = true;\n                    self.emit(\"upgrading\", transport);\n                    if (!transport) return;\n                    Socket.priorWebsocketSuccess = \"websocket\" === transport.name;\n                    debug('pausing current transport \"%s\"', self.transport.name);\n                    self.transport.pause(function () {\n                      if (failed) return;\n                      if (\"closed\" === self.readyState) return;\n                      debug(\"changing transport and sending upgrade packet\");\n                      cleanup();\n                      self.setTransport(transport);\n                      transport.send([{\n                        type: \"upgrade\"\n                      }]);\n                      self.emit(\"upgrade\", transport);\n                      transport = null;\n                      self.upgrading = false;\n                      self.flush();\n                    });\n                  } else {\n                    debug('probe transport \"%s\" failed', name);\n                    var err = new Error(\"probe error\");\n                    err.transport = transport.name;\n                    self.emit(\"upgradeError\", err);\n                  }\n                });\n              }\n\n              function freezeTransport() {\n                if (failed) return; // Any callback called by transport should be ignored since now\n\n                failed = true;\n                cleanup();\n                transport.close();\n                transport = null;\n              } // Handle any error that happens while probing\n\n\n              function onerror(err) {\n                var error = new Error(\"probe error: \" + err);\n                error.transport = transport.name;\n                freezeTransport();\n                debug('probe transport \"%s\" failed because of error: %s', name, err);\n                self.emit(\"upgradeError\", error);\n              }\n\n              function onTransportClose() {\n                onerror(\"transport closed\");\n              } // When the socket is closed while we're probing\n\n\n              function onclose() {\n                onerror(\"socket closed\");\n              } // When the socket is upgraded while we're probing\n\n\n              function onupgrade(to) {\n                if (transport && to.name !== transport.name) {\n                  debug('\"%s\" works - aborting \"%s\"', to.name, transport.name);\n                  freezeTransport();\n                }\n              } // Remove all listeners on the transport and on self\n\n\n              function cleanup() {\n                transport.removeListener(\"open\", onTransportOpen);\n                transport.removeListener(\"error\", onerror);\n                transport.removeListener(\"close\", onTransportClose);\n                self.removeListener(\"close\", onclose);\n                self.removeListener(\"upgrading\", onupgrade);\n              }\n\n              transport.once(\"open\", onTransportOpen);\n              transport.once(\"error\", onerror);\n              transport.once(\"close\", onTransportClose);\n              this.once(\"close\", onclose);\n              this.once(\"upgrading\", onupgrade);\n              transport.open();\n            }\n            /**\n             * Called when connection is deemed open.\n             *\n             * @api public\n             */\n\n          }, {\n            key: \"onOpen\",\n            value: function onOpen() {\n              debug(\"socket open\");\n              this.readyState = \"open\";\n              Socket.priorWebsocketSuccess = \"websocket\" === this.transport.name;\n              this.emit(\"open\");\n              this.flush(); // we check for `readyState` in case an `open`\n              // listener already closed the socket\n\n              if (\"open\" === this.readyState && this.opts.upgrade && this.transport.pause) {\n                debug(\"starting upgrade probes\");\n                var i = 0;\n                var l = this.upgrades.length;\n\n                for (; i < l; i++) {\n                  this.probe(this.upgrades[i]);\n                }\n              }\n            }\n            /**\n             * Handles a packet.\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"onPacket\",\n            value: function onPacket(packet) {\n              if (\"opening\" === this.readyState || \"open\" === this.readyState || \"closing\" === this.readyState) {\n                debug('socket receive: type \"%s\", data \"%s\"', packet.type, packet.data);\n                this.emit(\"packet\", packet); // Socket is live - any packet counts\n\n                this.emit(\"heartbeat\");\n\n                switch (packet.type) {\n                  case \"open\":\n                    this.onHandshake(JSON.parse(packet.data));\n                    break;\n\n                  case \"ping\":\n                    this.resetPingTimeout();\n                    this.sendPacket(\"pong\");\n                    this.emit(\"pong\");\n                    break;\n\n                  case \"error\":\n                    var err = new Error(\"server error\");\n                    err.code = packet.data;\n                    this.onError(err);\n                    break;\n\n                  case \"message\":\n                    this.emit(\"data\", packet.data);\n                    this.emit(\"message\", packet.data);\n                    break;\n                }\n              } else {\n                debug('packet received with socket readyState \"%s\"', this.readyState);\n              }\n            }\n            /**\n             * Called upon handshake completion.\n             *\n             * @param {Object} handshake obj\n             * @api private\n             */\n\n          }, {\n            key: \"onHandshake\",\n            value: function onHandshake(data) {\n              this.emit(\"handshake\", data);\n              this.id = data.sid;\n              this.transport.query.sid = data.sid;\n              this.upgrades = this.filterUpgrades(data.upgrades);\n              this.pingInterval = data.pingInterval;\n              this.pingTimeout = data.pingTimeout;\n              this.onOpen(); // In case open handler closes socket\n\n              if (\"closed\" === this.readyState) return;\n              this.resetPingTimeout();\n            }\n            /**\n             * Sets and resets ping timeout timer based on server pings.\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"resetPingTimeout\",\n            value: function resetPingTimeout() {\n              var _this2 = this;\n\n              clearTimeout(this.pingTimeoutTimer);\n              this.pingTimeoutTimer = setTimeout(function () {\n                _this2.onClose(\"ping timeout\");\n              }, this.pingInterval + this.pingTimeout);\n            }\n            /**\n             * Called on `drain` event\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"onDrain\",\n            value: function onDrain() {\n              this.writeBuffer.splice(0, this.prevBufferLen); // setting prevBufferLen = 0 is very important\n              // for example, when upgrading, upgrade packet is sent over,\n              // and a nonzero prevBufferLen could cause problems on `drain`\n\n              this.prevBufferLen = 0;\n\n              if (0 === this.writeBuffer.length) {\n                this.emit(\"drain\");\n              } else {\n                this.flush();\n              }\n            }\n            /**\n             * Flush write buffers.\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"flush\",\n            value: function flush() {\n              if (\"closed\" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {\n                debug(\"flushing %d packets in socket\", this.writeBuffer.length);\n                this.transport.send(this.writeBuffer); // keep track of current length of writeBuffer\n                // splice writeBuffer and callbackBuffer on `drain`\n\n                this.prevBufferLen = this.writeBuffer.length;\n                this.emit(\"flush\");\n              }\n            }\n            /**\n             * Sends a message.\n             *\n             * @param {String} message.\n             * @param {Function} callback function.\n             * @param {Object} options.\n             * @return {Socket} for chaining.\n             * @api public\n             */\n\n          }, {\n            key: \"write\",\n            value: function write(msg, options, fn) {\n              this.sendPacket(\"message\", msg, options, fn);\n              return this;\n            }\n          }, {\n            key: \"send\",\n            value: function send(msg, options, fn) {\n              this.sendPacket(\"message\", msg, options, fn);\n              return this;\n            }\n            /**\n             * Sends a packet.\n             *\n             * @param {String} packet type.\n             * @param {String} data.\n             * @param {Object} options.\n             * @param {Function} callback function.\n             * @api private\n             */\n\n          }, {\n            key: \"sendPacket\",\n            value: function sendPacket(type, data, options, fn) {\n              if (\"function\" === typeof data) {\n                fn = data;\n                data = undefined;\n              }\n\n              if (\"function\" === typeof options) {\n                fn = options;\n                options = null;\n              }\n\n              if (\"closing\" === this.readyState || \"closed\" === this.readyState) {\n                return;\n              }\n\n              options = options || {};\n              options.compress = false !== options.compress;\n              var packet = {\n                type: type,\n                data: data,\n                options: options\n              };\n              this.emit(\"packetCreate\", packet);\n              this.writeBuffer.push(packet);\n              if (fn) this.once(\"flush\", fn);\n              this.flush();\n            }\n            /**\n             * Closes the connection.\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"close\",\n            value: function close() {\n              var self = this;\n\n              if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n                this.readyState = \"closing\";\n\n                if (this.writeBuffer.length) {\n                  this.once(\"drain\", function () {\n                    if (this.upgrading) {\n                      waitForUpgrade();\n                    } else {\n                      close();\n                    }\n                  });\n                } else if (this.upgrading) {\n                  waitForUpgrade();\n                } else {\n                  close();\n                }\n              }\n\n              function close() {\n                self.onClose(\"forced close\");\n                debug(\"socket closing - telling transport to close\");\n                self.transport.close();\n              }\n\n              function cleanupAndClose() {\n                self.removeListener(\"upgrade\", cleanupAndClose);\n                self.removeListener(\"upgradeError\", cleanupAndClose);\n                close();\n              }\n\n              function waitForUpgrade() {\n                // wait for upgrade to finish since we can't send packets while pausing a transport\n                self.once(\"upgrade\", cleanupAndClose);\n                self.once(\"upgradeError\", cleanupAndClose);\n              }\n\n              return this;\n            }\n            /**\n             * Called upon transport error\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"onError\",\n            value: function onError(err) {\n              debug(\"socket error %j\", err);\n              Socket.priorWebsocketSuccess = false;\n              this.emit(\"error\", err);\n              this.onClose(\"transport error\", err);\n            }\n            /**\n             * Called upon transport close.\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"onClose\",\n            value: function onClose(reason, desc) {\n              if (\"opening\" === this.readyState || \"open\" === this.readyState || \"closing\" === this.readyState) {\n                debug('socket close with reason: \"%s\"', reason);\n                var self = this; // clear timers\n\n                clearTimeout(this.pingIntervalTimer);\n                clearTimeout(this.pingTimeoutTimer); // stop event from firing again for transport\n\n                this.transport.removeAllListeners(\"close\"); // ensure transport won't stay open\n\n                this.transport.close(); // ignore further transport communication\n\n                this.transport.removeAllListeners(); // set ready state\n\n                this.readyState = \"closed\"; // clear session id\n\n                this.id = null; // emit close event\n\n                this.emit(\"close\", reason, desc); // clean buffers after, so users can still\n                // grab the buffers on `close` event\n\n                self.writeBuffer = [];\n                self.prevBufferLen = 0;\n              }\n            }\n            /**\n             * Filters upgrades, returning only those matching client transports.\n             *\n             * @param {Array} server upgrades\n             * @api private\n             *\n             */\n\n          }, {\n            key: \"filterUpgrades\",\n            value: function filterUpgrades(upgrades) {\n              var filteredUpgrades = [];\n              var i = 0;\n              var j = upgrades.length;\n\n              for (; i < j; i++) {\n                if (~this.transports.indexOf(upgrades[i])) filteredUpgrades.push(upgrades[i]);\n              }\n\n              return filteredUpgrades;\n            }\n          }]);\n\n          return Socket;\n        }(Emitter);\n\n        Socket.priorWebsocketSuccess = false;\n        /**\n         * Protocol version.\n         *\n         * @api public\n         */\n\n        Socket.protocol = parser.protocol; // this is an int\n\n        function clone(obj) {\n          var o = {};\n\n          for (var i in obj) {\n            if (obj.hasOwnProperty(i)) {\n              o[i] = obj[i];\n            }\n          }\n\n          return o;\n        }\n\n        module.exports = Socket;\n        /***/\n      },\n\n      /***/\n      \"./node_modules/engine.io-client/lib/transport.js\":\n      /*!********************************************************!*\\\n        !*** ./node_modules/engine.io-client/lib/transport.js ***!\n        \\********************************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesEngineIoClientLibTransportJs(module, exports, __webpack_require__) {\n        function _typeof(obj) {\n          \"@babel/helpers - typeof\";\n\n          if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n              return typeof obj;\n            };\n          } else {\n            _typeof = function _typeof(obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n          }\n\n          return _typeof(obj);\n        }\n\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        function _defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        function _createClass(Constructor, protoProps, staticProps) {\n          if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) _defineProperties(Constructor, staticProps);\n          return Constructor;\n        }\n\n        function _inherits(subClass, superClass) {\n          if (typeof superClass !== \"function\" && superClass !== null) {\n            throw new TypeError(\"Super expression must either be null or a function\");\n          }\n\n          subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n              value: subClass,\n              writable: true,\n              configurable: true\n            }\n          });\n          if (superClass) _setPrototypeOf(subClass, superClass);\n        }\n\n        function _setPrototypeOf(o, p) {\n          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n            o.__proto__ = p;\n            return o;\n          };\n\n          return _setPrototypeOf(o, p);\n        }\n\n        function _createSuper(Derived) {\n          var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n          return function _createSuperInternal() {\n            var Super = _getPrototypeOf(Derived),\n                result;\n\n            if (hasNativeReflectConstruct) {\n              var NewTarget = _getPrototypeOf(this).constructor;\n\n              result = Reflect.construct(Super, arguments, NewTarget);\n            } else {\n              result = Super.apply(this, arguments);\n            }\n\n            return _possibleConstructorReturn(this, result);\n          };\n        }\n\n        function _possibleConstructorReturn(self, call) {\n          if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n            return call;\n          }\n\n          return _assertThisInitialized(self);\n        }\n\n        function _assertThisInitialized(self) {\n          if (self === void 0) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          }\n\n          return self;\n        }\n\n        function _isNativeReflectConstruct() {\n          if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n          if (Reflect.construct.sham) return false;\n          if (typeof Proxy === \"function\") return true;\n\n          try {\n            Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n            return true;\n          } catch (e) {\n            return false;\n          }\n        }\n\n        function _getPrototypeOf(o) {\n          _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n            return o.__proto__ || Object.getPrototypeOf(o);\n          };\n          return _getPrototypeOf(o);\n        }\n\n        var parser = __webpack_require__(\n        /*! engine.io-parser */\n        \"./node_modules/engine.io-parser/lib/index.js\");\n\n        var Emitter = __webpack_require__(\n        /*! component-emitter */\n        \"./node_modules/component-emitter/index.js\");\n\n        var Transport = /*#__PURE__*/function (_Emitter) {\n          _inherits(Transport, _Emitter);\n\n          var _super = _createSuper(Transport);\n          /**\n           * Transport abstract constructor.\n           *\n           * @param {Object} options.\n           * @api private\n           */\n\n\n          function Transport(opts) {\n            var _this;\n\n            _classCallCheck(this, Transport);\n\n            _this = _super.call(this);\n            _this.opts = opts;\n            _this.query = opts.query;\n            _this.readyState = \"\";\n            _this.socket = opts.socket;\n            return _this;\n          }\n          /**\n           * Emits an error.\n           *\n           * @param {String} str\n           * @return {Transport} for chaining\n           * @api public\n           */\n\n\n          _createClass(Transport, [{\n            key: \"onError\",\n            value: function onError(msg, desc) {\n              var err = new Error(msg);\n              err.type = \"TransportError\";\n              err.description = desc;\n              this.emit(\"error\", err);\n              return this;\n            }\n            /**\n             * Opens the transport.\n             *\n             * @api public\n             */\n\n          }, {\n            key: \"open\",\n            value: function open() {\n              if (\"closed\" === this.readyState || \"\" === this.readyState) {\n                this.readyState = \"opening\";\n                this.doOpen();\n              }\n\n              return this;\n            }\n            /**\n             * Closes the transport.\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"close\",\n            value: function close() {\n              if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n                this.doClose();\n                this.onClose();\n              }\n\n              return this;\n            }\n            /**\n             * Sends multiple packets.\n             *\n             * @param {Array} packets\n             * @api private\n             */\n\n          }, {\n            key: \"send\",\n            value: function send(packets) {\n              if (\"open\" === this.readyState) {\n                this.write(packets);\n              } else {\n                throw new Error(\"Transport not open\");\n              }\n            }\n            /**\n             * Called upon open\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"onOpen\",\n            value: function onOpen() {\n              this.readyState = \"open\";\n              this.writable = true;\n              this.emit(\"open\");\n            }\n            /**\n             * Called with data.\n             *\n             * @param {String} data\n             * @api private\n             */\n\n          }, {\n            key: \"onData\",\n            value: function onData(data) {\n              var packet = parser.decodePacket(data, this.socket.binaryType);\n              this.onPacket(packet);\n            }\n            /**\n             * Called with a decoded packet.\n             */\n\n          }, {\n            key: \"onPacket\",\n            value: function onPacket(packet) {\n              this.emit(\"packet\", packet);\n            }\n            /**\n             * Called upon close.\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"onClose\",\n            value: function onClose() {\n              this.readyState = \"closed\";\n              this.emit(\"close\");\n            }\n          }]);\n\n          return Transport;\n        }(Emitter);\n\n        module.exports = Transport;\n        /***/\n      },\n\n      /***/\n      \"./node_modules/engine.io-client/lib/transports/index.js\":\n      /*!***************************************************************!*\\\n        !*** ./node_modules/engine.io-client/lib/transports/index.js ***!\n        \\***************************************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesEngineIoClientLibTransportsIndexJs(module, exports, __webpack_require__) {\n        var XMLHttpRequest = __webpack_require__(\n        /*! xmlhttprequest-ssl */\n        \"./node_modules/engine.io-client/lib/xmlhttprequest.js\");\n\n        var XHR = __webpack_require__(\n        /*! ./polling-xhr */\n        \"./node_modules/engine.io-client/lib/transports/polling-xhr.js\");\n\n        var JSONP = __webpack_require__(\n        /*! ./polling-jsonp */\n        \"./node_modules/engine.io-client/lib/transports/polling-jsonp.js\");\n\n        var websocket = __webpack_require__(\n        /*! ./websocket */\n        \"./node_modules/engine.io-client/lib/transports/websocket.js\");\n\n        exports.polling = polling;\n        exports.websocket = websocket;\n        /**\n         * Polling transport polymorphic constructor.\n         * Decides on xhr vs jsonp based on feature detection.\n         *\n         * @api private\n         */\n\n        function polling(opts) {\n          var xhr;\n          var xd = false;\n          var xs = false;\n          var jsonp = false !== opts.jsonp;\n\n          if (typeof location !== \"undefined\") {\n            var isSSL = \"https:\" === location.protocol;\n            var port = location.port; // some user agents have empty `location.port`\n\n            if (!port) {\n              port = isSSL ? 443 : 80;\n            }\n\n            xd = opts.hostname !== location.hostname || port !== opts.port;\n            xs = opts.secure !== isSSL;\n          }\n\n          opts.xdomain = xd;\n          opts.xscheme = xs;\n          xhr = new XMLHttpRequest(opts);\n\n          if (\"open\" in xhr && !opts.forceJSONP) {\n            return new XHR(opts);\n          } else {\n            if (!jsonp) throw new Error(\"JSONP disabled\");\n            return new JSONP(opts);\n          }\n        }\n        /***/\n\n      },\n\n      /***/\n      \"./node_modules/engine.io-client/lib/transports/polling-jsonp.js\":\n      /*!***********************************************************************!*\\\n        !*** ./node_modules/engine.io-client/lib/transports/polling-jsonp.js ***!\n        \\***********************************************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesEngineIoClientLibTransportsPollingJsonpJs(module, exports, __webpack_require__) {\n        function _typeof(obj) {\n          \"@babel/helpers - typeof\";\n\n          if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n              return typeof obj;\n            };\n          } else {\n            _typeof = function _typeof(obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n          }\n\n          return _typeof(obj);\n        }\n\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        function _defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        function _createClass(Constructor, protoProps, staticProps) {\n          if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) _defineProperties(Constructor, staticProps);\n          return Constructor;\n        }\n\n        function _get(target, property, receiver) {\n          if (typeof Reflect !== \"undefined\" && Reflect.get) {\n            _get = Reflect.get;\n          } else {\n            _get = function _get(target, property, receiver) {\n              var base = _superPropBase(target, property);\n\n              if (!base) return;\n              var desc = Object.getOwnPropertyDescriptor(base, property);\n\n              if (desc.get) {\n                return desc.get.call(receiver);\n              }\n\n              return desc.value;\n            };\n          }\n\n          return _get(target, property, receiver || target);\n        }\n\n        function _superPropBase(object, property) {\n          while (!Object.prototype.hasOwnProperty.call(object, property)) {\n            object = _getPrototypeOf(object);\n            if (object === null) break;\n          }\n\n          return object;\n        }\n\n        function _inherits(subClass, superClass) {\n          if (typeof superClass !== \"function\" && superClass !== null) {\n            throw new TypeError(\"Super expression must either be null or a function\");\n          }\n\n          subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n              value: subClass,\n              writable: true,\n              configurable: true\n            }\n          });\n          if (superClass) _setPrototypeOf(subClass, superClass);\n        }\n\n        function _setPrototypeOf(o, p) {\n          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n            o.__proto__ = p;\n            return o;\n          };\n\n          return _setPrototypeOf(o, p);\n        }\n\n        function _createSuper(Derived) {\n          var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n          return function _createSuperInternal() {\n            var Super = _getPrototypeOf(Derived),\n                result;\n\n            if (hasNativeReflectConstruct) {\n              var NewTarget = _getPrototypeOf(this).constructor;\n\n              result = Reflect.construct(Super, arguments, NewTarget);\n            } else {\n              result = Super.apply(this, arguments);\n            }\n\n            return _possibleConstructorReturn(this, result);\n          };\n        }\n\n        function _possibleConstructorReturn(self, call) {\n          if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n            return call;\n          }\n\n          return _assertThisInitialized(self);\n        }\n\n        function _assertThisInitialized(self) {\n          if (self === void 0) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          }\n\n          return self;\n        }\n\n        function _isNativeReflectConstruct() {\n          if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n          if (Reflect.construct.sham) return false;\n          if (typeof Proxy === \"function\") return true;\n\n          try {\n            Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n            return true;\n          } catch (e) {\n            return false;\n          }\n        }\n\n        function _getPrototypeOf(o) {\n          _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n            return o.__proto__ || Object.getPrototypeOf(o);\n          };\n          return _getPrototypeOf(o);\n        }\n\n        var Polling = __webpack_require__(\n        /*! ./polling */\n        \"./node_modules/engine.io-client/lib/transports/polling.js\");\n\n        var globalThis = __webpack_require__(\n        /*! ../globalThis */\n        \"./node_modules/engine.io-client/lib/globalThis.browser.js\");\n\n        var rNewline = /\\n/g;\n        var rEscapedNewline = /\\\\n/g;\n        /**\n         * Global JSONP callbacks.\n         */\n\n        var callbacks;\n        /**\n         * Noop.\n         */\n\n        function empty() {}\n\n        var JSONPPolling = /*#__PURE__*/function (_Polling) {\n          _inherits(JSONPPolling, _Polling);\n\n          var _super = _createSuper(JSONPPolling);\n          /**\n           * JSONP Polling constructor.\n           *\n           * @param {Object} opts.\n           * @api public\n           */\n\n\n          function JSONPPolling(opts) {\n            var _this;\n\n            _classCallCheck(this, JSONPPolling);\n\n            _this = _super.call(this, opts);\n            _this.query = _this.query || {}; // define global callbacks array if not present\n            // we do this here (lazily) to avoid unneeded global pollution\n\n            if (!callbacks) {\n              // we need to consider multiple engines in the same page\n              callbacks = globalThis.___eio = globalThis.___eio || [];\n            } // callback identifier\n\n\n            _this.index = callbacks.length; // add callback to jsonp global\n\n            var self = _assertThisInitialized(_this);\n\n            callbacks.push(function (msg) {\n              self.onData(msg);\n            }); // append to query string\n\n            _this.query.j = _this.index; // prevent spurious errors from being emitted when the window is unloaded\n\n            if (typeof addEventListener === \"function\") {\n              addEventListener(\"beforeunload\", function () {\n                if (self.script) self.script.onerror = empty;\n              }, false);\n            }\n\n            return _this;\n          }\n          /**\n           * JSONP only supports binary as base64 encoded strings\n           */\n\n\n          _createClass(JSONPPolling, [{\n            key: \"doClose\",\n\n            /**\n             * Closes the socket.\n             *\n             * @api private\n             */\n            value: function doClose() {\n              if (this.script) {\n                this.script.parentNode.removeChild(this.script);\n                this.script = null;\n              }\n\n              if (this.form) {\n                this.form.parentNode.removeChild(this.form);\n                this.form = null;\n                this.iframe = null;\n              }\n\n              _get(_getPrototypeOf(JSONPPolling.prototype), \"doClose\", this).call(this);\n            }\n            /**\n             * Starts a poll cycle.\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"doPoll\",\n            value: function doPoll() {\n              var self = this;\n              var script = document.createElement(\"script\");\n\n              if (this.script) {\n                this.script.parentNode.removeChild(this.script);\n                this.script = null;\n              }\n\n              script.async = true;\n              script.src = this.uri();\n\n              script.onerror = function (e) {\n                self.onError(\"jsonp poll error\", e);\n              };\n\n              var insertAt = document.getElementsByTagName(\"script\")[0];\n\n              if (insertAt) {\n                insertAt.parentNode.insertBefore(script, insertAt);\n              } else {\n                (document.head || document.body).appendChild(script);\n              }\n\n              this.script = script;\n              var isUAgecko = \"undefined\" !== typeof navigator && /gecko/i.test(navigator.userAgent);\n\n              if (isUAgecko) {\n                setTimeout(function () {\n                  var iframe = document.createElement(\"iframe\");\n                  document.body.appendChild(iframe);\n                  document.body.removeChild(iframe);\n                }, 100);\n              }\n            }\n            /**\n             * Writes with a hidden iframe.\n             *\n             * @param {String} data to send\n             * @param {Function} called upon flush.\n             * @api private\n             */\n\n          }, {\n            key: \"doWrite\",\n            value: function doWrite(data, fn) {\n              var self = this;\n              var iframe;\n\n              if (!this.form) {\n                var form = document.createElement(\"form\");\n                var area = document.createElement(\"textarea\");\n                var id = this.iframeId = \"eio_iframe_\" + this.index;\n                form.className = \"socketio\";\n                form.style.position = \"absolute\";\n                form.style.top = \"-1000px\";\n                form.style.left = \"-1000px\";\n                form.target = id;\n                form.method = \"POST\";\n                form.setAttribute(\"accept-charset\", \"utf-8\");\n                area.name = \"d\";\n                form.appendChild(area);\n                document.body.appendChild(form);\n                this.form = form;\n                this.area = area;\n              }\n\n              this.form.action = this.uri();\n\n              function complete() {\n                initIframe();\n                fn();\n              }\n\n              function initIframe() {\n                if (self.iframe) {\n                  try {\n                    self.form.removeChild(self.iframe);\n                  } catch (e) {\n                    self.onError(\"jsonp polling iframe removal error\", e);\n                  }\n                }\n\n                try {\n                  // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n                  var html = '<iframe src=\"javascript:0\" name=\"' + self.iframeId + '\">';\n                  iframe = document.createElement(html);\n                } catch (e) {\n                  iframe = document.createElement(\"iframe\");\n                  iframe.name = self.iframeId;\n                  iframe.src = \"javascript:0\";\n                }\n\n                iframe.id = self.iframeId;\n                self.form.appendChild(iframe);\n                self.iframe = iframe;\n              }\n\n              initIframe(); // escape \\n to prevent it from being converted into \\r\\n by some UAs\n              // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side\n\n              data = data.replace(rEscapedNewline, \"\\\\\\n\");\n              this.area.value = data.replace(rNewline, \"\\\\n\");\n\n              try {\n                this.form.submit();\n              } catch (e) {}\n\n              if (this.iframe.attachEvent) {\n                this.iframe.onreadystatechange = function () {\n                  if (self.iframe.readyState === \"complete\") {\n                    complete();\n                  }\n                };\n              } else {\n                this.iframe.onload = complete;\n              }\n            }\n          }, {\n            key: \"supportsBinary\",\n            get: function get() {\n              return false;\n            }\n          }]);\n\n          return JSONPPolling;\n        }(Polling);\n\n        module.exports = JSONPPolling;\n        /***/\n      },\n\n      /***/\n      \"./node_modules/engine.io-client/lib/transports/polling-xhr.js\":\n      /*!*********************************************************************!*\\\n        !*** ./node_modules/engine.io-client/lib/transports/polling-xhr.js ***!\n        \\*********************************************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesEngineIoClientLibTransportsPollingXhrJs(module, exports, __webpack_require__) {\n        function _typeof(obj) {\n          \"@babel/helpers - typeof\";\n\n          if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n              return typeof obj;\n            };\n          } else {\n            _typeof = function _typeof(obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n          }\n\n          return _typeof(obj);\n        }\n\n        function _extends() {\n          _extends = Object.assign || function (target) {\n            for (var i = 1; i < arguments.length; i++) {\n              var source = arguments[i];\n\n              for (var key in source) {\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                  target[key] = source[key];\n                }\n              }\n            }\n\n            return target;\n          };\n\n          return _extends.apply(this, arguments);\n        }\n\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        function _defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        function _createClass(Constructor, protoProps, staticProps) {\n          if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) _defineProperties(Constructor, staticProps);\n          return Constructor;\n        }\n\n        function _inherits(subClass, superClass) {\n          if (typeof superClass !== \"function\" && superClass !== null) {\n            throw new TypeError(\"Super expression must either be null or a function\");\n          }\n\n          subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n              value: subClass,\n              writable: true,\n              configurable: true\n            }\n          });\n          if (superClass) _setPrototypeOf(subClass, superClass);\n        }\n\n        function _setPrototypeOf(o, p) {\n          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n            o.__proto__ = p;\n            return o;\n          };\n\n          return _setPrototypeOf(o, p);\n        }\n\n        function _createSuper(Derived) {\n          var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n          return function _createSuperInternal() {\n            var Super = _getPrototypeOf(Derived),\n                result;\n\n            if (hasNativeReflectConstruct) {\n              var NewTarget = _getPrototypeOf(this).constructor;\n\n              result = Reflect.construct(Super, arguments, NewTarget);\n            } else {\n              result = Super.apply(this, arguments);\n            }\n\n            return _possibleConstructorReturn(this, result);\n          };\n        }\n\n        function _possibleConstructorReturn(self, call) {\n          if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n            return call;\n          }\n\n          return _assertThisInitialized(self);\n        }\n\n        function _assertThisInitialized(self) {\n          if (self === void 0) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          }\n\n          return self;\n        }\n\n        function _isNativeReflectConstruct() {\n          if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n          if (Reflect.construct.sham) return false;\n          if (typeof Proxy === \"function\") return true;\n\n          try {\n            Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n            return true;\n          } catch (e) {\n            return false;\n          }\n        }\n\n        function _getPrototypeOf(o) {\n          _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n            return o.__proto__ || Object.getPrototypeOf(o);\n          };\n          return _getPrototypeOf(o);\n        }\n        /* global attachEvent */\n\n\n        var XMLHttpRequest = __webpack_require__(\n        /*! xmlhttprequest-ssl */\n        \"./node_modules/engine.io-client/lib/xmlhttprequest.js\");\n\n        var Polling = __webpack_require__(\n        /*! ./polling */\n        \"./node_modules/engine.io-client/lib/transports/polling.js\");\n\n        var Emitter = __webpack_require__(\n        /*! component-emitter */\n        \"./node_modules/component-emitter/index.js\");\n\n        var _require = __webpack_require__(\n        /*! ../util */\n        \"./node_modules/engine.io-client/lib/util.js\"),\n            pick = _require.pick;\n\n        var globalThis = __webpack_require__(\n        /*! ../globalThis */\n        \"./node_modules/engine.io-client/lib/globalThis.browser.js\");\n\n        var debug = __webpack_require__(\n        /*! debug */\n        \"./node_modules/debug/src/browser.js\")(\"engine.io-client:polling-xhr\");\n        /**\n         * Empty function\n         */\n\n\n        function empty() {}\n\n        var hasXHR2 = function () {\n          var XMLHttpRequest = __webpack_require__(\n          /*! xmlhttprequest-ssl */\n          \"./node_modules/engine.io-client/lib/xmlhttprequest.js\");\n\n          var xhr = new XMLHttpRequest({\n            xdomain: false\n          });\n          return null != xhr.responseType;\n        }();\n\n        var XHR = /*#__PURE__*/function (_Polling) {\n          _inherits(XHR, _Polling);\n\n          var _super = _createSuper(XHR);\n          /**\n           * XHR Polling constructor.\n           *\n           * @param {Object} opts\n           * @api public\n           */\n\n\n          function XHR(opts) {\n            var _this;\n\n            _classCallCheck(this, XHR);\n\n            _this = _super.call(this, opts);\n\n            if (typeof location !== \"undefined\") {\n              var isSSL = \"https:\" === location.protocol;\n              var port = location.port; // some user agents have empty `location.port`\n\n              if (!port) {\n                port = isSSL ? 443 : 80;\n              }\n\n              _this.xd = typeof location !== \"undefined\" && opts.hostname !== location.hostname || port !== opts.port;\n              _this.xs = opts.secure !== isSSL;\n            }\n            /**\n             * XHR supports binary\n             */\n\n\n            var forceBase64 = opts && opts.forceBase64;\n            _this.supportsBinary = hasXHR2 && !forceBase64;\n            return _this;\n          }\n          /**\n           * Creates a request.\n           *\n           * @param {String} method\n           * @api private\n           */\n\n\n          _createClass(XHR, [{\n            key: \"request\",\n            value: function request() {\n              var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n              _extends(opts, {\n                xd: this.xd,\n                xs: this.xs\n              }, this.opts);\n\n              return new Request(this.uri(), opts);\n            }\n            /**\n             * Sends data.\n             *\n             * @param {String} data to send.\n             * @param {Function} called upon flush.\n             * @api private\n             */\n\n          }, {\n            key: \"doWrite\",\n            value: function doWrite(data, fn) {\n              var req = this.request({\n                method: \"POST\",\n                data: data\n              });\n              var self = this;\n              req.on(\"success\", fn);\n              req.on(\"error\", function (err) {\n                self.onError(\"xhr post error\", err);\n              });\n            }\n            /**\n             * Starts a poll cycle.\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"doPoll\",\n            value: function doPoll() {\n              debug(\"xhr poll\");\n              var req = this.request();\n              var self = this;\n              req.on(\"data\", function (data) {\n                self.onData(data);\n              });\n              req.on(\"error\", function (err) {\n                self.onError(\"xhr poll error\", err);\n              });\n              this.pollXhr = req;\n            }\n          }]);\n\n          return XHR;\n        }(Polling);\n\n        var Request = /*#__PURE__*/function (_Emitter) {\n          _inherits(Request, _Emitter);\n\n          var _super2 = _createSuper(Request);\n          /**\n           * Request constructor\n           *\n           * @param {Object} options\n           * @api public\n           */\n\n\n          function Request(uri, opts) {\n            var _this2;\n\n            _classCallCheck(this, Request);\n\n            _this2 = _super2.call(this);\n            _this2.opts = opts;\n            _this2.method = opts.method || \"GET\";\n            _this2.uri = uri;\n            _this2.async = false !== opts.async;\n            _this2.data = undefined !== opts.data ? opts.data : null;\n\n            _this2.create();\n\n            return _this2;\n          }\n          /**\n           * Creates the XHR object and sends the request.\n           *\n           * @api private\n           */\n\n\n          _createClass(Request, [{\n            key: \"create\",\n            value: function create() {\n              var opts = pick(this.opts, \"agent\", \"enablesXDR\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\");\n              opts.xdomain = !!this.opts.xd;\n              opts.xscheme = !!this.opts.xs;\n              var xhr = this.xhr = new XMLHttpRequest(opts);\n              var self = this;\n\n              try {\n                debug(\"xhr open %s: %s\", this.method, this.uri);\n                xhr.open(this.method, this.uri, this.async);\n\n                try {\n                  if (this.opts.extraHeaders) {\n                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n\n                    for (var i in this.opts.extraHeaders) {\n                      if (this.opts.extraHeaders.hasOwnProperty(i)) {\n                        xhr.setRequestHeader(i, this.opts.extraHeaders[i]);\n                      }\n                    }\n                  }\n                } catch (e) {}\n\n                if (\"POST\" === this.method) {\n                  try {\n                    xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n                  } catch (e) {}\n                }\n\n                try {\n                  xhr.setRequestHeader(\"Accept\", \"*/*\");\n                } catch (e) {} // ie6 check\n\n\n                if (\"withCredentials\" in xhr) {\n                  xhr.withCredentials = this.opts.withCredentials;\n                }\n\n                if (this.opts.requestTimeout) {\n                  xhr.timeout = this.opts.requestTimeout;\n                }\n\n                if (this.hasXDR()) {\n                  xhr.onload = function () {\n                    self.onLoad();\n                  };\n\n                  xhr.onerror = function () {\n                    self.onError(xhr.responseText);\n                  };\n                } else {\n                  xhr.onreadystatechange = function () {\n                    if (4 !== xhr.readyState) return;\n\n                    if (200 === xhr.status || 1223 === xhr.status) {\n                      self.onLoad();\n                    } else {\n                      // make sure the `error` event handler that's user-set\n                      // does not throw in the same tick and gets caught here\n                      setTimeout(function () {\n                        self.onError(typeof xhr.status === \"number\" ? xhr.status : 0);\n                      }, 0);\n                    }\n                  };\n                }\n\n                debug(\"xhr data %s\", this.data);\n                xhr.send(this.data);\n              } catch (e) {\n                // Need to defer since .create() is called directly from the constructor\n                // and thus the 'error' event can only be only bound *after* this exception\n                // occurs.  Therefore, also, we cannot throw here at all.\n                setTimeout(function () {\n                  self.onError(e);\n                }, 0);\n                return;\n              }\n\n              if (typeof document !== \"undefined\") {\n                this.index = Request.requestsCount++;\n                Request.requests[this.index] = this;\n              }\n            }\n            /**\n             * Called upon successful response.\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"onSuccess\",\n            value: function onSuccess() {\n              this.emit(\"success\");\n              this.cleanup();\n            }\n            /**\n             * Called if we have data.\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"onData\",\n            value: function onData(data) {\n              this.emit(\"data\", data);\n              this.onSuccess();\n            }\n            /**\n             * Called upon error.\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"onError\",\n            value: function onError(err) {\n              this.emit(\"error\", err);\n              this.cleanup(true);\n            }\n            /**\n             * Cleans up house.\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"cleanup\",\n            value: function cleanup(fromError) {\n              if (\"undefined\" === typeof this.xhr || null === this.xhr) {\n                return;\n              } // xmlhttprequest\n\n\n              if (this.hasXDR()) {\n                this.xhr.onload = this.xhr.onerror = empty;\n              } else {\n                this.xhr.onreadystatechange = empty;\n              }\n\n              if (fromError) {\n                try {\n                  this.xhr.abort();\n                } catch (e) {}\n              }\n\n              if (typeof document !== \"undefined\") {\n                delete Request.requests[this.index];\n              }\n\n              this.xhr = null;\n            }\n            /**\n             * Called upon load.\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"onLoad\",\n            value: function onLoad() {\n              var data = this.xhr.responseText;\n\n              if (data !== null) {\n                this.onData(data);\n              }\n            }\n            /**\n             * Check if it has XDomainRequest.\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"hasXDR\",\n            value: function hasXDR() {\n              return typeof XDomainRequest !== \"undefined\" && !this.xs && this.enablesXDR;\n            }\n            /**\n             * Aborts the request.\n             *\n             * @api public\n             */\n\n          }, {\n            key: \"abort\",\n            value: function abort() {\n              this.cleanup();\n            }\n          }]);\n\n          return Request;\n        }(Emitter);\n        /**\n         * Aborts pending requests when unloading the window. This is needed to prevent\n         * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n         * emitted.\n         */\n\n\n        Request.requestsCount = 0;\n        Request.requests = {};\n\n        if (typeof document !== \"undefined\") {\n          if (typeof attachEvent === \"function\") {\n            attachEvent(\"onunload\", unloadHandler);\n          } else if (typeof addEventListener === \"function\") {\n            var terminationEvent = \"onpagehide\" in globalThis ? \"pagehide\" : \"unload\";\n            addEventListener(terminationEvent, unloadHandler, false);\n          }\n        }\n\n        function unloadHandler() {\n          for (var i in Request.requests) {\n            if (Request.requests.hasOwnProperty(i)) {\n              Request.requests[i].abort();\n            }\n          }\n        }\n\n        module.exports = XHR;\n        module.exports.Request = Request;\n        /***/\n      },\n\n      /***/\n      \"./node_modules/engine.io-client/lib/transports/polling.js\":\n      /*!*****************************************************************!*\\\n        !*** ./node_modules/engine.io-client/lib/transports/polling.js ***!\n        \\*****************************************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesEngineIoClientLibTransportsPollingJs(module, exports, __webpack_require__) {\n        function _typeof(obj) {\n          \"@babel/helpers - typeof\";\n\n          if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n              return typeof obj;\n            };\n          } else {\n            _typeof = function _typeof(obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n          }\n\n          return _typeof(obj);\n        }\n\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        function _defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        function _createClass(Constructor, protoProps, staticProps) {\n          if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) _defineProperties(Constructor, staticProps);\n          return Constructor;\n        }\n\n        function _inherits(subClass, superClass) {\n          if (typeof superClass !== \"function\" && superClass !== null) {\n            throw new TypeError(\"Super expression must either be null or a function\");\n          }\n\n          subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n              value: subClass,\n              writable: true,\n              configurable: true\n            }\n          });\n          if (superClass) _setPrototypeOf(subClass, superClass);\n        }\n\n        function _setPrototypeOf(o, p) {\n          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n            o.__proto__ = p;\n            return o;\n          };\n\n          return _setPrototypeOf(o, p);\n        }\n\n        function _createSuper(Derived) {\n          var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n          return function _createSuperInternal() {\n            var Super = _getPrototypeOf(Derived),\n                result;\n\n            if (hasNativeReflectConstruct) {\n              var NewTarget = _getPrototypeOf(this).constructor;\n\n              result = Reflect.construct(Super, arguments, NewTarget);\n            } else {\n              result = Super.apply(this, arguments);\n            }\n\n            return _possibleConstructorReturn(this, result);\n          };\n        }\n\n        function _possibleConstructorReturn(self, call) {\n          if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n            return call;\n          }\n\n          return _assertThisInitialized(self);\n        }\n\n        function _assertThisInitialized(self) {\n          if (self === void 0) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          }\n\n          return self;\n        }\n\n        function _isNativeReflectConstruct() {\n          if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n          if (Reflect.construct.sham) return false;\n          if (typeof Proxy === \"function\") return true;\n\n          try {\n            Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n            return true;\n          } catch (e) {\n            return false;\n          }\n        }\n\n        function _getPrototypeOf(o) {\n          _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n            return o.__proto__ || Object.getPrototypeOf(o);\n          };\n          return _getPrototypeOf(o);\n        }\n\n        var Transport = __webpack_require__(\n        /*! ../transport */\n        \"./node_modules/engine.io-client/lib/transport.js\");\n\n        var parseqs = __webpack_require__(\n        /*! parseqs */\n        \"./node_modules/parseqs/index.js\");\n\n        var parser = __webpack_require__(\n        /*! engine.io-parser */\n        \"./node_modules/engine.io-parser/lib/index.js\");\n\n        var yeast = __webpack_require__(\n        /*! yeast */\n        \"./node_modules/yeast/index.js\");\n\n        var debug = __webpack_require__(\n        /*! debug */\n        \"./node_modules/debug/src/browser.js\")(\"engine.io-client:polling\");\n\n        var Polling = /*#__PURE__*/function (_Transport) {\n          _inherits(Polling, _Transport);\n\n          var _super = _createSuper(Polling);\n\n          function Polling() {\n            _classCallCheck(this, Polling);\n\n            return _super.apply(this, arguments);\n          }\n\n          _createClass(Polling, [{\n            key: \"doOpen\",\n\n            /**\n             * Opens the socket (triggers polling). We write a PING message to determine\n             * when the transport is open.\n             *\n             * @api private\n             */\n            value: function doOpen() {\n              this.poll();\n            }\n            /**\n             * Pauses polling.\n             *\n             * @param {Function} callback upon buffers are flushed and transport is paused\n             * @api private\n             */\n\n          }, {\n            key: \"pause\",\n            value: function pause(onPause) {\n              var self = this;\n              this.readyState = \"pausing\";\n\n              function pause() {\n                debug(\"paused\");\n                self.readyState = \"paused\";\n                onPause();\n              }\n\n              if (this.polling || !this.writable) {\n                var total = 0;\n\n                if (this.polling) {\n                  debug(\"we are currently polling - waiting to pause\");\n                  total++;\n                  this.once(\"pollComplete\", function () {\n                    debug(\"pre-pause polling complete\");\n                    --total || pause();\n                  });\n                }\n\n                if (!this.writable) {\n                  debug(\"we are currently writing - waiting to pause\");\n                  total++;\n                  this.once(\"drain\", function () {\n                    debug(\"pre-pause writing complete\");\n                    --total || pause();\n                  });\n                }\n              } else {\n                pause();\n              }\n            }\n            /**\n             * Starts polling cycle.\n             *\n             * @api public\n             */\n\n          }, {\n            key: \"poll\",\n            value: function poll() {\n              debug(\"polling\");\n              this.polling = true;\n              this.doPoll();\n              this.emit(\"poll\");\n            }\n            /**\n             * Overloads onData to detect payloads.\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"onData\",\n            value: function onData(data) {\n              var self = this;\n              debug(\"polling got data %s\", data);\n\n              var callback = function callback(packet, index, total) {\n                // if its the first message we consider the transport open\n                if (\"opening\" === self.readyState && packet.type === \"open\") {\n                  self.onOpen();\n                } // if its a close packet, we close the ongoing requests\n\n\n                if (\"close\" === packet.type) {\n                  self.onClose();\n                  return false;\n                } // otherwise bypass onData and handle the message\n\n\n                self.onPacket(packet);\n              }; // decode payload\n\n\n              parser.decodePayload(data, this.socket.binaryType).forEach(callback); // if an event did not trigger closing\n\n              if (\"closed\" !== this.readyState) {\n                // if we got data we're not polling\n                this.polling = false;\n                this.emit(\"pollComplete\");\n\n                if (\"open\" === this.readyState) {\n                  this.poll();\n                } else {\n                  debug('ignoring poll - transport state \"%s\"', this.readyState);\n                }\n              }\n            }\n            /**\n             * For polling, send a close packet.\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"doClose\",\n            value: function doClose() {\n              var self = this;\n\n              function close() {\n                debug(\"writing close packet\");\n                self.write([{\n                  type: \"close\"\n                }]);\n              }\n\n              if (\"open\" === this.readyState) {\n                debug(\"transport open - closing\");\n                close();\n              } else {\n                // in case we're trying to close while\n                // handshaking is in progress (GH-164)\n                debug(\"transport not open - deferring close\");\n                this.once(\"open\", close);\n              }\n            }\n            /**\n             * Writes a packets payload.\n             *\n             * @param {Array} data packets\n             * @param {Function} drain callback\n             * @api private\n             */\n\n          }, {\n            key: \"write\",\n            value: function write(packets) {\n              var _this = this;\n\n              this.writable = false;\n              parser.encodePayload(packets, function (data) {\n                _this.doWrite(data, function () {\n                  _this.writable = true;\n\n                  _this.emit(\"drain\");\n                });\n              });\n            }\n            /**\n             * Generates uri for connection.\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"uri\",\n            value: function uri() {\n              var query = this.query || {};\n              var schema = this.opts.secure ? \"https\" : \"http\";\n              var port = \"\"; // cache busting is forced\n\n              if (false !== this.opts.timestampRequests) {\n                query[this.opts.timestampParam] = yeast();\n              }\n\n              if (!this.supportsBinary && !query.sid) {\n                query.b64 = 1;\n              }\n\n              query = parseqs.encode(query); // avoid port if default for schema\n\n              if (this.opts.port && (\"https\" === schema && Number(this.opts.port) !== 443 || \"http\" === schema && Number(this.opts.port) !== 80)) {\n                port = \":\" + this.opts.port;\n              } // prepend ? to query\n\n\n              if (query.length) {\n                query = \"?\" + query;\n              }\n\n              var ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n              return schema + \"://\" + (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + port + this.opts.path + query;\n            }\n          }, {\n            key: \"name\",\n\n            /**\n             * Transport name.\n             */\n            get: function get() {\n              return \"polling\";\n            }\n          }]);\n\n          return Polling;\n        }(Transport);\n\n        module.exports = Polling;\n        /***/\n      },\n\n      /***/\n      \"./node_modules/engine.io-client/lib/transports/websocket-constructor.browser.js\":\n      /*!***************************************************************************************!*\\\n        !*** ./node_modules/engine.io-client/lib/transports/websocket-constructor.browser.js ***!\n        \\***************************************************************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesEngineIoClientLibTransportsWebsocketConstructorBrowserJs(module, exports, __webpack_require__) {\n        var globalThis = __webpack_require__(\n        /*! ../globalThis */\n        \"./node_modules/engine.io-client/lib/globalThis.browser.js\");\n\n        module.exports = {\n          WebSocket: globalThis.WebSocket || globalThis.MozWebSocket,\n          usingBrowserWebSocket: true,\n          defaultBinaryType: \"arraybuffer\"\n        };\n        /***/\n      },\n\n      /***/\n      \"./node_modules/engine.io-client/lib/transports/websocket.js\":\n      /*!*******************************************************************!*\\\n        !*** ./node_modules/engine.io-client/lib/transports/websocket.js ***!\n        \\*******************************************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesEngineIoClientLibTransportsWebsocketJs(module, exports, __webpack_require__) {\n        function _typeof(obj) {\n          \"@babel/helpers - typeof\";\n\n          if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n              return typeof obj;\n            };\n          } else {\n            _typeof = function _typeof(obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n          }\n\n          return _typeof(obj);\n        }\n\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        function _defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        function _createClass(Constructor, protoProps, staticProps) {\n          if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) _defineProperties(Constructor, staticProps);\n          return Constructor;\n        }\n\n        function _inherits(subClass, superClass) {\n          if (typeof superClass !== \"function\" && superClass !== null) {\n            throw new TypeError(\"Super expression must either be null or a function\");\n          }\n\n          subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n              value: subClass,\n              writable: true,\n              configurable: true\n            }\n          });\n          if (superClass) _setPrototypeOf(subClass, superClass);\n        }\n\n        function _setPrototypeOf(o, p) {\n          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n            o.__proto__ = p;\n            return o;\n          };\n\n          return _setPrototypeOf(o, p);\n        }\n\n        function _createSuper(Derived) {\n          var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n          return function _createSuperInternal() {\n            var Super = _getPrototypeOf(Derived),\n                result;\n\n            if (hasNativeReflectConstruct) {\n              var NewTarget = _getPrototypeOf(this).constructor;\n\n              result = Reflect.construct(Super, arguments, NewTarget);\n            } else {\n              result = Super.apply(this, arguments);\n            }\n\n            return _possibleConstructorReturn(this, result);\n          };\n        }\n\n        function _possibleConstructorReturn(self, call) {\n          if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n            return call;\n          }\n\n          return _assertThisInitialized(self);\n        }\n\n        function _assertThisInitialized(self) {\n          if (self === void 0) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          }\n\n          return self;\n        }\n\n        function _isNativeReflectConstruct() {\n          if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n          if (Reflect.construct.sham) return false;\n          if (typeof Proxy === \"function\") return true;\n\n          try {\n            Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n            return true;\n          } catch (e) {\n            return false;\n          }\n        }\n\n        function _getPrototypeOf(o) {\n          _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n            return o.__proto__ || Object.getPrototypeOf(o);\n          };\n          return _getPrototypeOf(o);\n        }\n\n        var Transport = __webpack_require__(\n        /*! ../transport */\n        \"./node_modules/engine.io-client/lib/transport.js\");\n\n        var parser = __webpack_require__(\n        /*! engine.io-parser */\n        \"./node_modules/engine.io-parser/lib/index.js\");\n\n        var parseqs = __webpack_require__(\n        /*! parseqs */\n        \"./node_modules/parseqs/index.js\");\n\n        var yeast = __webpack_require__(\n        /*! yeast */\n        \"./node_modules/yeast/index.js\");\n\n        var _require = __webpack_require__(\n        /*! ../util */\n        \"./node_modules/engine.io-client/lib/util.js\"),\n            pick = _require.pick;\n\n        var _require2 = __webpack_require__(\n        /*! ./websocket-constructor */\n        \"./node_modules/engine.io-client/lib/transports/websocket-constructor.browser.js\"),\n            WebSocket = _require2.WebSocket,\n            usingBrowserWebSocket = _require2.usingBrowserWebSocket,\n            defaultBinaryType = _require2.defaultBinaryType;\n\n        var debug = __webpack_require__(\n        /*! debug */\n        \"./node_modules/debug/src/browser.js\")(\"engine.io-client:websocket\"); // detect ReactNative environment\n\n\n        var isReactNative = typeof navigator !== \"undefined\" && typeof navigator.product === \"string\" && navigator.product.toLowerCase() === \"reactnative\";\n\n        var WS = /*#__PURE__*/function (_Transport) {\n          _inherits(WS, _Transport);\n\n          var _super = _createSuper(WS);\n          /**\n           * WebSocket transport constructor.\n           *\n           * @api {Object} connection options\n           * @api public\n           */\n\n\n          function WS(opts) {\n            var _this;\n\n            _classCallCheck(this, WS);\n\n            _this = _super.call(this, opts);\n            _this.supportsBinary = !opts.forceBase64;\n            return _this;\n          }\n          /**\n           * Transport name.\n           *\n           * @api public\n           */\n\n\n          _createClass(WS, [{\n            key: \"doOpen\",\n\n            /**\n             * Opens socket.\n             *\n             * @api private\n             */\n            value: function doOpen() {\n              if (!this.check()) {\n                // let probe timeout\n                return;\n              }\n\n              var uri = this.uri();\n              var protocols = this.opts.protocols; // React Native only supports the 'headers' option, and will print a warning if anything else is passed\n\n              var opts = isReactNative ? {} : pick(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\");\n\n              if (this.opts.extraHeaders) {\n                opts.headers = this.opts.extraHeaders;\n              }\n\n              try {\n                this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket(uri, protocols) : new WebSocket(uri) : new WebSocket(uri, protocols, opts);\n              } catch (err) {\n                return this.emit(\"error\", err);\n              }\n\n              this.ws.binaryType = this.socket.binaryType || defaultBinaryType;\n              this.addEventListeners();\n            }\n            /**\n             * Adds event listeners to the socket\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"addEventListeners\",\n            value: function addEventListeners() {\n              var self = this;\n\n              this.ws.onopen = function () {\n                self.onOpen();\n              };\n\n              this.ws.onclose = function () {\n                self.onClose();\n              };\n\n              this.ws.onmessage = function (ev) {\n                self.onData(ev.data);\n              };\n\n              this.ws.onerror = function (e) {\n                self.onError(\"websocket error\", e);\n              };\n            }\n            /**\n             * Writes data to socket.\n             *\n             * @param {Array} array of packets.\n             * @api private\n             */\n\n          }, {\n            key: \"write\",\n            value: function write(packets) {\n              var self = this;\n              this.writable = false; // encodePacket efficient as it uses WS framing\n              // no need for encodePayload\n\n              var total = packets.length;\n              var i = 0;\n              var l = total;\n\n              for (; i < l; i++) {\n                (function (packet) {\n                  parser.encodePacket(packet, self.supportsBinary, function (data) {\n                    // always create a new object (GH-437)\n                    var opts = {};\n\n                    if (!usingBrowserWebSocket) {\n                      if (packet.options) {\n                        opts.compress = packet.options.compress;\n                      }\n\n                      if (self.opts.perMessageDeflate) {\n                        var len = \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n\n                        if (len < self.opts.perMessageDeflate.threshold) {\n                          opts.compress = false;\n                        }\n                      }\n                    } // Sometimes the websocket has already been closed but the browser didn't\n                    // have a chance of informing us about it yet, in that case send will\n                    // throw an error\n\n\n                    try {\n                      if (usingBrowserWebSocket) {\n                        // TypeError is thrown when passing the second argument on Safari\n                        self.ws.send(data);\n                      } else {\n                        self.ws.send(data, opts);\n                      }\n                    } catch (e) {\n                      debug(\"websocket closed before onclose event\");\n                    }\n\n                    --total || done();\n                  });\n                })(packets[i]);\n              }\n\n              function done() {\n                self.emit(\"flush\"); // fake drain\n                // defer to next tick to allow Socket to clear writeBuffer\n\n                setTimeout(function () {\n                  self.writable = true;\n                  self.emit(\"drain\");\n                }, 0);\n              }\n            }\n            /**\n             * Called upon close\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"onClose\",\n            value: function onClose() {\n              Transport.prototype.onClose.call(this);\n            }\n            /**\n             * Closes socket.\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"doClose\",\n            value: function doClose() {\n              if (typeof this.ws !== \"undefined\") {\n                this.ws.close();\n              }\n            }\n            /**\n             * Generates uri for connection.\n             *\n             * @api private\n             */\n\n          }, {\n            key: \"uri\",\n            value: function uri() {\n              var query = this.query || {};\n              var schema = this.opts.secure ? \"wss\" : \"ws\";\n              var port = \"\"; // avoid port if default for schema\n\n              if (this.opts.port && (\"wss\" === schema && Number(this.opts.port) !== 443 || \"ws\" === schema && Number(this.opts.port) !== 80)) {\n                port = \":\" + this.opts.port;\n              } // append timestamp to URI\n\n\n              if (this.opts.timestampRequests) {\n                query[this.opts.timestampParam] = yeast();\n              } // communicate binary support capabilities\n\n\n              if (!this.supportsBinary) {\n                query.b64 = 1;\n              }\n\n              query = parseqs.encode(query); // prepend ? to query\n\n              if (query.length) {\n                query = \"?\" + query;\n              }\n\n              var ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n              return schema + \"://\" + (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + port + this.opts.path + query;\n            }\n            /**\n             * Feature detection for WebSocket.\n             *\n             * @return {Boolean} whether this transport is available.\n             * @api public\n             */\n\n          }, {\n            key: \"check\",\n            value: function check() {\n              return !!WebSocket && !(\"__initialize\" in WebSocket && this.name === WS.prototype.name);\n            }\n          }, {\n            key: \"name\",\n            get: function get() {\n              return \"websocket\";\n            }\n          }]);\n\n          return WS;\n        }(Transport);\n\n        module.exports = WS;\n        /***/\n      },\n\n      /***/\n      \"./node_modules/engine.io-client/lib/util.js\":\n      /*!***************************************************!*\\\n        !*** ./node_modules/engine.io-client/lib/util.js ***!\n        \\***************************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesEngineIoClientLibUtilJs(module, exports) {\n        module.exports.pick = function (obj) {\n          for (var _len = arguments.length, attr = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            attr[_key - 1] = arguments[_key];\n          }\n\n          return attr.reduce(function (acc, k) {\n            acc[k] = obj[k];\n            return acc;\n          }, {});\n        };\n        /***/\n\n      },\n\n      /***/\n      \"./node_modules/engine.io-client/lib/xmlhttprequest.js\":\n      /*!*************************************************************!*\\\n        !*** ./node_modules/engine.io-client/lib/xmlhttprequest.js ***!\n        \\*************************************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesEngineIoClientLibXmlhttprequestJs(module, exports, __webpack_require__) {\n        // browser shim for xmlhttprequest module\n        var hasCORS = __webpack_require__(\n        /*! has-cors */\n        \"./node_modules/has-cors/index.js\");\n\n        var globalThis = __webpack_require__(\n        /*! ./globalThis */\n        \"./node_modules/engine.io-client/lib/globalThis.browser.js\");\n\n        module.exports = function (opts) {\n          var xdomain = opts.xdomain; // scheme must be same when usign XDomainRequest\n          // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx\n\n          var xscheme = opts.xscheme; // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.\n          // https://github.com/Automattic/engine.io-client/pull/217\n\n          var enablesXDR = opts.enablesXDR; // XMLHttpRequest can be disabled on IE\n\n          try {\n            if (\"undefined\" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {\n              return new XMLHttpRequest();\n            }\n          } catch (e) {} // Use XDomainRequest for IE8 if enablesXDR is true\n          // because loading bar keeps flashing when using jsonp-polling\n          // https://github.com/yujiosaka/socke.io-ie8-loading-example\n\n\n          try {\n            if (\"undefined\" !== typeof XDomainRequest && !xscheme && enablesXDR) {\n              return new XDomainRequest();\n            }\n          } catch (e) {}\n\n          if (!xdomain) {\n            try {\n              return new globalThis[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n            } catch (e) {}\n          }\n        };\n        /***/\n\n      },\n\n      /***/\n      \"./node_modules/engine.io-parser/lib/commons.js\":\n      /*!******************************************************!*\\\n        !*** ./node_modules/engine.io-parser/lib/commons.js ***!\n        \\******************************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesEngineIoParserLibCommonsJs(module, exports) {\n        var PACKET_TYPES = Object.create(null); // no Map = no polyfill\n\n        PACKET_TYPES[\"open\"] = \"0\";\n        PACKET_TYPES[\"close\"] = \"1\";\n        PACKET_TYPES[\"ping\"] = \"2\";\n        PACKET_TYPES[\"pong\"] = \"3\";\n        PACKET_TYPES[\"message\"] = \"4\";\n        PACKET_TYPES[\"upgrade\"] = \"5\";\n        PACKET_TYPES[\"noop\"] = \"6\";\n        var PACKET_TYPES_REVERSE = Object.create(null);\n        Object.keys(PACKET_TYPES).forEach(function (key) {\n          PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;\n        });\n        var ERROR_PACKET = {\n          type: \"error\",\n          data: \"parser error\"\n        };\n        module.exports = {\n          PACKET_TYPES: PACKET_TYPES,\n          PACKET_TYPES_REVERSE: PACKET_TYPES_REVERSE,\n          ERROR_PACKET: ERROR_PACKET\n        };\n        /***/\n      },\n\n      /***/\n      \"./node_modules/engine.io-parser/lib/decodePacket.browser.js\":\n      /*!*******************************************************************!*\\\n        !*** ./node_modules/engine.io-parser/lib/decodePacket.browser.js ***!\n        \\*******************************************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesEngineIoParserLibDecodePacketBrowserJs(module, exports, __webpack_require__) {\n        var _require = __webpack_require__(\n        /*! ./commons */\n        \"./node_modules/engine.io-parser/lib/commons.js\"),\n            PACKET_TYPES_REVERSE = _require.PACKET_TYPES_REVERSE,\n            ERROR_PACKET = _require.ERROR_PACKET;\n\n        var withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n        var base64decoder;\n\n        if (withNativeArrayBuffer) {\n          base64decoder = __webpack_require__(\n          /*! base64-arraybuffer */\n          \"./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js\");\n        }\n\n        var decodePacket = function decodePacket(encodedPacket, binaryType) {\n          if (typeof encodedPacket !== \"string\") {\n            return {\n              type: \"message\",\n              data: mapBinary(encodedPacket, binaryType)\n            };\n          }\n\n          var type = encodedPacket.charAt(0);\n\n          if (type === \"b\") {\n            return {\n              type: \"message\",\n              data: decodeBase64Packet(encodedPacket.substring(1), binaryType)\n            };\n          }\n\n          var packetType = PACKET_TYPES_REVERSE[type];\n\n          if (!packetType) {\n            return ERROR_PACKET;\n          }\n\n          return encodedPacket.length > 1 ? {\n            type: PACKET_TYPES_REVERSE[type],\n            data: encodedPacket.substring(1)\n          } : {\n            type: PACKET_TYPES_REVERSE[type]\n          };\n        };\n\n        var decodeBase64Packet = function decodeBase64Packet(data, binaryType) {\n          if (base64decoder) {\n            var decoded = base64decoder.decode(data);\n            return mapBinary(decoded, binaryType);\n          } else {\n            return {\n              base64: true,\n              data: data\n            }; // fallback for old browsers\n          }\n        };\n\n        var mapBinary = function mapBinary(data, binaryType) {\n          switch (binaryType) {\n            case \"blob\":\n              return data instanceof ArrayBuffer ? new Blob([data]) : data;\n\n            case \"arraybuffer\":\n            default:\n              return data;\n            // assuming the data is already an ArrayBuffer\n          }\n        };\n\n        module.exports = decodePacket;\n        /***/\n      },\n\n      /***/\n      \"./node_modules/engine.io-parser/lib/encodePacket.browser.js\":\n      /*!*******************************************************************!*\\\n        !*** ./node_modules/engine.io-parser/lib/encodePacket.browser.js ***!\n        \\*******************************************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesEngineIoParserLibEncodePacketBrowserJs(module, exports, __webpack_require__) {\n        var _require = __webpack_require__(\n        /*! ./commons */\n        \"./node_modules/engine.io-parser/lib/commons.js\"),\n            PACKET_TYPES = _require.PACKET_TYPES;\n\n        var withNativeBlob = typeof Blob === \"function\" || typeof Blob !== \"undefined\" && Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\";\n        var withNativeArrayBuffer = typeof ArrayBuffer === \"function\"; // ArrayBuffer.isView method is not defined in IE10\n\n        var isView = function isView(obj) {\n          return typeof ArrayBuffer.isView === \"function\" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;\n        };\n\n        var encodePacket = function encodePacket(_ref, supportsBinary, callback) {\n          var type = _ref.type,\n              data = _ref.data;\n\n          if (withNativeBlob && data instanceof Blob) {\n            if (supportsBinary) {\n              return callback(data);\n            } else {\n              return encodeBlobAsBase64(data, callback);\n            }\n          } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {\n            if (supportsBinary) {\n              return callback(data instanceof ArrayBuffer ? data : data.buffer);\n            } else {\n              return encodeBlobAsBase64(new Blob([data]), callback);\n            }\n          } // plain string\n\n\n          return callback(PACKET_TYPES[type] + (data || \"\"));\n        };\n\n        var encodeBlobAsBase64 = function encodeBlobAsBase64(data, callback) {\n          var fileReader = new FileReader();\n\n          fileReader.onload = function () {\n            var content = fileReader.result.split(\",\")[1];\n            callback(\"b\" + content);\n          };\n\n          return fileReader.readAsDataURL(data);\n        };\n\n        module.exports = encodePacket;\n        /***/\n      },\n\n      /***/\n      \"./node_modules/engine.io-parser/lib/index.js\":\n      /*!****************************************************!*\\\n        !*** ./node_modules/engine.io-parser/lib/index.js ***!\n        \\****************************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesEngineIoParserLibIndexJs(module, exports, __webpack_require__) {\n        var encodePacket = __webpack_require__(\n        /*! ./encodePacket */\n        \"./node_modules/engine.io-parser/lib/encodePacket.browser.js\");\n\n        var decodePacket = __webpack_require__(\n        /*! ./decodePacket */\n        \"./node_modules/engine.io-parser/lib/decodePacket.browser.js\");\n\n        var SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\n\n        var encodePayload = function encodePayload(packets, callback) {\n          // some packets may be added to the array while encoding, so the initial length must be saved\n          var length = packets.length;\n          var encodedPackets = new Array(length);\n          var count = 0;\n          packets.forEach(function (packet, i) {\n            // force base64 encoding for binary packets\n            encodePacket(packet, false, function (encodedPacket) {\n              encodedPackets[i] = encodedPacket;\n\n              if (++count === length) {\n                callback(encodedPackets.join(SEPARATOR));\n              }\n            });\n          });\n        };\n\n        var decodePayload = function decodePayload(encodedPayload, binaryType) {\n          var encodedPackets = encodedPayload.split(SEPARATOR);\n          var packets = [];\n\n          for (var i = 0; i < encodedPackets.length; i++) {\n            var decodedPacket = decodePacket(encodedPackets[i], binaryType);\n            packets.push(decodedPacket);\n\n            if (decodedPacket.type === \"error\") {\n              break;\n            }\n          }\n\n          return packets;\n        };\n\n        module.exports = {\n          protocol: 4,\n          encodePacket: encodePacket,\n          encodePayload: encodePayload,\n          decodePacket: decodePacket,\n          decodePayload: decodePayload\n        };\n        /***/\n      },\n\n      /***/\n      \"./node_modules/has-cors/index.js\":\n      /*!****************************************!*\\\n        !*** ./node_modules/has-cors/index.js ***!\n        \\****************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesHasCorsIndexJs(module, exports) {\n        /**\n         * Module exports.\n         *\n         * Logic borrowed from Modernizr:\n         *\n         *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js\n         */\n        try {\n          module.exports = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();\n        } catch (err) {\n          // if XMLHttp support is disabled in IE then it will throw\n          // when trying to create\n          module.exports = false;\n        }\n        /***/\n\n      },\n\n      /***/\n      \"./node_modules/ms/index.js\":\n      /*!**********************************!*\\\n        !*** ./node_modules/ms/index.js ***!\n        \\**********************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesMsIndexJs(module, exports) {\n        function _typeof(obj) {\n          \"@babel/helpers - typeof\";\n\n          if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n              return typeof obj;\n            };\n          } else {\n            _typeof = function _typeof(obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n          }\n\n          return _typeof(obj);\n        }\n        /**\n         * Helpers.\n         */\n\n\n        var s = 1000;\n        var m = s * 60;\n        var h = m * 60;\n        var d = h * 24;\n        var w = d * 7;\n        var y = d * 365.25;\n        /**\n         * Parse or format the given `val`.\n         *\n         * Options:\n         *\n         *  - `long` verbose formatting [false]\n         *\n         * @param {String|Number} val\n         * @param {Object} [options]\n         * @throws {Error} throw an error if val is not a non-empty string or a number\n         * @return {String|Number}\n         * @api public\n         */\n\n        module.exports = function (val, options) {\n          options = options || {};\n\n          var type = _typeof(val);\n\n          if (type === 'string' && val.length > 0) {\n            return parse(val);\n          } else if (type === 'number' && isFinite(val)) {\n            return options[\"long\"] ? fmtLong(val) : fmtShort(val);\n          }\n\n          throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\n        };\n        /**\n         * Parse the given `str` and return milliseconds.\n         *\n         * @param {String} str\n         * @return {Number}\n         * @api private\n         */\n\n\n        function parse(str) {\n          str = String(str);\n\n          if (str.length > 100) {\n            return;\n          }\n\n          var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n\n          if (!match) {\n            return;\n          }\n\n          var n = parseFloat(match[1]);\n          var type = (match[2] || 'ms').toLowerCase();\n\n          switch (type) {\n            case 'years':\n            case 'year':\n            case 'yrs':\n            case 'yr':\n            case 'y':\n              return n * y;\n\n            case 'weeks':\n            case 'week':\n            case 'w':\n              return n * w;\n\n            case 'days':\n            case 'day':\n            case 'd':\n              return n * d;\n\n            case 'hours':\n            case 'hour':\n            case 'hrs':\n            case 'hr':\n            case 'h':\n              return n * h;\n\n            case 'minutes':\n            case 'minute':\n            case 'mins':\n            case 'min':\n            case 'm':\n              return n * m;\n\n            case 'seconds':\n            case 'second':\n            case 'secs':\n            case 'sec':\n            case 's':\n              return n * s;\n\n            case 'milliseconds':\n            case 'millisecond':\n            case 'msecs':\n            case 'msec':\n            case 'ms':\n              return n;\n\n            default:\n              return undefined;\n          }\n        }\n        /**\n         * Short format for `ms`.\n         *\n         * @param {Number} ms\n         * @return {String}\n         * @api private\n         */\n\n\n        function fmtShort(ms) {\n          var msAbs = Math.abs(ms);\n\n          if (msAbs >= d) {\n            return Math.round(ms / d) + 'd';\n          }\n\n          if (msAbs >= h) {\n            return Math.round(ms / h) + 'h';\n          }\n\n          if (msAbs >= m) {\n            return Math.round(ms / m) + 'm';\n          }\n\n          if (msAbs >= s) {\n            return Math.round(ms / s) + 's';\n          }\n\n          return ms + 'ms';\n        }\n        /**\n         * Long format for `ms`.\n         *\n         * @param {Number} ms\n         * @return {String}\n         * @api private\n         */\n\n\n        function fmtLong(ms) {\n          var msAbs = Math.abs(ms);\n\n          if (msAbs >= d) {\n            return plural(ms, msAbs, d, 'day');\n          }\n\n          if (msAbs >= h) {\n            return plural(ms, msAbs, h, 'hour');\n          }\n\n          if (msAbs >= m) {\n            return plural(ms, msAbs, m, 'minute');\n          }\n\n          if (msAbs >= s) {\n            return plural(ms, msAbs, s, 'second');\n          }\n\n          return ms + ' ms';\n        }\n        /**\n         * Pluralization helper.\n         */\n\n\n        function plural(ms, msAbs, n, name) {\n          var isPlural = msAbs >= n * 1.5;\n          return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n        }\n        /***/\n\n      },\n\n      /***/\n      \"./node_modules/parseqs/index.js\":\n      /*!***************************************!*\\\n        !*** ./node_modules/parseqs/index.js ***!\n        \\***************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesParseqsIndexJs(module, exports) {\n        /**\n         * Compiles a querystring\n         * Returns string representation of the object\n         *\n         * @param {Object}\n         * @api private\n         */\n        exports.encode = function (obj) {\n          var str = '';\n\n          for (var i in obj) {\n            if (obj.hasOwnProperty(i)) {\n              if (str.length) str += '&';\n              str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\n            }\n          }\n\n          return str;\n        };\n        /**\n         * Parses a simple querystring into an object\n         *\n         * @param {String} qs\n         * @api private\n         */\n\n\n        exports.decode = function (qs) {\n          var qry = {};\n          var pairs = qs.split('&');\n\n          for (var i = 0, l = pairs.length; i < l; i++) {\n            var pair = pairs[i].split('=');\n            qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n          }\n\n          return qry;\n        };\n        /***/\n\n      },\n\n      /***/\n      \"./node_modules/parseuri/index.js\":\n      /*!****************************************!*\\\n        !*** ./node_modules/parseuri/index.js ***!\n        \\****************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesParseuriIndexJs(module, exports) {\n        /**\n         * Parses an URI\n         *\n         * @author Steven Levithan <stevenlevithan.com> (MIT license)\n         * @api private\n         */\n        var re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n        var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];\n\n        module.exports = function parseuri(str) {\n          var src = str,\n              b = str.indexOf('['),\n              e = str.indexOf(']');\n\n          if (b != -1 && e != -1) {\n            str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\n          }\n\n          var m = re.exec(str || ''),\n              uri = {},\n              i = 14;\n\n          while (i--) {\n            uri[parts[i]] = m[i] || '';\n          }\n\n          if (b != -1 && e != -1) {\n            uri.source = src;\n            uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\n            uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\n            uri.ipv6uri = true;\n          }\n\n          uri.pathNames = pathNames(uri, uri['path']);\n          uri.queryKey = queryKey(uri, uri['query']);\n          return uri;\n        };\n\n        function pathNames(obj, path) {\n          var regx = /\\/{2,9}/g,\n              names = path.replace(regx, \"/\").split(\"/\");\n\n          if (path.substr(0, 1) == '/' || path.length === 0) {\n            names.splice(0, 1);\n          }\n\n          if (path.substr(path.length - 1, 1) == '/') {\n            names.splice(names.length - 1, 1);\n          }\n\n          return names;\n        }\n\n        function queryKey(uri, query) {\n          var data = {};\n          query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {\n            if ($1) {\n              data[$1] = $2;\n            }\n          });\n          return data;\n        }\n        /***/\n\n      },\n\n      /***/\n      \"./node_modules/process/browser.js\":\n      /*!*****************************************!*\\\n        !*** ./node_modules/process/browser.js ***!\n        \\*****************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesProcessBrowserJs(module, exports) {\n        // shim for using process in browser\n        var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n        // don't break things.  But we need to wrap it in a try catch in case it is\n        // wrapped in strict mode code which doesn't define any globals.  It's inside a\n        // function because try/catches deoptimize in certain engines.\n\n        var cachedSetTimeout;\n        var cachedClearTimeout;\n\n        function defaultSetTimout() {\n          throw new Error('setTimeout has not been defined');\n        }\n\n        function defaultClearTimeout() {\n          throw new Error('clearTimeout has not been defined');\n        }\n\n        (function () {\n          try {\n            if (typeof setTimeout === 'function') {\n              cachedSetTimeout = setTimeout;\n            } else {\n              cachedSetTimeout = defaultSetTimout;\n            }\n          } catch (e) {\n            cachedSetTimeout = defaultSetTimout;\n          }\n\n          try {\n            if (typeof clearTimeout === 'function') {\n              cachedClearTimeout = clearTimeout;\n            } else {\n              cachedClearTimeout = defaultClearTimeout;\n            }\n          } catch (e) {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        })();\n\n        function runTimeout(fun) {\n          if (cachedSetTimeout === setTimeout) {\n            //normal enviroments in sane situations\n            return setTimeout(fun, 0);\n          } // if setTimeout wasn't available but was latter defined\n\n\n          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n            cachedSetTimeout = setTimeout;\n            return setTimeout(fun, 0);\n          }\n\n          try {\n            // when when somebody has screwed with setTimeout but no I.E. maddness\n            return cachedSetTimeout(fun, 0);\n          } catch (e) {\n            try {\n              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n              return cachedSetTimeout.call(null, fun, 0);\n            } catch (e) {\n              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n              return cachedSetTimeout.call(this, fun, 0);\n            }\n          }\n        }\n\n        function runClearTimeout(marker) {\n          if (cachedClearTimeout === clearTimeout) {\n            //normal enviroments in sane situations\n            return clearTimeout(marker);\n          } // if clearTimeout wasn't available but was latter defined\n\n\n          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n            cachedClearTimeout = clearTimeout;\n            return clearTimeout(marker);\n          }\n\n          try {\n            // when when somebody has screwed with setTimeout but no I.E. maddness\n            return cachedClearTimeout(marker);\n          } catch (e) {\n            try {\n              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n              return cachedClearTimeout.call(null, marker);\n            } catch (e) {\n              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n              // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n              return cachedClearTimeout.call(this, marker);\n            }\n          }\n        }\n\n        var queue = [];\n        var draining = false;\n        var currentQueue;\n        var queueIndex = -1;\n\n        function cleanUpNextTick() {\n          if (!draining || !currentQueue) {\n            return;\n          }\n\n          draining = false;\n\n          if (currentQueue.length) {\n            queue = currentQueue.concat(queue);\n          } else {\n            queueIndex = -1;\n          }\n\n          if (queue.length) {\n            drainQueue();\n          }\n        }\n\n        function drainQueue() {\n          if (draining) {\n            return;\n          }\n\n          var timeout = runTimeout(cleanUpNextTick);\n          draining = true;\n          var len = queue.length;\n\n          while (len) {\n            currentQueue = queue;\n            queue = [];\n\n            while (++queueIndex < len) {\n              if (currentQueue) {\n                currentQueue[queueIndex].run();\n              }\n            }\n\n            queueIndex = -1;\n            len = queue.length;\n          }\n\n          currentQueue = null;\n          draining = false;\n          runClearTimeout(timeout);\n        }\n\n        process.nextTick = function (fun) {\n          var args = new Array(arguments.length - 1);\n\n          if (arguments.length > 1) {\n            for (var i = 1; i < arguments.length; i++) {\n              args[i - 1] = arguments[i];\n            }\n          }\n\n          queue.push(new Item(fun, args));\n\n          if (queue.length === 1 && !draining) {\n            runTimeout(drainQueue);\n          }\n        }; // v8 likes predictible objects\n\n\n        function Item(fun, array) {\n          this.fun = fun;\n          this.array = array;\n        }\n\n        Item.prototype.run = function () {\n          this.fun.apply(null, this.array);\n        };\n\n        process.title = 'browser';\n        process.browser = true;\n        process.env = {};\n        process.argv = [];\n        process.version = ''; // empty string to avoid regexp issues\n\n        process.versions = {};\n\n        function noop() {}\n\n        process.on = noop;\n        process.addListener = noop;\n        process.once = noop;\n        process.off = noop;\n        process.removeListener = noop;\n        process.removeAllListeners = noop;\n        process.emit = noop;\n        process.prependListener = noop;\n        process.prependOnceListener = noop;\n\n        process.listeners = function (name) {\n          return [];\n        };\n\n        process.binding = function (name) {\n          throw new Error('process.binding is not supported');\n        };\n\n        process.cwd = function () {\n          return '/';\n        };\n\n        process.chdir = function (dir) {\n          throw new Error('process.chdir is not supported');\n        };\n\n        process.umask = function () {\n          return 0;\n        };\n        /***/\n\n      },\n\n      /***/\n      \"./node_modules/socket.io-parser/dist/binary.js\":\n      /*!******************************************************!*\\\n        !*** ./node_modules/socket.io-parser/dist/binary.js ***!\n        \\******************************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesSocketIoParserDistBinaryJs(module, exports, __webpack_require__) {\n        \"use strict\";\n\n        function _typeof(obj) {\n          \"@babel/helpers - typeof\";\n\n          if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n              return typeof obj;\n            };\n          } else {\n            _typeof = function _typeof(obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n          }\n\n          return _typeof(obj);\n        }\n\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.reconstructPacket = exports.deconstructPacket = void 0;\n\n        var is_binary_1 = __webpack_require__(\n        /*! ./is-binary */\n        \"./node_modules/socket.io-parser/dist/is-binary.js\");\n        /**\n         * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.\n         *\n         * @param {Object} packet - socket.io event packet\n         * @return {Object} with deconstructed packet and list of buffers\n         * @public\n         */\n\n\n        function deconstructPacket(packet) {\n          var buffers = [];\n          var packetData = packet.data;\n          var pack = packet;\n          pack.data = _deconstructPacket(packetData, buffers);\n          pack.attachments = buffers.length; // number of binary 'attachments'\n\n          return {\n            packet: pack,\n            buffers: buffers\n          };\n        }\n\n        exports.deconstructPacket = deconstructPacket;\n\n        function _deconstructPacket(data, buffers) {\n          if (!data) return data;\n\n          if (is_binary_1.isBinary(data)) {\n            var placeholder = {\n              _placeholder: true,\n              num: buffers.length\n            };\n            buffers.push(data);\n            return placeholder;\n          } else if (Array.isArray(data)) {\n            var newData = new Array(data.length);\n\n            for (var i = 0; i < data.length; i++) {\n              newData[i] = _deconstructPacket(data[i], buffers);\n            }\n\n            return newData;\n          } else if (_typeof(data) === \"object\" && !(data instanceof Date)) {\n            var _newData = {};\n\n            for (var key in data) {\n              if (data.hasOwnProperty(key)) {\n                _newData[key] = _deconstructPacket(data[key], buffers);\n              }\n            }\n\n            return _newData;\n          }\n\n          return data;\n        }\n        /**\n         * Reconstructs a binary packet from its placeholder packet and buffers\n         *\n         * @param {Object} packet - event packet with placeholders\n         * @param {Array} buffers - binary buffers to put in placeholder positions\n         * @return {Object} reconstructed packet\n         * @public\n         */\n\n\n        function reconstructPacket(packet, buffers) {\n          packet.data = _reconstructPacket(packet.data, buffers);\n          packet.attachments = undefined; // no longer useful\n\n          return packet;\n        }\n\n        exports.reconstructPacket = reconstructPacket;\n\n        function _reconstructPacket(data, buffers) {\n          if (!data) return data;\n\n          if (data && data._placeholder) {\n            return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n          } else if (Array.isArray(data)) {\n            for (var i = 0; i < data.length; i++) {\n              data[i] = _reconstructPacket(data[i], buffers);\n            }\n          } else if (_typeof(data) === \"object\") {\n            for (var key in data) {\n              if (data.hasOwnProperty(key)) {\n                data[key] = _reconstructPacket(data[key], buffers);\n              }\n            }\n          }\n\n          return data;\n        }\n        /***/\n\n      },\n\n      /***/\n      \"./node_modules/socket.io-parser/dist/index.js\":\n      /*!*****************************************************!*\\\n        !*** ./node_modules/socket.io-parser/dist/index.js ***!\n        \\*****************************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesSocketIoParserDistIndexJs(module, exports, __webpack_require__) {\n        \"use strict\";\n\n        function _typeof(obj) {\n          \"@babel/helpers - typeof\";\n\n          if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n              return typeof obj;\n            };\n          } else {\n            _typeof = function _typeof(obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n          }\n\n          return _typeof(obj);\n        }\n\n        function _get(target, property, receiver) {\n          if (typeof Reflect !== \"undefined\" && Reflect.get) {\n            _get = Reflect.get;\n          } else {\n            _get = function _get(target, property, receiver) {\n              var base = _superPropBase(target, property);\n\n              if (!base) return;\n              var desc = Object.getOwnPropertyDescriptor(base, property);\n\n              if (desc.get) {\n                return desc.get.call(receiver);\n              }\n\n              return desc.value;\n            };\n          }\n\n          return _get(target, property, receiver || target);\n        }\n\n        function _superPropBase(object, property) {\n          while (!Object.prototype.hasOwnProperty.call(object, property)) {\n            object = _getPrototypeOf(object);\n            if (object === null) break;\n          }\n\n          return object;\n        }\n\n        function _inherits(subClass, superClass) {\n          if (typeof superClass !== \"function\" && superClass !== null) {\n            throw new TypeError(\"Super expression must either be null or a function\");\n          }\n\n          subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n              value: subClass,\n              writable: true,\n              configurable: true\n            }\n          });\n          if (superClass) _setPrototypeOf(subClass, superClass);\n        }\n\n        function _setPrototypeOf(o, p) {\n          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n            o.__proto__ = p;\n            return o;\n          };\n\n          return _setPrototypeOf(o, p);\n        }\n\n        function _createSuper(Derived) {\n          var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n          return function _createSuperInternal() {\n            var Super = _getPrototypeOf(Derived),\n                result;\n\n            if (hasNativeReflectConstruct) {\n              var NewTarget = _getPrototypeOf(this).constructor;\n\n              result = Reflect.construct(Super, arguments, NewTarget);\n            } else {\n              result = Super.apply(this, arguments);\n            }\n\n            return _possibleConstructorReturn(this, result);\n          };\n        }\n\n        function _possibleConstructorReturn(self, call) {\n          if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n            return call;\n          }\n\n          return _assertThisInitialized(self);\n        }\n\n        function _assertThisInitialized(self) {\n          if (self === void 0) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          }\n\n          return self;\n        }\n\n        function _isNativeReflectConstruct() {\n          if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n          if (Reflect.construct.sham) return false;\n          if (typeof Proxy === \"function\") return true;\n\n          try {\n            Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n            return true;\n          } catch (e) {\n            return false;\n          }\n        }\n\n        function _getPrototypeOf(o) {\n          _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n            return o.__proto__ || Object.getPrototypeOf(o);\n          };\n          return _getPrototypeOf(o);\n        }\n\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        function _defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        function _createClass(Constructor, protoProps, staticProps) {\n          if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) _defineProperties(Constructor, staticProps);\n          return Constructor;\n        }\n\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;\n\n        var Emitter = __webpack_require__(\n        /*! component-emitter */\n        \"./node_modules/component-emitter/index.js\");\n\n        var binary_1 = __webpack_require__(\n        /*! ./binary */\n        \"./node_modules/socket.io-parser/dist/binary.js\");\n\n        var is_binary_1 = __webpack_require__(\n        /*! ./is-binary */\n        \"./node_modules/socket.io-parser/dist/is-binary.js\");\n\n        var debug = __webpack_require__(\n        /*! debug */\n        \"./node_modules/debug/src/browser.js\")(\"socket.io-parser\");\n        /**\n         * Protocol version.\n         *\n         * @public\n         */\n\n\n        exports.protocol = 5;\n        var PacketType;\n\n        (function (PacketType) {\n          PacketType[PacketType[\"CONNECT\"] = 0] = \"CONNECT\";\n          PacketType[PacketType[\"DISCONNECT\"] = 1] = \"DISCONNECT\";\n          PacketType[PacketType[\"EVENT\"] = 2] = \"EVENT\";\n          PacketType[PacketType[\"ACK\"] = 3] = \"ACK\";\n          PacketType[PacketType[\"CONNECT_ERROR\"] = 4] = \"CONNECT_ERROR\";\n          PacketType[PacketType[\"BINARY_EVENT\"] = 5] = \"BINARY_EVENT\";\n          PacketType[PacketType[\"BINARY_ACK\"] = 6] = \"BINARY_ACK\";\n        })(PacketType = exports.PacketType || (exports.PacketType = {}));\n        /**\n         * A socket.io Encoder instance\n         */\n\n\n        var Encoder = /*#__PURE__*/function () {\n          function Encoder() {\n            _classCallCheck(this, Encoder);\n          }\n\n          _createClass(Encoder, [{\n            key: \"encode\",\n\n            /**\n             * Encode a packet as a single string if non-binary, or as a\n             * buffer sequence, depending on packet type.\n             *\n             * @param {Object} obj - packet object\n             */\n            value: function encode(obj) {\n              debug(\"encoding packet %j\", obj);\n\n              if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {\n                if (is_binary_1.hasBinary(obj)) {\n                  obj.type = obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK;\n                  return this.encodeAsBinary(obj);\n                }\n              }\n\n              return [this.encodeAsString(obj)];\n            }\n            /**\n             * Encode packet as string.\n             */\n\n          }, {\n            key: \"encodeAsString\",\n            value: function encodeAsString(obj) {\n              // first is type\n              var str = \"\" + obj.type; // attachments if we have them\n\n              if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {\n                str += obj.attachments + \"-\";\n              } // if we have a namespace other than `/`\n              // we append it followed by a comma `,`\n\n\n              if (obj.nsp && \"/\" !== obj.nsp) {\n                str += obj.nsp + \",\";\n              } // immediately followed by the id\n\n\n              if (null != obj.id) {\n                str += obj.id;\n              } // json data\n\n\n              if (null != obj.data) {\n                str += JSON.stringify(obj.data);\n              }\n\n              debug(\"encoded %j as %s\", obj, str);\n              return str;\n            }\n            /**\n             * Encode packet as 'buffer sequence' by removing blobs, and\n             * deconstructing packet into object with placeholders and\n             * a list of buffers.\n             */\n\n          }, {\n            key: \"encodeAsBinary\",\n            value: function encodeAsBinary(obj) {\n              var deconstruction = binary_1.deconstructPacket(obj);\n              var pack = this.encodeAsString(deconstruction.packet);\n              var buffers = deconstruction.buffers;\n              buffers.unshift(pack); // add packet info to beginning of data list\n\n              return buffers; // write all the buffers\n            }\n          }]);\n\n          return Encoder;\n        }();\n\n        exports.Encoder = Encoder;\n        /**\n         * A socket.io Decoder instance\n         *\n         * @return {Object} decoder\n         */\n\n        var Decoder = /*#__PURE__*/function (_Emitter) {\n          _inherits(Decoder, _Emitter);\n\n          var _super = _createSuper(Decoder);\n\n          function Decoder() {\n            _classCallCheck(this, Decoder);\n\n            return _super.call(this);\n          }\n          /**\n           * Decodes an encoded packet string into packet JSON.\n           *\n           * @param {String} obj - encoded packet\n           */\n\n\n          _createClass(Decoder, [{\n            key: \"add\",\n            value: function add(obj) {\n              var packet;\n\n              if (typeof obj === \"string\") {\n                packet = this.decodeString(obj);\n\n                if (packet.type === PacketType.BINARY_EVENT || packet.type === PacketType.BINARY_ACK) {\n                  // binary packet's json\n                  this.reconstructor = new BinaryReconstructor(packet); // no attachments, labeled binary but no binary data to follow\n\n                  if (packet.attachments === 0) {\n                    _get(_getPrototypeOf(Decoder.prototype), \"emit\", this).call(this, \"decoded\", packet);\n                  }\n                } else {\n                  // non-binary full packet\n                  _get(_getPrototypeOf(Decoder.prototype), \"emit\", this).call(this, \"decoded\", packet);\n                }\n              } else if (is_binary_1.isBinary(obj) || obj.base64) {\n                // raw binary data\n                if (!this.reconstructor) {\n                  throw new Error(\"got binary data when not reconstructing a packet\");\n                } else {\n                  packet = this.reconstructor.takeBinaryData(obj);\n\n                  if (packet) {\n                    // received final buffer\n                    this.reconstructor = null;\n\n                    _get(_getPrototypeOf(Decoder.prototype), \"emit\", this).call(this, \"decoded\", packet);\n                  }\n                }\n              } else {\n                throw new Error(\"Unknown type: \" + obj);\n              }\n            }\n            /**\n             * Decode a packet String (JSON data)\n             *\n             * @param {String} str\n             * @return {Object} packet\n             */\n\n          }, {\n            key: \"decodeString\",\n            value: function decodeString(str) {\n              var i = 0; // look up type\n\n              var p = {\n                type: Number(str.charAt(0))\n              };\n\n              if (PacketType[p.type] === undefined) {\n                throw new Error(\"unknown packet type \" + p.type);\n              } // look up attachments if type binary\n\n\n              if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {\n                var start = i + 1;\n\n                while (str.charAt(++i) !== \"-\" && i != str.length) {}\n\n                var buf = str.substring(start, i);\n\n                if (buf != Number(buf) || str.charAt(i) !== \"-\") {\n                  throw new Error(\"Illegal attachments\");\n                }\n\n                p.attachments = Number(buf);\n              } // look up namespace (if any)\n\n\n              if (\"/\" === str.charAt(i + 1)) {\n                var _start = i + 1;\n\n                while (++i) {\n                  var c = str.charAt(i);\n                  if (\",\" === c) break;\n                  if (i === str.length) break;\n                }\n\n                p.nsp = str.substring(_start, i);\n              } else {\n                p.nsp = \"/\";\n              } // look up id\n\n\n              var next = str.charAt(i + 1);\n\n              if (\"\" !== next && Number(next) == next) {\n                var _start2 = i + 1;\n\n                while (++i) {\n                  var _c = str.charAt(i);\n\n                  if (null == _c || Number(_c) != _c) {\n                    --i;\n                    break;\n                  }\n\n                  if (i === str.length) break;\n                }\n\n                p.id = Number(str.substring(_start2, i + 1));\n              } // look up json data\n\n\n              if (str.charAt(++i)) {\n                var payload = tryParse(str.substr(i));\n\n                if (Decoder.isPayloadValid(p.type, payload)) {\n                  p.data = payload;\n                } else {\n                  throw new Error(\"invalid payload\");\n                }\n              }\n\n              debug(\"decoded %s as %j\", str, p);\n              return p;\n            }\n          }, {\n            key: \"destroy\",\n\n            /**\n             * Deallocates a parser's resources\n             */\n            value: function destroy() {\n              if (this.reconstructor) {\n                this.reconstructor.finishedReconstruction();\n              }\n            }\n          }], [{\n            key: \"isPayloadValid\",\n            value: function isPayloadValid(type, payload) {\n              switch (type) {\n                case PacketType.CONNECT:\n                  return _typeof(payload) === \"object\";\n\n                case PacketType.DISCONNECT:\n                  return payload === undefined;\n\n                case PacketType.CONNECT_ERROR:\n                  return typeof payload === \"string\" || _typeof(payload) === \"object\";\n\n                case PacketType.EVENT:\n                case PacketType.BINARY_EVENT:\n                  return Array.isArray(payload) && typeof payload[0] === \"string\";\n\n                case PacketType.ACK:\n                case PacketType.BINARY_ACK:\n                  return Array.isArray(payload);\n              }\n            }\n          }]);\n\n          return Decoder;\n        }(Emitter);\n\n        exports.Decoder = Decoder;\n\n        function tryParse(str) {\n          try {\n            return JSON.parse(str);\n          } catch (e) {\n            return false;\n          }\n        }\n        /**\n         * A manager of a binary event's 'buffer sequence'. Should\n         * be constructed whenever a packet of type BINARY_EVENT is\n         * decoded.\n         *\n         * @param {Object} packet\n         * @return {BinaryReconstructor} initialized reconstructor\n         */\n\n\n        var BinaryReconstructor = /*#__PURE__*/function () {\n          function BinaryReconstructor(packet) {\n            _classCallCheck(this, BinaryReconstructor);\n\n            this.packet = packet;\n            this.buffers = [];\n            this.reconPack = packet;\n          }\n          /**\n           * Method to be called when binary data received from connection\n           * after a BINARY_EVENT packet.\n           *\n           * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n           * @return {null | Object} returns null if more binary data is expected or\n           *   a reconstructed packet object if all buffers have been received.\n           */\n\n\n          _createClass(BinaryReconstructor, [{\n            key: \"takeBinaryData\",\n            value: function takeBinaryData(binData) {\n              this.buffers.push(binData);\n\n              if (this.buffers.length === this.reconPack.attachments) {\n                // done with buffer list\n                var packet = binary_1.reconstructPacket(this.reconPack, this.buffers);\n                this.finishedReconstruction();\n                return packet;\n              }\n\n              return null;\n            }\n            /**\n             * Cleans up binary packet reconstruction variables.\n             */\n\n          }, {\n            key: \"finishedReconstruction\",\n            value: function finishedReconstruction() {\n              this.reconPack = null;\n              this.buffers = [];\n            }\n          }]);\n\n          return BinaryReconstructor;\n        }();\n        /***/\n\n      },\n\n      /***/\n      \"./node_modules/socket.io-parser/dist/is-binary.js\":\n      /*!*********************************************************!*\\\n        !*** ./node_modules/socket.io-parser/dist/is-binary.js ***!\n        \\*********************************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesSocketIoParserDistIsBinaryJs(module, exports, __webpack_require__) {\n        \"use strict\";\n\n        function _typeof(obj) {\n          \"@babel/helpers - typeof\";\n\n          if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n              return typeof obj;\n            };\n          } else {\n            _typeof = function _typeof(obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n          }\n\n          return _typeof(obj);\n        }\n\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.hasBinary = exports.isBinary = void 0;\n        var withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n\n        var isView = function isView(obj) {\n          return typeof ArrayBuffer.isView === \"function\" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;\n        };\n\n        var toString = Object.prototype.toString;\n        var withNativeBlob = typeof Blob === \"function\" || typeof Blob !== \"undefined\" && toString.call(Blob) === \"[object BlobConstructor]\";\n        var withNativeFile = typeof File === \"function\" || typeof File !== \"undefined\" && toString.call(File) === \"[object FileConstructor]\";\n        /**\n         * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.\n         *\n         * @private\n         */\n\n        function isBinary(obj) {\n          return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;\n        }\n\n        exports.isBinary = isBinary;\n\n        function hasBinary(obj, toJSON) {\n          if (!obj || _typeof(obj) !== \"object\") {\n            return false;\n          }\n\n          if (Array.isArray(obj)) {\n            for (var i = 0, l = obj.length; i < l; i++) {\n              if (hasBinary(obj[i])) {\n                return true;\n              }\n            }\n\n            return false;\n          }\n\n          if (isBinary(obj)) {\n            return true;\n          }\n\n          if (obj.toJSON && typeof obj.toJSON === \"function\" && arguments.length === 1) {\n            return hasBinary(obj.toJSON(), true);\n          }\n\n          for (var key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\n              return true;\n            }\n          }\n\n          return false;\n        }\n\n        exports.hasBinary = hasBinary;\n        /***/\n      },\n\n      /***/\n      \"./node_modules/yeast/index.js\":\n      /*!*************************************!*\\\n        !*** ./node_modules/yeast/index.js ***!\n        \\*************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesYeastIndexJs(module, exports, __webpack_require__) {\n        \"use strict\";\n\n        var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),\n            length = 64,\n            map = {},\n            seed = 0,\n            i = 0,\n            prev;\n        /**\n         * Return a string representing the specified number.\n         *\n         * @param {Number} num The number to convert.\n         * @returns {String} The string representation of the number.\n         * @api public\n         */\n\n        function encode(num) {\n          var encoded = '';\n\n          do {\n            encoded = alphabet[num % length] + encoded;\n            num = Math.floor(num / length);\n          } while (num > 0);\n\n          return encoded;\n        }\n        /**\n         * Return the integer value specified by the given string.\n         *\n         * @param {String} str The string to convert.\n         * @returns {Number} The integer value represented by the string.\n         * @api public\n         */\n\n\n        function decode(str) {\n          var decoded = 0;\n\n          for (i = 0; i < str.length; i++) {\n            decoded = decoded * length + map[str.charAt(i)];\n          }\n\n          return decoded;\n        }\n        /**\n         * Yeast: A tiny growing id generator.\n         *\n         * @returns {String} A unique id.\n         * @api public\n         */\n\n\n        function yeast() {\n          var now = encode(+new Date());\n          if (now !== prev) return seed = 0, prev = now;\n          return now + '.' + encode(seed++);\n        } //\n        // Map each character to its index.\n        //\n\n\n        for (; i < length; i++) {\n          map[alphabet[i]] = i;\n        } //\n        // Expose the `yeast`, `encode` and `decode` functions.\n        //\n\n\n        yeast.encode = encode;\n        yeast.decode = decode;\n        module.exports = yeast;\n        /***/\n      }\n      /******/\n\n    })\n  );\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../node_modules/buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer, __webpack_require__(/*! ./../../node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvc29ja2V0LmlvLWNsaWVudC5qcz82ZWUzIl0sIm5hbWVzIjpbIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwic2VsZiIsIndpbmRvdyIsImdsb2JhbCIsIkZ1bmN0aW9uIiwibW9kdWxlcyIsImluc3RhbGxlZE1vZHVsZXMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJpIiwibCIsImNhbGwiLCJtIiwiYyIsImQiLCJuYW1lIiwiZ2V0dGVyIiwibyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsInIiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInZhbHVlIiwidCIsIm1vZGUiLCJfX2VzTW9kdWxlIiwibnMiLCJjcmVhdGUiLCJrZXkiLCJiaW5kIiwibiIsImdldERlZmF1bHQiLCJnZXRNb2R1bGVFeHBvcnRzIiwib2JqZWN0IiwicHJvcGVydHkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInAiLCJzIiwiX3R5cGVvZiIsIm9iaiIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJTb2NrZXQiLCJpbyIsIk1hbmFnZXIiLCJwcm90b2NvbCIsInVybF8xIiwibWFuYWdlcl8xIiwic29ja2V0XzEiLCJkZWJ1ZyIsImxvb2t1cCIsImNhY2hlIiwibWFuYWdlcnMiLCJ1cmkiLCJvcHRzIiwidW5kZWZpbmVkIiwicGFyc2VkIiwidXJsIiwic291cmNlIiwiaWQiLCJwYXRoIiwic2FtZU5hbWVzcGFjZSIsIm5zcHMiLCJuZXdDb25uZWN0aW9uIiwiZm9yY2VOZXciLCJtdWx0aXBsZXgiLCJxdWVyeSIsInNvY2tldCIsInNvY2tldF9pb19wYXJzZXJfMSIsImNvbm5lY3QiLCJtYW5hZ2VyXzIiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImxlbmd0aCIsImRlc2NyaXB0b3IiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9nZXQiLCJyZWNlaXZlciIsIlJlZmxlY3QiLCJiYXNlIiwiX3N1cGVyUHJvcEJhc2UiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX2dldFByb3RvdHlwZU9mIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiX3NldFByb3RvdHlwZU9mIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJfY3JlYXRlU3VwZXIiLCJEZXJpdmVkIiwiaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfY3JlYXRlU3VwZXJJbnRlcm5hbCIsIlN1cGVyIiwicmVzdWx0IiwiTmV3VGFyZ2V0IiwiY29uc3RydWN0IiwiYXJndW1lbnRzIiwiYXBwbHkiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsInNoYW0iLCJQcm94eSIsIkRhdGUiLCJ0b1N0cmluZyIsImUiLCJnZXRQcm90b3R5cGVPZiIsImVpbyIsIkVtaXR0ZXIiLCJwYXJzZXIiLCJvbl8xIiwiQmFja29mZiIsIl9FbWl0dGVyIiwiX3N1cGVyIiwiX3RoaXMiLCJzdWJzIiwiY29ubmVjdGluZyIsInJlY29ubmVjdGlvbiIsInJlY29ubmVjdGlvbkF0dGVtcHRzIiwiSW5maW5pdHkiLCJyZWNvbm5lY3Rpb25EZWxheSIsInJlY29ubmVjdGlvbkRlbGF5TWF4IiwicmFuZG9taXphdGlvbkZhY3RvciIsImJhY2tvZmYiLCJtaW4iLCJtYXgiLCJqaXR0ZXIiLCJ0aW1lb3V0IiwiX3JlYWR5U3RhdGUiLCJfcGFyc2VyIiwiZW5jb2RlciIsIkVuY29kZXIiLCJkZWNvZGVyIiwiRGVjb2RlciIsIl9hdXRvQ29ubmVjdCIsImF1dG9Db25uZWN0Iiwib3BlbiIsInYiLCJfcmVjb25uZWN0aW9uIiwiX3JlY29ubmVjdGlvbkF0dGVtcHRzIiwiX3JlY29ubmVjdGlvbkRlbGF5Iiwic2V0TWluIiwiX3JhbmRvbWl6YXRpb25GYWN0b3IiLCJzZXRKaXR0ZXIiLCJfcmVjb25uZWN0aW9uRGVsYXlNYXgiLCJzZXRNYXgiLCJfdGltZW91dCIsIm1heWJlUmVjb25uZWN0T25PcGVuIiwiX3JlY29ubmVjdGluZyIsImF0dGVtcHRzIiwicmVjb25uZWN0IiwiZm4iLCJfdGhpczIiLCJpbmRleE9mIiwiZW5naW5lIiwic2tpcFJlY29ubmVjdCIsIm9wZW5TdWIiLCJvbiIsIm9ub3BlbiIsImVycm9yU3ViIiwiZXJyIiwiY2xlYW51cCIsImRlc3Ryb3kiLCJ0aW1lciIsInNldFRpbWVvdXQiLCJjbG9zZSIsImVtaXQiLCJFcnJvciIsInB1c2giLCJjbGVhclRpbWVvdXQiLCJvbnBpbmciLCJvbmRhdGEiLCJkYXRhIiwiYWRkIiwib25kZWNvZGVkIiwicGFja2V0Iiwib25lcnJvciIsIm5zcCIsIm9uQ29ubmVjdGluZyIsIl9kZXN0cm95IiwiaW5kZXgiLCJzcGxpY2UiLCJfY2xvc2UiLCJfcGFja2V0IiwidHlwZSIsImVuY29kZWRQYWNrZXRzIiwiZW5jb2RlIiwid3JpdGUiLCJvcHRpb25zIiwic3Vic0xlbmd0aCIsInN1YiIsInNoaWZ0IiwicmVzZXQiLCJkaXNjb25uZWN0Iiwib25jbG9zZSIsInJlYXNvbiIsIl90aGlzMyIsImRlbGF5IiwiZHVyYXRpb24iLCJvbnJlY29ubmVjdCIsImF0dGVtcHQiLCJldiIsInJlbW92ZUxpc3RlbmVyIiwiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIiLCJhbGxvd0FycmF5TGlrZSIsIml0IiwiQXJyYXkiLCJpc0FycmF5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiRiIsImRvbmUiLCJfZSIsImYiLCJub3JtYWxDb21wbGV0aW9uIiwiZGlkRXJyIiwic3RlcCIsIm5leHQiLCJfZTIiLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsInNsaWNlIiwiZnJvbSIsInRlc3QiLCJhcnIiLCJsZW4iLCJhcnIyIiwiUkVTRVJWRURfRVZFTlRTIiwiY29ubmVjdF9lcnJvciIsImRpc2Nvbm5lY3RpbmciLCJuZXdMaXN0ZW5lciIsImlkcyIsImFja3MiLCJyZWNlaXZlQnVmZmVyIiwic2VuZEJ1ZmZlciIsImZsYWdzIiwiY29ubmVjdGVkIiwiZGlzY29ubmVjdGVkIiwiYXV0aCIsInN1YkV2ZW50cyIsInNlbmQiLCJfbGVuIiwiYXJncyIsIl9rZXkiLCJ1bnNoaWZ0IiwiX2xlbjIiLCJfa2V5MiIsIlBhY2tldFR5cGUiLCJFVkVOVCIsImNvbXByZXNzIiwicG9wIiwiaXNUcmFuc3BvcnRXcml0YWJsZSIsInRyYW5zcG9ydCIsImRpc2NhcmRQYWNrZXQiLCJDT05ORUNUIiwib25wYWNrZXQiLCJzaWQiLCJvbmNvbm5lY3QiLCJvbmV2ZW50IiwiQklOQVJZX0VWRU5UIiwiQUNLIiwib25hY2siLCJCSU5BUllfQUNLIiwiRElTQ09OTkVDVCIsIm9uZGlzY29ubmVjdCIsIkNPTk5FQ1RfRVJST1IiLCJtZXNzYWdlIiwiYWNrIiwiZW1pdEV2ZW50IiwiX2FueUxpc3RlbmVycyIsImxpc3RlbmVycyIsIl9pdGVyYXRvciIsIl9zdGVwIiwibGlzdGVuZXIiLCJzZW50IiwiX2xlbjMiLCJfa2V5MyIsImVtaXRCdWZmZXJlZCIsIl9pIiwiX2NvbXByZXNzIiwib25BbnkiLCJwcmVwZW5kQW55Iiwib2ZmQW55IiwibGlzdGVuZXJzQW55IiwicGFyc2V1cmkiLCJsb2MiLCJsb2NhdGlvbiIsImhvc3QiLCJjaGFyQXQiLCJwb3J0IiwiaXB2NiIsImhyZWYiLCJtcyIsImZhY3RvciIsIk1hdGgiLCJwb3ciLCJyYW5kIiwicmFuZG9tIiwiZGV2aWF0aW9uIiwiZmxvb3IiLCJjaGFycyIsIlVpbnQ4QXJyYXkiLCJjaGFyQ29kZUF0IiwiYXJyYXlidWZmZXIiLCJieXRlcyIsImJhc2U2NCIsInN1YnN0cmluZyIsImRlY29kZSIsImJ1ZmZlckxlbmd0aCIsImVuY29kZWQxIiwiZW5jb2RlZDIiLCJlbmNvZGVkMyIsImVuY29kZWQ0IiwiQXJyYXlCdWZmZXIiLCJjb25jYXQiLCJtaXhpbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsIl9jYWxsYmFja3MiLCJvbmNlIiwib2ZmIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbGxiYWNrcyIsImNiIiwiaGFzTGlzdGVuZXJzIiwicHJvY2VzcyIsImxvZyIsImZvcm1hdEFyZ3MiLCJzYXZlIiwibG9hZCIsInVzZUNvbG9ycyIsInN0b3JhZ2UiLCJsb2NhbHN0b3JhZ2UiLCJjb2xvcnMiLCJfX253anMiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ0b0xvd2VyQ2FzZSIsIm1hdGNoIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJzdHlsZSIsIldlYmtpdEFwcGVhcmFuY2UiLCJjb25zb2xlIiwiZmlyZWJ1ZyIsImV4Y2VwdGlvbiIsInRhYmxlIiwicGFyc2VJbnQiLCJSZWdFeHAiLCIkMSIsIm5hbWVzcGFjZSIsImh1bWFuaXplIiwiZGlmZiIsImNvbG9yIiwibGFzdEMiLCJyZXBsYWNlIiwiX2NvbnNvbGUiLCJuYW1lc3BhY2VzIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJlcnJvciIsImdldEl0ZW0iLCJlbnYiLCJERUJVRyIsImxvY2FsU3RvcmFnZSIsImZvcm1hdHRlcnMiLCJqIiwiSlNPTiIsInN0cmluZ2lmeSIsIl90b0NvbnN1bWFibGVBcnJheSIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJpdGVyIiwic2V0dXAiLCJjcmVhdGVEZWJ1ZyIsImNvZXJjZSIsImRpc2FibGUiLCJlbmFibGUiLCJlbmFibGVkIiwia2V5cyIsImZvckVhY2giLCJpbnN0YW5jZXMiLCJuYW1lcyIsInNraXBzIiwic2VsZWN0Q29sb3IiLCJoYXNoIiwiYWJzIiwicHJldlRpbWUiLCJjdXJyIiwiTnVtYmVyIiwicHJldiIsImZvcm1hdCIsImZvcm1hdHRlciIsInZhbCIsImxvZ0ZuIiwiZXh0ZW5kIiwiaW5pdCIsImRlbGltaXRlciIsIm5ld0RlYnVnIiwic3BsaXQiLCJzdWJzdHIiLCJtYXAiLCJ0b05hbWVzcGFjZSIsImpvaW4iLCJyZWdleHAiLCJzdGFjayIsIlRyYW5zcG9ydCIsInRyYW5zcG9ydHMiLCJfZXh0ZW5kcyIsImFzc2lnbiIsInBhcnNlcXMiLCJob3N0bmFtZSIsInNlY3VyZSIsInJlYWR5U3RhdGUiLCJ3cml0ZUJ1ZmZlciIsInByZXZCdWZmZXJMZW4iLCJhZ2VudCIsIndpdGhDcmVkZW50aWFscyIsInVwZ3JhZGUiLCJqc29ucCIsInRpbWVzdGFtcFBhcmFtIiwicG9saWN5UG9ydCIsInJlbWVtYmVyVXBncmFkZSIsInJlamVjdFVuYXV0aG9yaXplZCIsInBlck1lc3NhZ2VEZWZsYXRlIiwidGhyZXNob2xkIiwidHJhbnNwb3J0T3B0aW9ucyIsInVwZ3JhZGVzIiwicGluZ0ludGVydmFsIiwicGluZ1RpbWVvdXQiLCJwaW5nVGltZW91dFRpbWVyIiwiY3JlYXRlVHJhbnNwb3J0IiwiY2xvbmUiLCJFSU8iLCJwcmlvcldlYnNvY2tldFN1Y2Nlc3MiLCJzZXRUcmFuc3BvcnQiLCJvbkRyYWluIiwib25QYWNrZXQiLCJvbkVycm9yIiwib25DbG9zZSIsInByb2JlIiwiZmFpbGVkIiwib25UcmFuc3BvcnRPcGVuIiwib25seUJpbmFyeVVwZ3JhZGVzIiwidXBncmFkZUxvc2VzQmluYXJ5Iiwic3VwcG9ydHNCaW5hcnkiLCJtc2ciLCJ1cGdyYWRpbmciLCJwYXVzZSIsImZsdXNoIiwiZnJlZXplVHJhbnNwb3J0Iiwib25UcmFuc3BvcnRDbG9zZSIsIm9udXBncmFkZSIsInRvIiwib25PcGVuIiwib25IYW5kc2hha2UiLCJwYXJzZSIsInJlc2V0UGluZ1RpbWVvdXQiLCJzZW5kUGFja2V0IiwiY29kZSIsImZpbHRlclVwZ3JhZGVzIiwid2FpdEZvclVwZ3JhZGUiLCJjbGVhbnVwQW5kQ2xvc2UiLCJwaW5nSW50ZXJ2YWxUaW1lciIsImZpbHRlcmVkVXBncmFkZXMiLCJkZXNjcmlwdGlvbiIsImRvT3BlbiIsImRvQ2xvc2UiLCJwYWNrZXRzIiwib25EYXRhIiwiZGVjb2RlUGFja2V0IiwiYmluYXJ5VHlwZSIsIlhNTEh0dHBSZXF1ZXN0IiwiWEhSIiwiSlNPTlAiLCJ3ZWJzb2NrZXQiLCJwb2xsaW5nIiwieGhyIiwieGQiLCJ4cyIsImlzU1NMIiwieGRvbWFpbiIsInhzY2hlbWUiLCJmb3JjZUpTT05QIiwiUG9sbGluZyIsImdsb2JhbFRoaXMiLCJyTmV3bGluZSIsInJFc2NhcGVkTmV3bGluZSIsImVtcHR5IiwiSlNPTlBQb2xsaW5nIiwiX1BvbGxpbmciLCJfX19laW8iLCJzY3JpcHQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJmb3JtIiwiaWZyYW1lIiwiZG9Qb2xsIiwiY3JlYXRlRWxlbWVudCIsImFzeW5jIiwic3JjIiwiaW5zZXJ0QXQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImluc2VydEJlZm9yZSIsImhlYWQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJpc1VBZ2Vja28iLCJkb1dyaXRlIiwiYXJlYSIsImlmcmFtZUlkIiwiY2xhc3NOYW1lIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0IiwibWV0aG9kIiwic2V0QXR0cmlidXRlIiwiYWN0aW9uIiwiY29tcGxldGUiLCJpbml0SWZyYW1lIiwiaHRtbCIsInN1Ym1pdCIsImF0dGFjaEV2ZW50Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwib25sb2FkIiwiX3JlcXVpcmUiLCJwaWNrIiwiaGFzWEhSMiIsInJlc3BvbnNlVHlwZSIsImZvcmNlQmFzZTY0IiwicmVxdWVzdCIsIlJlcXVlc3QiLCJyZXEiLCJwb2xsWGhyIiwiX3N1cGVyMiIsImV4dHJhSGVhZGVycyIsInNldERpc2FibGVIZWFkZXJDaGVjayIsInNldFJlcXVlc3RIZWFkZXIiLCJyZXF1ZXN0VGltZW91dCIsImhhc1hEUiIsIm9uTG9hZCIsInJlc3BvbnNlVGV4dCIsInN0YXR1cyIsInJlcXVlc3RzQ291bnQiLCJyZXF1ZXN0cyIsIm9uU3VjY2VzcyIsImZyb21FcnJvciIsImFib3J0IiwiWERvbWFpblJlcXVlc3QiLCJlbmFibGVzWERSIiwidW5sb2FkSGFuZGxlciIsInRlcm1pbmF0aW9uRXZlbnQiLCJ5ZWFzdCIsIl9UcmFuc3BvcnQiLCJwb2xsIiwib25QYXVzZSIsInRvdGFsIiwiY2FsbGJhY2siLCJkZWNvZGVQYXlsb2FkIiwiZW5jb2RlUGF5bG9hZCIsInNjaGVtYSIsInRpbWVzdGFtcFJlcXVlc3RzIiwiYjY0IiwiV2ViU29ja2V0IiwiTW96V2ViU29ja2V0IiwidXNpbmdCcm93c2VyV2ViU29ja2V0IiwiZGVmYXVsdEJpbmFyeVR5cGUiLCJfcmVxdWlyZTIiLCJpc1JlYWN0TmF0aXZlIiwicHJvZHVjdCIsIldTIiwiY2hlY2siLCJwcm90b2NvbHMiLCJoZWFkZXJzIiwid3MiLCJhZGRFdmVudExpc3RlbmVycyIsIm9ubWVzc2FnZSIsImVuY29kZVBhY2tldCIsIkJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJhdHRyIiwicmVkdWNlIiwiYWNjIiwiayIsImhhc0NPUlMiLCJQQUNLRVRfVFlQRVMiLCJQQUNLRVRfVFlQRVNfUkVWRVJTRSIsIkVSUk9SX1BBQ0tFVCIsIndpdGhOYXRpdmVBcnJheUJ1ZmZlciIsImJhc2U2NGRlY29kZXIiLCJlbmNvZGVkUGFja2V0IiwibWFwQmluYXJ5IiwiZGVjb2RlQmFzZTY0UGFja2V0IiwicGFja2V0VHlwZSIsImRlY29kZWQiLCJCbG9iIiwid2l0aE5hdGl2ZUJsb2IiLCJpc1ZpZXciLCJidWZmZXIiLCJfcmVmIiwiZW5jb2RlQmxvYkFzQmFzZTY0IiwiZmlsZVJlYWRlciIsIkZpbGVSZWFkZXIiLCJjb250ZW50IiwicmVhZEFzRGF0YVVSTCIsIlNFUEFSQVRPUiIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImNvdW50IiwiZW5jb2RlZFBheWxvYWQiLCJkZWNvZGVkUGFja2V0IiwiaCIsInciLCJ5IiwiaXNGaW5pdGUiLCJmbXRMb25nIiwiZm10U2hvcnQiLCJzdHIiLCJleGVjIiwicGFyc2VGbG9hdCIsIm1zQWJzIiwicm91bmQiLCJwbHVyYWwiLCJpc1BsdXJhbCIsImVuY29kZVVSSUNvbXBvbmVudCIsInFzIiwicXJ5IiwicGFpcnMiLCJwYWlyIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicmUiLCJwYXJ0cyIsImIiLCJhdXRob3JpdHkiLCJpcHY2dXJpIiwicGF0aE5hbWVzIiwicXVlcnlLZXkiLCJyZWd4IiwiJDAiLCIkMiIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiZGVmYXVsdENsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJxdWV1ZSIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImRyYWluUXVldWUiLCJydW4iLCJuZXh0VGljayIsIkl0ZW0iLCJhcnJheSIsInRpdGxlIiwiYnJvd3NlciIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwiYWRkTGlzdGVuZXIiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwiYmluZGluZyIsImN3ZCIsImNoZGlyIiwiZGlyIiwidW1hc2siLCJyZWNvbnN0cnVjdFBhY2tldCIsImRlY29uc3RydWN0UGFja2V0IiwiaXNfYmluYXJ5XzEiLCJidWZmZXJzIiwicGFja2V0RGF0YSIsInBhY2siLCJfZGVjb25zdHJ1Y3RQYWNrZXQiLCJhdHRhY2htZW50cyIsImlzQmluYXJ5IiwicGxhY2Vob2xkZXIiLCJfcGxhY2Vob2xkZXIiLCJudW0iLCJuZXdEYXRhIiwiX25ld0RhdGEiLCJfcmVjb25zdHJ1Y3RQYWNrZXQiLCJiaW5hcnlfMSIsImhhc0JpbmFyeSIsImVuY29kZUFzQmluYXJ5IiwiZW5jb2RlQXNTdHJpbmciLCJkZWNvbnN0cnVjdGlvbiIsImRlY29kZVN0cmluZyIsInJlY29uc3RydWN0b3IiLCJCaW5hcnlSZWNvbnN0cnVjdG9yIiwidGFrZUJpbmFyeURhdGEiLCJzdGFydCIsImJ1ZiIsIl9zdGFydCIsIl9zdGFydDIiLCJfYyIsInBheWxvYWQiLCJ0cnlQYXJzZSIsImlzUGF5bG9hZFZhbGlkIiwiZmluaXNoZWRSZWNvbnN0cnVjdGlvbiIsInJlY29uUGFjayIsImJpbkRhdGEiLCJ3aXRoTmF0aXZlRmlsZSIsIkZpbGUiLCJ0b0pTT04iLCJhbHBoYWJldCIsInNlZWQiLCJlbmNvZGVkIiwibm93Il0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFNBQVNBLGdDQUFULENBQTBDQyxJQUExQyxFQUFnREMsT0FBaEQsRUFBeUQ7QUFDekQsTUFBRywrQkFBT0MsT0FBUCxPQUFtQixRQUFuQixJQUErQiwrQkFBT0MsTUFBUCxPQUFrQixRQUFwRCxFQUNDQSxNQUFNLENBQUNELE9BQVAsR0FBaUJELE9BQU8sRUFBeEIsQ0FERCxLQUVLLElBQUcsSUFBSCxFQUNKRyxpQ0FBTyxFQUFELG9DQUFLSCxPQUFMO0FBQUE7QUFBQTtBQUFBLG9HQUFOLENBREksS0FFQSxFQUdKO0FBQ0QsQ0FURCxFQVNJLFlBQU07QUFDSixNQUFJLE9BQU9JLElBQVAsS0FBZ0IsV0FBcEIsRUFBaUM7QUFDN0IsV0FBT0EsSUFBUDtBQUNILEdBRkQsTUFFTyxJQUFJLE9BQU9DLE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7QUFDdEMsV0FBT0EsTUFBUDtBQUNILEdBRk0sTUFFQSxJQUFJLE9BQU9DLE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7QUFDdEMsV0FBT0EsTUFBUDtBQUNILEdBRk0sTUFFQTtBQUNILFdBQU9DLFFBQVEsQ0FBQyxhQUFELENBQVIsRUFBUDtBQUNIO0FBQ0YsQ0FWRixFQVRILEVBbUJVLFlBQVc7QUFDckI7QUFB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QTs7O0FBR0EsZUFBTy9zQixDQUFDLEdBQUd5RSxNQUFYLEVBQW1CekUsQ0FBQyxFQUFwQixFQUF3QjtBQUN0QnlaLGFBQUcsQ0FBQ3FULFFBQVEsQ0FBQzlzQixDQUFELENBQVQsQ0FBSCxHQUFtQkEsQ0FBbkI7QUFDRCxTQWxFcUQsQ0FrRXBEO0FBQ0Y7QUFDQTs7O0FBR0FnakIsYUFBSyxDQUFDL1csTUFBTixHQUFlQSxNQUFmO0FBQ0ErVyxhQUFLLENBQUN2UCxNQUFOLEdBQWVBLE1BQWY7QUFDQW5VLGNBQU0sQ0FBQ0QsT0FBUCxHQUFpQjJqQixLQUFqQjtBQUVBO0FBQU87QUFFUDs7QUF4M0xVLEtBdEZNO0FBQWhCO0FBKzhMQyxDQW4rTEQsRSIsImZpbGUiOiIuL3Jlc291cmNlcy9qcy9zb2NrZXQuaW8tY2xpZW50LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBTb2NrZXQuSU8gdjMuMC4zXG4gKiAoYykgMjAxNC0yMDIwIEd1aWxsZXJtbyBSYXVjaFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJpb1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJpb1wiXSA9IGZhY3RvcnkoKTtcbn0pKCgoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgICAgIH1cbiAgICB9KSgpLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9idWlsZC9pbmRleC5qc1wiKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKHtcblxuLyoqKi8gXCIuL2J1aWxkL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9idWlsZC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuU29ja2V0ID0gZXhwb3J0cy5pbyA9IGV4cG9ydHMuTWFuYWdlciA9IGV4cG9ydHMucHJvdG9jb2wgPSB2b2lkIDA7XG5cbnZhciB1cmxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXJsICovIFwiLi9idWlsZC91cmwuanNcIik7XG5cbnZhciBtYW5hZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21hbmFnZXIgKi8gXCIuL2J1aWxkL21hbmFnZXIuanNcIik7XG5cbnZhciBzb2NrZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc29ja2V0ICovIFwiLi9idWlsZC9zb2NrZXQuanNcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tldFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBzb2NrZXRfMS5Tb2NrZXQ7XG4gIH1cbn0pO1xuXG52YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkZWJ1ZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzXCIpKFwic29ja2V0LmlvLWNsaWVudFwiKTtcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBsb29rdXA7XG4vKipcbiAqIE1hbmFnZXJzIGNhY2hlLlxuICovXG5cbnZhciBjYWNoZSA9IGV4cG9ydHMubWFuYWdlcnMgPSB7fTtcblxuZnVuY3Rpb24gbG9va3VwKHVyaSwgb3B0cykge1xuICBpZiAoX3R5cGVvZih1cmkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdmFyIHBhcnNlZCA9IHVybF8xLnVybCh1cmkpO1xuICB2YXIgc291cmNlID0gcGFyc2VkLnNvdXJjZTtcbiAgdmFyIGlkID0gcGFyc2VkLmlkO1xuICB2YXIgcGF0aCA9IHBhcnNlZC5wYXRoO1xuICB2YXIgc2FtZU5hbWVzcGFjZSA9IGNhY2hlW2lkXSAmJiBwYXRoIGluIGNhY2hlW2lkXS5uc3BzO1xuICB2YXIgbmV3Q29ubmVjdGlvbiA9IG9wdHMuZm9yY2VOZXcgfHwgb3B0c1tcImZvcmNlIG5ldyBjb25uZWN0aW9uXCJdIHx8IGZhbHNlID09PSBvcHRzLm11bHRpcGxleCB8fCBzYW1lTmFtZXNwYWNlO1xuICB2YXIgaW87XG5cbiAgaWYgKG5ld0Nvbm5lY3Rpb24pIHtcbiAgICBkZWJ1ZyhcImlnbm9yaW5nIHNvY2tldCBjYWNoZSBmb3IgJXNcIiwgc291cmNlKTtcbiAgICBpbyA9IG5ldyBtYW5hZ2VyXzEuTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghY2FjaGVbaWRdKSB7XG4gICAgICBkZWJ1ZyhcIm5ldyBpbyBpbnN0YW5jZSBmb3IgJXNcIiwgc291cmNlKTtcbiAgICAgIGNhY2hlW2lkXSA9IG5ldyBtYW5hZ2VyXzEuTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICAgIH1cblxuICAgIGlvID0gY2FjaGVbaWRdO1xuICB9XG5cbiAgaWYgKHBhcnNlZC5xdWVyeSAmJiAhb3B0cy5xdWVyeSkge1xuICAgIG9wdHMucXVlcnkgPSBwYXJzZWQucXVlcnk7XG4gIH1cblxuICByZXR1cm4gaW8uc29ja2V0KHBhcnNlZC5wYXRoLCBvcHRzKTtcbn1cblxuZXhwb3J0cy5pbyA9IGxvb2t1cDtcbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAcHVibGljXG4gKi9cblxudmFyIHNvY2tldF9pb19wYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHNvY2tldC5pby1wYXJzZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2Rpc3QvaW5kZXguanNcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInByb3RvY29sXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHNvY2tldF9pb19wYXJzZXJfMS5wcm90b2NvbDtcbiAgfVxufSk7XG4vKipcbiAqIGBjb25uZWN0YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJpXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0cy5jb25uZWN0ID0gbG9va3VwO1xuLyoqXG4gKiBFeHBvc2UgY29uc3RydWN0b3JzIGZvciBzdGFuZGFsb25lIGJ1aWxkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG52YXIgbWFuYWdlcl8yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tYW5hZ2VyICovIFwiLi9idWlsZC9tYW5hZ2VyLmpzXCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNYW5hZ2VyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIG1hbmFnZXJfMi5NYW5hZ2VyO1xuICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9idWlsZC9tYW5hZ2VyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2J1aWxkL21hbmFnZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuTWFuYWdlciA9IHZvaWQgMDtcblxudmFyIGVpbyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGVuZ2luZS5pby1jbGllbnQgKi8gXCIuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi9pbmRleC5qc1wiKTtcblxudmFyIHNvY2tldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zb2NrZXQgKi8gXCIuL2J1aWxkL3NvY2tldC5qc1wiKTtcblxudmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb21wb25lbnQtZW1pdHRlciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzXCIpO1xuXG52YXIgcGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgc29ja2V0LmlvLXBhcnNlciAqLyBcIi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvZGlzdC9pbmRleC5qc1wiKTtcblxudmFyIG9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL29uICovIFwiLi9idWlsZC9vbi5qc1wiKTtcblxudmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb21wb25lbnQtYmluZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1iaW5kL2luZGV4LmpzXCIpO1xuXG52YXIgQmFja29mZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGJhY2tvMiAqLyBcIi4vbm9kZV9tb2R1bGVzL2JhY2tvMi9pbmRleC5qc1wiKTtcblxudmFyIGRlYnVnID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZGVidWcgKi8gXCIuL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qc1wiKShcInNvY2tldC5pby1jbGllbnQ6bWFuYWdlclwiKTtcblxudmFyIE1hbmFnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbWl0dGVyKSB7XG4gIF9pbmhlcml0cyhNYW5hZ2VyLCBfRW1pdHRlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihNYW5hZ2VyKTtcblxuICBmdW5jdGlvbiBNYW5hZ2VyKHVyaSwgb3B0cykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYW5hZ2VyKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgX3RoaXMubnNwcyA9IHt9O1xuICAgIF90aGlzLnN1YnMgPSBbXTtcbiAgICBfdGhpcy5jb25uZWN0aW5nID0gW107XG5cbiAgICBpZiAodXJpICYmIFwib2JqZWN0XCIgPT09IF90eXBlb2YodXJpKSkge1xuICAgICAgb3B0cyA9IHVyaTtcbiAgICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICBvcHRzLnBhdGggPSBvcHRzLnBhdGggfHwgXCIvc29ja2V0LmlvXCI7XG4gICAgX3RoaXMub3B0cyA9IG9wdHM7XG5cbiAgICBfdGhpcy5yZWNvbm5lY3Rpb24ob3B0cy5yZWNvbm5lY3Rpb24gIT09IGZhbHNlKTtcblxuICAgIF90aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzKG9wdHMucmVjb25uZWN0aW9uQXR0ZW1wdHMgfHwgSW5maW5pdHkpO1xuXG4gICAgX3RoaXMucmVjb25uZWN0aW9uRGVsYXkob3B0cy5yZWNvbm5lY3Rpb25EZWxheSB8fCAxMDAwKTtcblxuICAgIF90aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KG9wdHMucmVjb25uZWN0aW9uRGVsYXlNYXggfHwgNTAwMCk7XG5cbiAgICBfdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKG9wdHMucmFuZG9taXphdGlvbkZhY3RvciB8fCAwLjUpO1xuXG4gICAgX3RoaXMuYmFja29mZiA9IG5ldyBCYWNrb2ZmKHtcbiAgICAgIG1pbjogX3RoaXMucmVjb25uZWN0aW9uRGVsYXkoKSxcbiAgICAgIG1heDogX3RoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgoKSxcbiAgICAgIGppdHRlcjogX3RoaXMucmFuZG9taXphdGlvbkZhY3RvcigpXG4gICAgfSk7XG5cbiAgICBfdGhpcy50aW1lb3V0KG51bGwgPT0gb3B0cy50aW1lb3V0ID8gMjAwMDAgOiBvcHRzLnRpbWVvdXQpO1xuXG4gICAgX3RoaXMuX3JlYWR5U3RhdGUgPSBcImNsb3NlZFwiO1xuICAgIF90aGlzLnVyaSA9IHVyaTtcblxuICAgIHZhciBfcGFyc2VyID0gb3B0cy5wYXJzZXIgfHwgcGFyc2VyO1xuXG4gICAgX3RoaXMuZW5jb2RlciA9IG5ldyBfcGFyc2VyLkVuY29kZXIoKTtcbiAgICBfdGhpcy5kZWNvZGVyID0gbmV3IF9wYXJzZXIuRGVjb2RlcigpO1xuICAgIF90aGlzLl9hdXRvQ29ubmVjdCA9IG9wdHMuYXV0b0Nvbm5lY3QgIT09IGZhbHNlO1xuICAgIGlmIChfdGhpcy5fYXV0b0Nvbm5lY3QpIF90aGlzLm9wZW4oKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWFuYWdlciwgW3tcbiAgICBrZXk6IFwicmVjb25uZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlY29ubmVjdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb247XG4gICAgICB0aGlzLl9yZWNvbm5lY3Rpb24gPSAhIXY7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVjb25uZWN0aW9uQXR0ZW1wdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb25uZWN0aW9uQXR0ZW1wdHModikge1xuICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzO1xuICAgICAgdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMgPSB2O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlY29ubmVjdGlvbkRlbGF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlY29ubmVjdGlvbkRlbGF5KHYpIHtcbiAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheTtcbiAgICAgIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5ID0gdjtcbiAgICAgIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWluKHYpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJhbmRvbWl6YXRpb25GYWN0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmFuZG9taXphdGlvbkZhY3Rvcih2KSB7XG4gICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvcjtcbiAgICAgIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3IgPSB2O1xuICAgICAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRKaXR0ZXIodik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVjb25uZWN0aW9uRGVsYXlNYXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb25uZWN0aW9uRGVsYXlNYXgodikge1xuICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O1xuICAgICAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXggPSB2O1xuICAgICAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNYXgodik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGltZW91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aW1lb3V0KHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XG4gICAgICB0aGlzLl90aW1lb3V0ID0gdjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdHJ5aW5nIHRvIHJlY29ubmVjdCBpZiByZWNvbm5lY3Rpb24gaXMgZW5hYmxlZCBhbmQgd2UgaGF2ZSBub3RcbiAgICAgKiBzdGFydGVkIHJlY29ubmVjdGluZyB5ZXRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtYXliZVJlY29ubmVjdE9uT3BlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXliZVJlY29ubmVjdE9uT3BlbigpIHtcbiAgICAgIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3RpbmdcbiAgICAgIGlmICghdGhpcy5fcmVjb25uZWN0aW5nICYmIHRoaXMuX3JlY29ubmVjdGlvbiAmJiB0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPT09IDApIHtcbiAgICAgICAgLy8ga2VlcHMgcmVjb25uZWN0aW9uIGZyb20gZmlyaW5nIHR3aWNlIGZvciB0aGUgc2FtZSByZWNvbm5lY3Rpb24gbG9vcFxuICAgICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydCBgc29ja2V0YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gb3B0aW9uYWwsIGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7TWFuYWdlcn0gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9wZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3Blbihmbikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGRlYnVnKFwicmVhZHlTdGF0ZSAlc1wiLCB0aGlzLl9yZWFkeVN0YXRlKTtcbiAgICAgIGlmICh+dGhpcy5fcmVhZHlTdGF0ZS5pbmRleE9mKFwib3BlblwiKSkgcmV0dXJuIHRoaXM7XG4gICAgICBkZWJ1ZyhcIm9wZW5pbmcgJXNcIiwgdGhpcy51cmkpO1xuICAgICAgdGhpcy5lbmdpbmUgPSBlaW8odGhpcy51cmksIHRoaXMub3B0cyk7XG4gICAgICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlID0gXCJvcGVuaW5nXCI7XG4gICAgICB0aGlzLnNraXBSZWNvbm5lY3QgPSBmYWxzZTsgLy8gZW1pdCBgb3BlbmBcblxuICAgICAgdmFyIG9wZW5TdWIgPSBvbl8xLm9uKHNvY2tldCwgXCJvcGVuXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5vbm9wZW4oKTtcbiAgICAgICAgZm4gJiYgZm4oKTtcbiAgICAgIH0pOyAvLyBlbWl0IGBlcnJvcmBcblxuICAgICAgdmFyIGVycm9yU3ViID0gb25fMS5vbihzb2NrZXQsIFwiZXJyb3JcIiwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBkZWJ1ZyhcImVycm9yXCIpO1xuICAgICAgICBzZWxmLmNsZWFudXAoKTtcbiAgICAgICAgc2VsZi5fcmVhZHlTdGF0ZSA9IFwiY2xvc2VkXCI7XG5cbiAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoTWFuYWdlci5wcm90b3R5cGUpLCBcImVtaXRcIiwgX3RoaXMyKS5jYWxsKF90aGlzMiwgXCJlcnJvclwiLCBlcnIpO1xuXG4gICAgICAgIGlmIChmbikge1xuICAgICAgICAgIGZuKGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT25seSBkbyB0aGlzIGlmIHRoZXJlIGlzIG5vIGZuIHRvIGhhbmRsZSB0aGUgZXJyb3JcbiAgICAgICAgICBzZWxmLm1heWJlUmVjb25uZWN0T25PcGVuKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZmFsc2UgIT09IHRoaXMuX3RpbWVvdXQpIHtcbiAgICAgICAgdmFyIHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0O1xuICAgICAgICBkZWJ1ZyhcImNvbm5lY3QgYXR0ZW1wdCB3aWxsIHRpbWVvdXQgYWZ0ZXIgJWRcIiwgdGltZW91dCk7XG5cbiAgICAgICAgaWYgKHRpbWVvdXQgPT09IDApIHtcbiAgICAgICAgICBvcGVuU3ViLmRlc3Ryb3koKTsgLy8gcHJldmVudHMgYSByYWNlIGNvbmRpdGlvbiB3aXRoIHRoZSAnb3BlbicgZXZlbnRcbiAgICAgICAgfSAvLyBzZXQgdGltZXJcblxuXG4gICAgICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRlYnVnKFwiY29ubmVjdCBhdHRlbXB0IHRpbWVkIG91dCBhZnRlciAlZFwiLCB0aW1lb3V0KTtcbiAgICAgICAgICBvcGVuU3ViLmRlc3Ryb3koKTtcbiAgICAgICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICBzb2NrZXQuZW1pdChcImVycm9yXCIsIG5ldyBFcnJvcihcInRpbWVvdXRcIikpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3Vicy5wdXNoKG9wZW5TdWIpO1xuICAgICAgdGhpcy5zdWJzLnB1c2goZXJyb3JTdWIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciBvcGVuKClcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjb25uZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3QoZm4pIHtcbiAgICAgIHJldHVybiB0aGlzLm9wZW4oZm4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgb3Blbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbm9wZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25vcGVuKCkge1xuICAgICAgZGVidWcoXCJvcGVuXCIpOyAvLyBjbGVhciBvbGQgc3Vic1xuXG4gICAgICB0aGlzLmNsZWFudXAoKTsgLy8gbWFyayBhcyBvcGVuXG5cbiAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBcIm9wZW5cIjtcblxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoTWFuYWdlci5wcm90b3R5cGUpLCBcImVtaXRcIiwgdGhpcykuY2FsbCh0aGlzLCBcIm9wZW5cIik7IC8vIGFkZCBuZXcgc3Vic1xuXG5cbiAgICAgIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcbiAgICAgIHRoaXMuc3Vicy5wdXNoKG9uXzEub24oc29ja2V0LCBcImRhdGFcIiwgYmluZCh0aGlzLCBcIm9uZGF0YVwiKSkpO1xuICAgICAgdGhpcy5zdWJzLnB1c2gob25fMS5vbihzb2NrZXQsIFwicGluZ1wiLCBiaW5kKHRoaXMsIFwib25waW5nXCIpKSk7XG4gICAgICB0aGlzLnN1YnMucHVzaChvbl8xLm9uKHNvY2tldCwgXCJlcnJvclwiLCBiaW5kKHRoaXMsIFwib25lcnJvclwiKSkpO1xuICAgICAgdGhpcy5zdWJzLnB1c2gob25fMS5vbihzb2NrZXQsIFwiY2xvc2VcIiwgYmluZCh0aGlzLCBcIm9uY2xvc2VcIikpKTtcbiAgICAgIHRoaXMuc3Vicy5wdXNoKG9uXzEub24odGhpcy5kZWNvZGVyLCBcImRlY29kZWRcIiwgYmluZCh0aGlzLCBcIm9uZGVjb2RlZFwiKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBhIHBpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25waW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9ucGluZygpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE1hbmFnZXIucHJvdG90eXBlKSwgXCJlbWl0XCIsIHRoaXMpLmNhbGwodGhpcywgXCJwaW5nXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCBkYXRhLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uZGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbmRhdGEoZGF0YSkge1xuICAgICAgdGhpcy5kZWNvZGVyLmFkZChkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gcGFyc2VyIGZ1bGx5IGRlY29kZXMgYSBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25kZWNvZGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uZGVjb2RlZChwYWNrZXQpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE1hbmFnZXIucHJvdG90eXBlKSwgXCJlbWl0XCIsIHRoaXMpLmNhbGwodGhpcywgXCJwYWNrZXRcIiwgcGFja2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gc29ja2V0IGVycm9yLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uZXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICAgIGRlYnVnKFwiZXJyb3JcIiwgZXJyKTtcblxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoTWFuYWdlci5wcm90b3R5cGUpLCBcImVtaXRcIiwgdGhpcykuY2FsbCh0aGlzLCBcImVycm9yXCIsIGVycik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc29ja2V0IGZvciB0aGUgZ2l2ZW4gYG5zcGAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic29ja2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvY2tldChuc3AsIG9wdHMpIHtcbiAgICAgIHZhciBzb2NrZXQgPSB0aGlzLm5zcHNbbnNwXTtcblxuICAgICAgaWYgKCFzb2NrZXQpIHtcbiAgICAgICAgc29ja2V0ID0gbmV3IHNvY2tldF8xLlNvY2tldCh0aGlzLCBuc3AsIG9wdHMpO1xuICAgICAgICB0aGlzLm5zcHNbbnNwXSA9IHNvY2tldDtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBzb2NrZXQub24oXCJjb25uZWN0aW5nXCIsIG9uQ29ubmVjdGluZyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2F1dG9Db25uZWN0KSB7XG4gICAgICAgICAgLy8gbWFudWFsbHkgY2FsbCBoZXJlIHNpbmNlIGNvbm5lY3RpbmcgZXZlbnQgaXMgZmlyZWQgYmVmb3JlIGxpc3RlbmluZ1xuICAgICAgICAgIG9uQ29ubmVjdGluZygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uQ29ubmVjdGluZygpIHtcbiAgICAgICAgaWYgKCF+c2VsZi5jb25uZWN0aW5nLmluZGV4T2Yoc29ja2V0KSkge1xuICAgICAgICAgIHNlbGYuY29ubmVjdGluZy5wdXNoKHNvY2tldCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNvY2tldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gYSBzb2NrZXQgY2xvc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NvY2tldH0gc29ja2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KHNvY2tldCkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5jb25uZWN0aW5nLmluZGV4T2Yoc29ja2V0KTtcbiAgICAgIGlmICh+aW5kZXgpIHRoaXMuY29ubmVjdGluZy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgaWYgKHRoaXMuY29ubmVjdGluZy5sZW5ndGgpIHJldHVybjtcblxuICAgICAgdGhpcy5fY2xvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcGFja2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYWNrZXQocGFja2V0KSB7XG4gICAgICBkZWJ1ZyhcIndyaXRpbmcgcGFja2V0ICVqXCIsIHBhY2tldCk7XG4gICAgICBpZiAocGFja2V0LnF1ZXJ5ICYmIHBhY2tldC50eXBlID09PSAwKSBwYWNrZXQubnNwICs9IFwiP1wiICsgcGFja2V0LnF1ZXJ5O1xuICAgICAgdmFyIGVuY29kZWRQYWNrZXRzID0gdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWRQYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZW5naW5lLndyaXRlKGVuY29kZWRQYWNrZXRzW2ldLCBwYWNrZXQub3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFuIHVwIHRyYW5zcG9ydCBzdWJzY3JpcHRpb25zIGFuZCBwYWNrZXQgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsZWFudXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIGRlYnVnKFwiY2xlYW51cFwiKTtcbiAgICAgIHZhciBzdWJzTGVuZ3RoID0gdGhpcy5zdWJzLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN1YiA9IHRoaXMuc3Vicy5zaGlmdCgpO1xuICAgICAgICBzdWIuZGVzdHJveSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRlY29kZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgY3VycmVudCBzb2NrZXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Nsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbG9zZSgpIHtcbiAgICAgIGRlYnVnKFwiZGlzY29ubmVjdFwiKTtcbiAgICAgIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG4gICAgICB0aGlzLl9yZWNvbm5lY3RpbmcgPSBmYWxzZTtcblxuICAgICAgaWYgKFwib3BlbmluZ1wiID09PSB0aGlzLl9yZWFkeVN0YXRlKSB7XG4gICAgICAgIC8vIGBvbmNsb3NlYCB3aWxsIG5vdCBmaXJlIGJlY2F1c2VcbiAgICAgICAgLy8gYW4gb3BlbiBldmVudCBuZXZlciBoYXBwZW5lZFxuICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlID0gXCJjbG9zZWRcIjtcbiAgICAgIGlmICh0aGlzLmVuZ2luZSkgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIGNsb3NlKClcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXNjb25uZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2Nvbm5lY3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2xvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gZW5naW5lIGNsb3NlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25jbG9zZShyZWFzb24pIHtcbiAgICAgIGRlYnVnKFwib25jbG9zZVwiKTtcbiAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlID0gXCJjbG9zZWRcIjtcblxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoTWFuYWdlci5wcm90b3R5cGUpLCBcImVtaXRcIiwgdGhpcykuY2FsbCh0aGlzLCBcImNsb3NlXCIsIHJlYXNvbik7XG5cbiAgICAgIGlmICh0aGlzLl9yZWNvbm5lY3Rpb24gJiYgIXRoaXMuc2tpcFJlY29ubmVjdCkge1xuICAgICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0IGEgcmVjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlY29ubmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWNvbm5lY3QoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX3JlY29ubmVjdGluZyB8fCB0aGlzLnNraXBSZWNvbm5lY3QpIHJldHVybiB0aGlzO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5iYWNrb2ZmLmF0dGVtcHRzID49IHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzKSB7XG4gICAgICAgIGRlYnVnKFwicmVjb25uZWN0IGZhaWxlZFwiKTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG5cbiAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoTWFuYWdlci5wcm90b3R5cGUpLCBcImVtaXRcIiwgdGhpcykuY2FsbCh0aGlzLCBcInJlY29ubmVjdF9mYWlsZWRcIik7XG5cbiAgICAgICAgdGhpcy5fcmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGVsYXkgPSB0aGlzLmJhY2tvZmYuZHVyYXRpb24oKTtcbiAgICAgICAgZGVidWcoXCJ3aWxsIHdhaXQgJWRtcyBiZWZvcmUgcmVjb25uZWN0IGF0dGVtcHRcIiwgZGVsYXkpO1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG4gICAgICAgICAgZGVidWcoXCJhdHRlbXB0aW5nIHJlY29ubmVjdFwiKTtcblxuICAgICAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE1hbmFnZXIucHJvdG90eXBlKSwgXCJlbWl0XCIsIF90aGlzMykuY2FsbChfdGhpczMsIFwicmVjb25uZWN0X2F0dGVtcHRcIiwgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTsgLy8gY2hlY2sgYWdhaW4gZm9yIHRoZSBjYXNlIHNvY2tldCBjbG9zZWQgaW4gYWJvdmUgZXZlbnRzXG5cblxuICAgICAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcbiAgICAgICAgICBzZWxmLm9wZW4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICBkZWJ1ZyhcInJlY29ubmVjdCBhdHRlbXB0IGVycm9yXCIpO1xuICAgICAgICAgICAgICBzZWxmLl9yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgc2VsZi5yZWNvbm5lY3QoKTtcblxuICAgICAgICAgICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihNYW5hZ2VyLnByb3RvdHlwZSksIFwiZW1pdFwiLCBfdGhpczMpLmNhbGwoX3RoaXMzLCBcInJlY29ubmVjdF9lcnJvclwiLCBlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVidWcoXCJyZWNvbm5lY3Qgc3VjY2Vzc1wiKTtcbiAgICAgICAgICAgICAgc2VsZi5vbnJlY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlY29ubmVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbnJlY29ubmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbnJlY29ubmVjdCgpIHtcbiAgICAgIHZhciBhdHRlbXB0ID0gdGhpcy5iYWNrb2ZmLmF0dGVtcHRzO1xuICAgICAgdGhpcy5fcmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcblxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoTWFuYWdlci5wcm90b3R5cGUpLCBcImVtaXRcIiwgdGhpcykuY2FsbCh0aGlzLCBcInJlY29ubmVjdFwiLCBhdHRlbXB0KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWFuYWdlcjtcbn0oRW1pdHRlcik7XG5cbmV4cG9ydHMuTWFuYWdlciA9IE1hbmFnZXI7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vYnVpbGQvb24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2J1aWxkL29uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMub24gPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIG9uKG9iaiwgZXYsIGZuKSB7XG4gIG9iai5vbihldiwgZm4pO1xuICByZXR1cm4ge1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBvYmoucmVtb3ZlTGlzdGVuZXIoZXYsIGZuKTtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydHMub24gPSBvbjtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9idWlsZC9zb2NrZXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9idWlsZC9zb2NrZXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Tb2NrZXQgPSB2b2lkIDA7XG5cbnZhciBzb2NrZXRfaW9fcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBzb2NrZXQuaW8tcGFyc2VyICovIFwiLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9kaXN0L2luZGV4LmpzXCIpO1xuXG52YXIgRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvbXBvbmVudC1lbWl0dGVyICovIFwiLi9ub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanNcIik7XG5cbnZhciBvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9vbiAqLyBcIi4vYnVpbGQvb24uanNcIik7XG5cbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29tcG9uZW50LWJpbmQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb21wb25lbnQtYmluZC9pbmRleC5qc1wiKTtcblxudmFyIGRlYnVnID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZGVidWcgKi8gXCIuL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qc1wiKShcInNvY2tldC5pby1jbGllbnQ6c29ja2V0XCIpO1xuLyoqXG4gKiBJbnRlcm5hbCBldmVudHMuXG4gKiBUaGVzZSBldmVudHMgY2FuJ3QgYmUgZW1pdHRlZCBieSB0aGUgdXNlci5cbiAqL1xuXG5cbnZhciBSRVNFUlZFRF9FVkVOVFMgPSB7XG4gIGNvbm5lY3Q6IDEsXG4gIGNvbm5lY3RfZXJyb3I6IDEsXG4gIGRpc2Nvbm5lY3Q6IDEsXG4gIGRpc2Nvbm5lY3Rpbmc6IDEsXG4gIC8vIEV2ZW50RW1pdHRlciByZXNlcnZlZCBldmVudHM6IGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZXZlbnRzLmh0bWwjZXZlbnRzX2V2ZW50X25ld2xpc3RlbmVyXG4gIG5ld0xpc3RlbmVyOiAxLFxuICByZW1vdmVMaXN0ZW5lcjogMVxufTtcblxudmFyIFNvY2tldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VtaXR0ZXIpIHtcbiAgX2luaGVyaXRzKFNvY2tldCwgX0VtaXR0ZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoU29ja2V0KTtcblxuICAvKipcbiAgICogYFNvY2tldGAgY29uc3RydWN0b3IuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGZ1bmN0aW9uIFNvY2tldChpbywgbnNwLCBvcHRzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNvY2tldCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIF90aGlzLmlkcyA9IDA7XG4gICAgX3RoaXMuYWNrcyA9IHt9O1xuICAgIF90aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcbiAgICBfdGhpcy5zZW5kQnVmZmVyID0gW107XG4gICAgX3RoaXMuZmxhZ3MgPSB7fTtcbiAgICBfdGhpcy5pbyA9IGlvO1xuICAgIF90aGlzLm5zcCA9IG5zcDtcbiAgICBfdGhpcy5pZHMgPSAwO1xuICAgIF90aGlzLmFja3MgPSB7fTtcbiAgICBfdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG4gICAgX3RoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICAgIF90aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIF90aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgX3RoaXMuZmxhZ3MgPSB7fTtcblxuICAgIGlmIChvcHRzICYmIG9wdHMuYXV0aCkge1xuICAgICAgX3RoaXMuYXV0aCA9IG9wdHMuYXV0aDtcbiAgICB9XG5cbiAgICBpZiAoX3RoaXMuaW8uX2F1dG9Db25uZWN0KSBfdGhpcy5vcGVuKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gb3BlbiwgY2xvc2UgYW5kIHBhY2tldCBldmVudHNcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoU29ja2V0LCBbe1xuICAgIGtleTogXCJzdWJFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3ViRXZlbnRzKCkge1xuICAgICAgaWYgKHRoaXMuc3VicykgcmV0dXJuO1xuICAgICAgdmFyIGlvID0gdGhpcy5pbztcbiAgICAgIHRoaXMuc3VicyA9IFtvbl8xLm9uKGlvLCBcIm9wZW5cIiwgYmluZCh0aGlzLCBcIm9ub3BlblwiKSksIG9uXzEub24oaW8sIFwicGFja2V0XCIsIGJpbmQodGhpcywgXCJvbnBhY2tldFwiKSksIG9uXzEub24oaW8sIFwiY2xvc2VcIiwgYmluZCh0aGlzLCBcIm9uY2xvc2VcIikpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogXCJPcGVuc1wiIHRoZSBzb2NrZXQuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjb25uZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHJldHVybiB0aGlzO1xuICAgICAgdGhpcy5zdWJFdmVudHMoKTtcbiAgICAgIGlmICghdGhpcy5pby5fcmVjb25uZWN0aW5nKSB0aGlzLmlvLm9wZW4oKTsgLy8gZW5zdXJlIG9wZW5cblxuICAgICAgaWYgKFwib3BlblwiID09PSB0aGlzLmlvLl9yZWFkeVN0YXRlKSB0aGlzLm9ub3BlbigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciBjb25uZWN0KClcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9wZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbmQoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgYXJncy51bnNoaWZ0KFwibWVzc2FnZVwiKTtcbiAgICAgIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBgZW1pdGAuXG4gICAgICogSWYgdGhlIGV2ZW50IGlzIGluIGBldmVudHNgLCBpdCdzIGVtaXR0ZWQgbm9ybWFsbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXYgLSBldmVudCBuYW1lXG4gICAgICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZW1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0KGV2KSB7XG4gICAgICBpZiAoUkVTRVJWRURfRVZFTlRTLmhhc093blByb3BlcnR5KGV2KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGV2ICsgJ1wiIGlzIGEgcmVzZXJ2ZWQgZXZlbnQgbmFtZScpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBhcmdzLnVuc2hpZnQoZXYpO1xuICAgICAgdmFyIHBhY2tldCA9IHtcbiAgICAgICAgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuRVZFTlQsXG4gICAgICAgIGRhdGE6IGFyZ3NcbiAgICAgIH07XG4gICAgICBwYWNrZXQub3B0aW9ucyA9IHt9O1xuICAgICAgcGFja2V0Lm9wdGlvbnMuY29tcHJlc3MgPSB0aGlzLmZsYWdzLmNvbXByZXNzICE9PSBmYWxzZTsgLy8gZXZlbnQgYWNrIGNhbGxiYWNrXG5cbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgZGVidWcoXCJlbWl0dGluZyBwYWNrZXQgd2l0aCBhY2sgaWQgJWRcIiwgdGhpcy5pZHMpO1xuICAgICAgICB0aGlzLmFja3NbdGhpcy5pZHNdID0gYXJncy5wb3AoKTtcbiAgICAgICAgcGFja2V0LmlkID0gdGhpcy5pZHMrKztcbiAgICAgIH1cblxuICAgICAgdmFyIGlzVHJhbnNwb3J0V3JpdGFibGUgPSB0aGlzLmlvLmVuZ2luZSAmJiB0aGlzLmlvLmVuZ2luZS50cmFuc3BvcnQgJiYgdGhpcy5pby5lbmdpbmUudHJhbnNwb3J0LndyaXRhYmxlO1xuICAgICAgdmFyIGRpc2NhcmRQYWNrZXQgPSB0aGlzLmZsYWdzW1widm9sYXRpbGVcIl0gJiYgKCFpc1RyYW5zcG9ydFdyaXRhYmxlIHx8ICF0aGlzLmNvbm5lY3RlZCk7XG5cbiAgICAgIGlmIChkaXNjYXJkUGFja2V0KSB7XG4gICAgICAgIGRlYnVnKFwiZGlzY2FyZCBwYWNrZXQgYXMgdGhlIHRyYW5zcG9ydCBpcyBub3QgY3VycmVudGx5IHdyaXRhYmxlXCIpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLnBhY2tldChwYWNrZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZW5kQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5mbGFncyA9IHt9O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYWNrZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFja2V0KF9wYWNrZXQpIHtcbiAgICAgIF9wYWNrZXQubnNwID0gdGhpcy5uc3A7XG5cbiAgICAgIHRoaXMuaW8uX3BhY2tldChfcGFja2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gZW5naW5lIGBvcGVuYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbm9wZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25vcGVuKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGRlYnVnKFwidHJhbnNwb3J0IGlzIG9wZW4gLSBjb25uZWN0aW5nXCIpO1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuYXV0aCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5hdXRoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgX3RoaXMyLnBhY2tldCh7XG4gICAgICAgICAgICB0eXBlOiBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5DT05ORUNULFxuICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFja2V0KHtcbiAgICAgICAgICB0eXBlOiBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5DT05ORUNULFxuICAgICAgICAgIGRhdGE6IHRoaXMuYXV0aFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gZW5naW5lIGBjbG9zZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25jbG9zZShyZWFzb24pIHtcbiAgICAgIGRlYnVnKFwiY2xvc2UgKCVzKVwiLCByZWFzb24pO1xuICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgIGRlbGV0ZSB0aGlzLmlkO1xuXG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihTb2NrZXQucHJvdG90eXBlKSwgXCJlbWl0XCIsIHRoaXMpLmNhbGwodGhpcywgXCJkaXNjb25uZWN0XCIsIHJlYXNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIHNvY2tldCBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9ucGFja2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9ucGFja2V0KHBhY2tldCkge1xuICAgICAgdmFyIHNhbWVOYW1lc3BhY2UgPSBwYWNrZXQubnNwID09PSB0aGlzLm5zcDtcbiAgICAgIGlmICghc2FtZU5hbWVzcGFjZSkgcmV0dXJuO1xuXG4gICAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgICAgIGNhc2Ugc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQ09OTkVDVDpcbiAgICAgICAgICB2YXIgaWQgPSBwYWNrZXQuZGF0YS5zaWQ7XG4gICAgICAgICAgdGhpcy5vbmNvbm5lY3QoaWQpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2Ugc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuRVZFTlQ6XG4gICAgICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5CSU5BUllfRVZFTlQ6XG4gICAgICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5BQ0s6XG4gICAgICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2Ugc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQklOQVJZX0FDSzpcbiAgICAgICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5ESVNDT05ORUNUOlxuICAgICAgICAgIHRoaXMub25kaXNjb25uZWN0KCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5DT05ORUNUX0VSUk9SOlxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IocGFja2V0LmRhdGEubWVzc2FnZSk7IC8vIEB0cy1pZ25vcmVcblxuICAgICAgICAgIGVyci5kYXRhID0gcGFja2V0LmRhdGEuZGF0YTtcblxuICAgICAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKFNvY2tldC5wcm90b3R5cGUpLCBcImVtaXRcIiwgdGhpcykuY2FsbCh0aGlzLCBcImNvbm5lY3RfZXJyb3JcIiwgZXJyKTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25ldmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbmV2ZW50KHBhY2tldCkge1xuICAgICAgdmFyIGFyZ3MgPSBwYWNrZXQuZGF0YSB8fCBbXTtcbiAgICAgIGRlYnVnKFwiZW1pdHRpbmcgZXZlbnQgJWpcIiwgYXJncyk7XG5cbiAgICAgIGlmIChudWxsICE9IHBhY2tldC5pZCkge1xuICAgICAgICBkZWJ1ZyhcImF0dGFjaGluZyBhY2sgY2FsbGJhY2sgdG8gZXZlbnRcIik7XG4gICAgICAgIGFyZ3MucHVzaCh0aGlzLmFjayhwYWNrZXQuaWQpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZWNlaXZlQnVmZmVyLnB1c2goYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVtaXRFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0RXZlbnQoYXJncykge1xuICAgICAgaWYgKHRoaXMuX2FueUxpc3RlbmVycyAmJiB0aGlzLl9hbnlMaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9hbnlMaXN0ZW5lcnMuc2xpY2UoKTtcblxuICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobGlzdGVuZXJzKSxcbiAgICAgICAgICAgIF9zdGVwO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoU29ja2V0LnByb3RvdHlwZSksIFwiZW1pdFwiLCB0aGlzKS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYW4gYWNrIGNhbGxiYWNrIHRvIGVtaXQgd2l0aCBhbiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNrKGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VudCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gcHJldmVudCBkb3VibGUgY2FsbGJhY2tzXG4gICAgICAgIGlmIChzZW50KSByZXR1cm47XG4gICAgICAgIHNlbnQgPSB0cnVlO1xuXG4gICAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlYnVnKFwic2VuZGluZyBhY2sgJWpcIiwgYXJncyk7XG4gICAgICAgIHNlbGYucGFja2V0KHtcbiAgICAgICAgICB0eXBlOiBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5BQ0ssXG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIGRhdGE6IGFyZ3NcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBhY2tub3dsZWdlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25hY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25hY2socGFja2V0KSB7XG4gICAgICB2YXIgYWNrID0gdGhpcy5hY2tzW3BhY2tldC5pZF07XG5cbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBhY2spIHtcbiAgICAgICAgZGVidWcoXCJjYWxsaW5nIGFjayAlcyB3aXRoICVqXCIsIHBhY2tldC5pZCwgcGFja2V0LmRhdGEpO1xuICAgICAgICBhY2suYXBwbHkodGhpcywgcGFja2V0LmRhdGEpO1xuICAgICAgICBkZWxldGUgdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZyhcImJhZCBhY2sgJXNcIiwgcGFja2V0LmlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gc2VydmVyIGNvbm5lY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25jb25uZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uY29ubmVjdChpZCkge1xuICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5kaXNjb25uZWN0ZWQgPSBmYWxzZTtcblxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoU29ja2V0LnByb3RvdHlwZSksIFwiZW1pdFwiLCB0aGlzKS5jYWxsKHRoaXMsIFwiY29ubmVjdFwiKTtcblxuICAgICAgdGhpcy5lbWl0QnVmZmVyZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdCBidWZmZXJlZCBldmVudHMgKHJlY2VpdmVkIGFuZCBlbWl0dGVkKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbWl0QnVmZmVyZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdEJ1ZmZlcmVkKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQodGhpcy5yZWNlaXZlQnVmZmVyW2ldKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHRoaXMucGFja2V0KHRoaXMuc2VuZEJ1ZmZlcltfaV0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gc2VydmVyIGRpc2Nvbm5lY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25kaXNjb25uZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uZGlzY29ubmVjdCgpIHtcbiAgICAgIGRlYnVnKFwic2VydmVyIGRpc2Nvbm5lY3QgKCVzKVwiLCB0aGlzLm5zcCk7XG4gICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMub25jbG9zZShcImlvIHNlcnZlciBkaXNjb25uZWN0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBmb3JjZWQgY2xpZW50L3NlcnZlciBzaWRlIGRpc2Nvbm5lY3Rpb25zLFxuICAgICAqIHRoaXMgbWV0aG9kIGVuc3VyZXMgdGhlIG1hbmFnZXIgc3RvcHMgdHJhY2tpbmcgdXMgYW5kXG4gICAgICogdGhhdCByZWNvbm5lY3Rpb25zIGRvbid0IGdldCB0cmlnZ2VyZWQgZm9yIHRoaXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMuc3Vicykge1xuICAgICAgICAvLyBjbGVhbiBzdWJzY3JpcHRpb25zIHRvIGF2b2lkIHJlY29ubmVjdGlvbnNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1YnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnN1YnNbaV0uZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdWJzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pby5fZGVzdHJveSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdHMgdGhlIHNvY2tldCBtYW51YWxseS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc2Nvbm5lY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzY29ubmVjdCgpIHtcbiAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICBkZWJ1ZyhcInBlcmZvcm1pbmcgZGlzY29ubmVjdCAoJXMpXCIsIHRoaXMubnNwKTtcbiAgICAgICAgdGhpcy5wYWNrZXQoe1xuICAgICAgICAgIHR5cGU6IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkRJU0NPTk5FQ1RcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIHJlbW92ZSBzb2NrZXQgZnJvbSBwb29sXG5cblxuICAgICAgdGhpcy5kZXN0cm95KCk7XG5cbiAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAvLyBmaXJlIGV2ZW50c1xuICAgICAgICB0aGlzLm9uY2xvc2UoXCJpbyBjbGllbnQgZGlzY29ubmVjdFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciBkaXNjb25uZWN0KClcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjb21wcmVzcyAtIGlmIGB0cnVlYCwgY29tcHJlc3NlcyB0aGUgc2VuZGluZyBkYXRhXG4gICAgICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcHJlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcHJlc3MoX2NvbXByZXNzKSB7XG4gICAgICB0aGlzLmZsYWdzLmNvbXByZXNzID0gX2NvbXByZXNzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGV2ZW50IG1lc3NhZ2Ugd2lsbCBiZSBkcm9wcGVkIHdoZW4gdGhpcyBzb2NrZXQgaXMgbm90XG4gICAgICogcmVhZHkgdG8gc2VuZCBtZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTb2NrZXR9IHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbkFueVwiLFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBmaXJlZCB3aGVuIGFueSBldmVudCBpcyBlbWl0dGVkLiBUaGUgZXZlbnQgbmFtZSBpcyBwYXNzZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZVxuICAgICAqIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkFueShsaXN0ZW5lcikge1xuICAgICAgdGhpcy5fYW55TGlzdGVuZXJzID0gdGhpcy5fYW55TGlzdGVuZXJzIHx8IFtdO1xuXG4gICAgICB0aGlzLl9hbnlMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYW55IGV2ZW50IGlzIGVtaXR0ZWQuIFRoZSBldmVudCBuYW1lIGlzIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlXG4gICAgICogY2FsbGJhY2suIFRoZSBsaXN0ZW5lciBpcyBhZGRlZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0ZW5lcnMgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcmVwZW5kQW55XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZXBlbmRBbnkobGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuX2FueUxpc3RlbmVycyA9IHRoaXMuX2FueUxpc3RlbmVycyB8fCBbXTtcblxuICAgICAgdGhpcy5fYW55TGlzdGVuZXJzLnVuc2hpZnQobGlzdGVuZXIpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYW55IGV2ZW50IGlzIGVtaXR0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvZmZBbnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2ZmQW55KGxpc3RlbmVyKSB7XG4gICAgICBpZiAoIXRoaXMuX2FueUxpc3RlbmVycykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9hbnlMaXN0ZW5lcnM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAobGlzdGVuZXIgPT09IGxpc3RlbmVyc1tpXSkge1xuICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYW55TGlzdGVuZXJzID0gW107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGxpc3RlbmVycyB0aGF0IGFyZSBsaXN0ZW5pbmcgZm9yIGFueSBldmVudCB0aGF0IGlzIHNwZWNpZmllZC4gVGhpcyBhcnJheSBjYW4gYmUgbWFuaXB1bGF0ZWQsXG4gICAgICogZS5nLiB0byByZW1vdmUgbGlzdGVuZXJzLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGlzdGVuZXJzQW55XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3RlbmVyc0FueSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hbnlMaXN0ZW5lcnMgfHwgW107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZvbGF0aWxlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB0aGlzLmZsYWdzW1widm9sYXRpbGVcIl0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNvY2tldDtcbn0oRW1pdHRlcik7XG5cbmV4cG9ydHMuU29ja2V0ID0gU29ja2V0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2J1aWxkL3VybC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2J1aWxkL3VybC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy51cmwgPSB2b2lkIDA7XG5cbnZhciBwYXJzZXVyaSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHBhcnNldXJpICovIFwiLi9ub2RlX21vZHVsZXMvcGFyc2V1cmkvaW5kZXguanNcIik7XG5cbnZhciBkZWJ1ZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGRlYnVnICovIFwiLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanNcIikoXCJzb2NrZXQuaW8tY2xpZW50OnVybFwiKTtcbi8qKlxuICogVVJMIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJpIC0gdXJsXG4gKiBAcGFyYW0ge09iamVjdH0gbG9jIC0gQW4gb2JqZWN0IG1lYW50IHRvIG1pbWljIHdpbmRvdy5sb2NhdGlvbi5cbiAqICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byB3aW5kb3cubG9jYXRpb24uXG4gKiBAcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiB1cmwodXJpLCBsb2MpIHtcbiAgdmFyIG9iaiA9IHVyaTsgLy8gZGVmYXVsdCB0byB3aW5kb3cubG9jYXRpb25cblxuICBsb2MgPSBsb2MgfHwgdHlwZW9mIGxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiICYmIGxvY2F0aW9uO1xuICBpZiAobnVsbCA9PSB1cmkpIHVyaSA9IGxvYy5wcm90b2NvbCArIFwiLy9cIiArIGxvYy5ob3N0OyAvLyByZWxhdGl2ZSBwYXRoIHN1cHBvcnRcblxuICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHVyaSkge1xuICAgIGlmIChcIi9cIiA9PT0gdXJpLmNoYXJBdCgwKSkge1xuICAgICAgaWYgKFwiL1wiID09PSB1cmkuY2hhckF0KDEpKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9IGxvYy5ob3N0ICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdCh1cmkpKSB7XG4gICAgICBkZWJ1ZyhcInByb3RvY29sLWxlc3MgdXJsICVzXCIsIHVyaSk7XG5cbiAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgbG9jKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArIFwiLy9cIiArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9IFwiaHR0cHM6Ly9cIiArIHVyaTtcbiAgICAgIH1cbiAgICB9IC8vIHBhcnNlXG5cblxuICAgIGRlYnVnKFwicGFyc2UgJXNcIiwgdXJpKTtcbiAgICBvYmogPSBwYXJzZXVyaSh1cmkpO1xuICB9IC8vIG1ha2Ugc3VyZSB3ZSB0cmVhdCBgbG9jYWxob3N0OjgwYCBhbmQgYGxvY2FsaG9zdGAgZXF1YWxseVxuXG5cbiAgaWYgKCFvYmoucG9ydCkge1xuICAgIGlmICgvXihodHRwfHdzKSQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSBcIjgwXCI7XG4gICAgfSBlbHNlIGlmICgvXihodHRwfHdzKXMkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gXCI0NDNcIjtcbiAgICB9XG4gIH1cblxuICBvYmoucGF0aCA9IG9iai5wYXRoIHx8IFwiL1wiO1xuICB2YXIgaXB2NiA9IG9iai5ob3N0LmluZGV4T2YoXCI6XCIpICE9PSAtMTtcbiAgdmFyIGhvc3QgPSBpcHY2ID8gXCJbXCIgKyBvYmouaG9zdCArIFwiXVwiIDogb2JqLmhvc3Q7IC8vIGRlZmluZSB1bmlxdWUgaWRcblxuICBvYmouaWQgPSBvYmoucHJvdG9jb2wgKyBcIjovL1wiICsgaG9zdCArIFwiOlwiICsgb2JqLnBvcnQ7IC8vIGRlZmluZSBocmVmXG5cbiAgb2JqLmhyZWYgPSBvYmoucHJvdG9jb2wgKyBcIjovL1wiICsgaG9zdCArIChsb2MgJiYgbG9jLnBvcnQgPT09IG9iai5wb3J0ID8gXCJcIiA6IFwiOlwiICsgb2JqLnBvcnQpO1xuICByZXR1cm4gb2JqO1xufVxuXG5leHBvcnRzLnVybCA9IHVybDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvYmFja28yL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9iYWNrbzIvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogRXhwb3NlIGBCYWNrb2ZmYC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBCYWNrb2ZmO1xuLyoqXG4gKiBJbml0aWFsaXplIGJhY2tvZmYgdGltZXIgd2l0aCBgb3B0c2AuXG4gKlxuICogLSBgbWluYCBpbml0aWFsIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIFsxMDBdXG4gKiAtIGBtYXhgIG1heCB0aW1lb3V0IFsxMDAwMF1cbiAqIC0gYGppdHRlcmAgWzBdXG4gKiAtIGBmYWN0b3JgIFsyXVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEJhY2tvZmYob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdGhpcy5tcyA9IG9wdHMubWluIHx8IDEwMDtcbiAgdGhpcy5tYXggPSBvcHRzLm1heCB8fCAxMDAwMDtcbiAgdGhpcy5mYWN0b3IgPSBvcHRzLmZhY3RvciB8fCAyO1xuICB0aGlzLmppdHRlciA9IG9wdHMuaml0dGVyID4gMCAmJiBvcHRzLmppdHRlciA8PSAxID8gb3B0cy5qaXR0ZXIgOiAwO1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn1cbi8qKlxuICogUmV0dXJuIHRoZSBiYWNrb2ZmIGR1cmF0aW9uLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5CYWNrb2ZmLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG1zID0gdGhpcy5tcyAqIE1hdGgucG93KHRoaXMuZmFjdG9yLCB0aGlzLmF0dGVtcHRzKyspO1xuXG4gIGlmICh0aGlzLmppdHRlcikge1xuICAgIHZhciByYW5kID0gTWF0aC5yYW5kb20oKTtcbiAgICB2YXIgZGV2aWF0aW9uID0gTWF0aC5mbG9vcihyYW5kICogdGhpcy5qaXR0ZXIgKiBtcyk7XG4gICAgbXMgPSAoTWF0aC5mbG9vcihyYW5kICogMTApICYgMSkgPT0gMCA/IG1zIC0gZGV2aWF0aW9uIDogbXMgKyBkZXZpYXRpb247XG4gIH1cblxuICByZXR1cm4gTWF0aC5taW4obXMsIHRoaXMubWF4KSB8IDA7XG59O1xuLyoqXG4gKiBSZXNldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5CYWNrb2ZmLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG59O1xuLyoqXG4gKiBTZXQgdGhlIG1pbmltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuQmFja29mZi5wcm90b3R5cGUuc2V0TWluID0gZnVuY3Rpb24gKG1pbikge1xuICB0aGlzLm1zID0gbWluO1xufTtcbi8qKlxuICogU2V0IHRoZSBtYXhpbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1heCA9IGZ1bmN0aW9uIChtYXgpIHtcbiAgdGhpcy5tYXggPSBtYXg7XG59O1xuLyoqXG4gKiBTZXQgdGhlIGppdHRlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRKaXR0ZXIgPSBmdW5jdGlvbiAoaml0dGVyKSB7XG4gIHRoaXMuaml0dGVyID0gaml0dGVyO1xufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvYmFzZTY0LWFycmF5YnVmZmVyL2xpYi9iYXNlNjQtYXJyYXlidWZmZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYmFzZTY0LWFycmF5YnVmZmVyL2xpYi9iYXNlNjQtYXJyYXlidWZmZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLypcbiAqIGJhc2U2NC1hcnJheWJ1ZmZlclxuICogaHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBOaWtsYXMgdm9uIEhlcnR6ZW5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGNoYXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7IC8vIFVzZSBhIGxvb2t1cCB0YWJsZSB0byBmaW5kIHRoZSBpbmRleC5cblxuICB2YXIgbG9va3VwID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgbG9va3VwW2NoYXJzLmNoYXJDb2RlQXQoaSldID0gaTtcbiAgfVxuXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKGFycmF5YnVmZmVyKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLFxuICAgICAgICBpLFxuICAgICAgICBsZW4gPSBieXRlcy5sZW5ndGgsXG4gICAgICAgIGJhc2U2NCA9IFwiXCI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDMpIHtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpXSA+PiAyXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1soYnl0ZXNbaV0gJiAzKSA8PCA0IHwgYnl0ZXNbaSArIDFdID4+IDRdO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpICsgMV0gJiAxNSkgPDwgMiB8IGJ5dGVzW2kgKyAyXSA+PiA2XTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgfVxuXG4gICAgaWYgKGxlbiAlIDMgPT09IDIpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgXCI9XCI7XG4gICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAyKSArIFwiPT1cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTY0O1xuICB9O1xuXG4gIGV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKGJhc2U2NCkge1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBiYXNlNjQubGVuZ3RoICogMC43NSxcbiAgICAgICAgbGVuID0gYmFzZTY0Lmxlbmd0aCxcbiAgICAgICAgaSxcbiAgICAgICAgcCA9IDAsXG4gICAgICAgIGVuY29kZWQxLFxuICAgICAgICBlbmNvZGVkMixcbiAgICAgICAgZW5jb2RlZDMsXG4gICAgICAgIGVuY29kZWQ0O1xuXG4gICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMV0gPT09IFwiPVwiKSB7XG4gICAgICBidWZmZXJMZW5ndGgtLTtcblxuICAgICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMl0gPT09IFwiPVwiKSB7XG4gICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhcnJheWJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXJMZW5ndGgpLFxuICAgICAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgZW5jb2RlZDEgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSldO1xuICAgICAgZW5jb2RlZDIgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSArIDEpXTtcbiAgICAgIGVuY29kZWQzID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkgKyAyKV07XG4gICAgICBlbmNvZGVkNCA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpICsgMyldO1xuICAgICAgYnl0ZXNbcCsrXSA9IGVuY29kZWQxIDw8IDIgfCBlbmNvZGVkMiA+PiA0O1xuICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMiAmIDE1KSA8PCA0IHwgZW5jb2RlZDMgPj4gMjtcbiAgICAgIGJ5dGVzW3ArK10gPSAoZW5jb2RlZDMgJiAzKSA8PCA2IHwgZW5jb2RlZDQgJiA2MztcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlidWZmZXI7XG4gIH07XG59KSgpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb21wb25lbnQtYmluZC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb21wb25lbnQtYmluZC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFNsaWNlIHJlZmVyZW5jZS5cbiAqL1xudmFyIHNsaWNlID0gW10uc2xpY2U7XG4vKipcbiAqIEJpbmQgYG9iamAgdG8gYGZuYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gZm4gb3Igc3RyaW5nXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBmbikge1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGZuKSBmbiA9IG9ialtmbl07XG4gIGlmICgnZnVuY3Rpb24nICE9IHR5cGVvZiBmbikgdGhyb3cgbmV3IEVycm9yKCdiaW5kKCkgcmVxdWlyZXMgYSBmdW5jdGlvbicpO1xuICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgfTtcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxyXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gKi9cbmlmICh0cnVlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcbn1cbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXG5cblxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59XG5cbjtcbi8qKlxyXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cbi8qKlxyXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXG5cblxuRW1pdHRlci5wcm90b3R5cGUub24gPSBFbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSkucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxyXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xuXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gIGZ1bmN0aW9uIG9uKCkge1xuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIG9uLmZuID0gZm47XG4gIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXHJcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXG5cblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID0gRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307IC8vIGFsbFxuXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBzcGVjaWZpYyBldmVudFxuXG5cbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpczsgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuXG5cbiAgdmFyIGNiO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2IgPSBjYWxsYmFja3NbaV07XG5cbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSAvLyBSZW1vdmUgZXZlbnQgc3BlY2lmaWMgYXJyYXlzIGZvciBldmVudCB0eXBlcyB0aGF0IG5vXG4gIC8vIG9uZSBpcyBzdWJzY3JpYmVkIGZvciB0byBhdm9pZCBtZW1vcnkgbGVhay5cblxuXG4gIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG4vKipcclxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge01peGVkfSAuLi5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICovXG5cblxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKSxcbiAgICAgIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgfVxuXG4gIGlmIChjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXHJcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICogQGFwaSBwdWJsaWNcclxuICovXG5cblxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xuXG5cbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uIChldmVudCkge1xuICByZXR1cm4gISF0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKHByb2Nlc3MpIHtmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbJyMwMDAwQ0MnLCAnIzAwMDBGRicsICcjMDAzM0NDJywgJyMwMDMzRkYnLCAnIzAwNjZDQycsICcjMDA2NkZGJywgJyMwMDk5Q0MnLCAnIzAwOTlGRicsICcjMDBDQzAwJywgJyMwMENDMzMnLCAnIzAwQ0M2NicsICcjMDBDQzk5JywgJyMwMENDQ0MnLCAnIzAwQ0NGRicsICcjMzMwMENDJywgJyMzMzAwRkYnLCAnIzMzMzNDQycsICcjMzMzM0ZGJywgJyMzMzY2Q0MnLCAnIzMzNjZGRicsICcjMzM5OUNDJywgJyMzMzk5RkYnLCAnIzMzQ0MwMCcsICcjMzNDQzMzJywgJyMzM0NDNjYnLCAnIzMzQ0M5OScsICcjMzNDQ0NDJywgJyMzM0NDRkYnLCAnIzY2MDBDQycsICcjNjYwMEZGJywgJyM2NjMzQ0MnLCAnIzY2MzNGRicsICcjNjZDQzAwJywgJyM2NkNDMzMnLCAnIzk5MDBDQycsICcjOTkwMEZGJywgJyM5OTMzQ0MnLCAnIzk5MzNGRicsICcjOTlDQzAwJywgJyM5OUNDMzMnLCAnI0NDMDAwMCcsICcjQ0MwMDMzJywgJyNDQzAwNjYnLCAnI0NDMDA5OScsICcjQ0MwMENDJywgJyNDQzAwRkYnLCAnI0NDMzMwMCcsICcjQ0MzMzMzJywgJyNDQzMzNjYnLCAnI0NDMzM5OScsICcjQ0MzM0NDJywgJyNDQzMzRkYnLCAnI0NDNjYwMCcsICcjQ0M2NjMzJywgJyNDQzk5MDAnLCAnI0NDOTkzMycsICcjQ0NDQzAwJywgJyNDQ0NDMzMnLCAnI0ZGMDAwMCcsICcjRkYwMDMzJywgJyNGRjAwNjYnLCAnI0ZGMDA5OScsICcjRkYwMENDJywgJyNGRjAwRkYnLCAnI0ZGMzMwMCcsICcjRkYzMzMzJywgJyNGRjMzNjYnLCAnI0ZGMzM5OScsICcjRkYzM0NDJywgJyNGRjMzRkYnLCAnI0ZGNjYwMCcsICcjRkY2NjMzJywgJyNGRjk5MDAnLCAnI0ZGOTkzMycsICcjRkZDQzAwJywgJyNGRkNDMzMnXTtcbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXG5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cblxuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlIHx8IC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgd2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSB8fCAvLyBJcyBmaXJlZm94ID49IHYzMT9cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEgfHwgLy8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKTtcbn1cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgYXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgKyB0aGlzLm5hbWVzcGFjZSArICh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArIGFyZ3NbMF0gKyAodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgKyAnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdGhpcy51c2VDb2xvcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpOyAvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICBpZiAobWF0Y2ggPT09ICclJScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbmRleCsrO1xuXG4gICAgaWYgKG1hdGNoID09PSAnJWMnKSB7XG4gICAgICAvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBsb2coKSB7XG4gIHZhciBfY29uc29sZTtcblxuICAvLyBUaGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gKHR5cGVvZiBjb25zb2xlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoY29uc29sZSkpID09PSAnb2JqZWN0JyAmJiBjb25zb2xlLmxvZyAmJiAoX2NvbnNvbGUgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikgey8vIFN3YWxsb3dcbiAgICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgfVxufVxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuXG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuICB9IGNhdGNoIChlcnJvcikgey8vIFN3YWxsb3dcbiAgICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgfSAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cblxuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgLy8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuICAgIC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsvLyBTd2FsbG93XG4gICAgLy8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbW1vbiAqLyBcIi4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanNcIikoZXhwb3J0cyk7XG52YXIgZm9ybWF0dGVycyA9IG1vZHVsZS5leHBvcnRzLmZvcm1hdHRlcnM7XG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcbiAgfVxufTtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLy4uLy4uL3Byb2Nlc3MvYnJvd3Nlci5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiKSkpXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuICBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuICBjcmVhdGVEZWJ1Z1tcImRlZmF1bHRcIl0gPSBjcmVhdGVEZWJ1ZztcbiAgY3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuICBjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcbiAgY3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuICBjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcbiAgY3JlYXRlRGVidWcuaHVtYW5pemUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBtcyAqLyBcIi4vbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzXCIpO1xuICBPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcbiAgfSk7XG4gIC8qKlxuICAqIEFjdGl2ZSBgZGVidWdgIGluc3RhbmNlcy5cbiAgKi9cblxuICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMgPSBbXTtcbiAgLyoqXG4gICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gICovXG5cbiAgY3JlYXRlRGVidWcubmFtZXMgPSBbXTtcbiAgY3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcbiAgLyoqXG4gICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICAqXG4gICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICAqL1xuXG4gIGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcbiAgLyoqXG4gICogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcbiAgKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2VcbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuICBmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgICB2YXIgaGFzaCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG4gIH1cblxuICBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuICAvKipcbiAgKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuICAgIHZhciBwcmV2VGltZTtcblxuICAgIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIC8vIERpc2FibGVkP1xuICAgICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlbGYgPSBkZWJ1ZzsgLy8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblxuICAgICAgdmFyIGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG4gICAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgICAgc2VsZi5kaWZmID0gbXM7XG4gICAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgICBwcmV2VGltZSA9IGN1cnI7XG4gICAgICBhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICAgIH0gLy8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblxuXG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uIChtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAgIC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgdmFyIGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblxuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7IC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblxuICAgICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICBpbmRleC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7IC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cbiAgICAgIGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcbiAgICAgIHZhciBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcbiAgICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cblxuICAgIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICBkZWJ1Zy5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuICAgIGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuICAgIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcbiAgICBkZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcbiAgICBkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7IC8vIERlYnVnLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuICAgIC8vIGRlYnVnLnJhd0xvZyA9IHJhd0xvZztcbiAgICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXG4gICAgaWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcbiAgICB9XG5cbiAgICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMucHVzaChkZWJ1Zyk7XG4gICAgcmV0dXJuIGRlYnVnO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB2YXIgaW5kZXggPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGNyZWF0ZURlYnVnLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG4gICAgdmFyIG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcbiAgICBuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcbiAgICByZXR1cm4gbmV3RGVidWc7XG4gIH1cbiAgLyoqXG4gICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICAqIEBhcGkgcHVibGljXG4gICovXG5cblxuICBmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICAgIGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG4gICAgY3JlYXRlRGVidWcubmFtZXMgPSBbXTtcbiAgICBjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuICAgIHZhciBpO1xuICAgIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gICAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCFzcGxpdFtpXSkge1xuICAgICAgICAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cbiAgICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgICAgY3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZURlYnVnLmluc3RhbmNlc1tpXTtcbiAgICAgIGluc3RhbmNlLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICAqXG4gICogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgdmFyIG5hbWVzcGFjZXMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSkpLCBfdG9Db25zdW1hYmxlQXJyYXkoY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAoZnVuY3Rpb24gKG5hbWVzcGFjZSkge1xuICAgICAgcmV0dXJuICctJyArIG5hbWVzcGFjZTtcbiAgICB9KSkpLmpvaW4oJywnKTtcbiAgICBjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuICAgIHJldHVybiBuYW1lc3BhY2VzO1xuICB9XG4gIC8qKlxuICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICogQHJldHVybiB7Qm9vbGVhbn1cbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gICAgaWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAqIENvbnZlcnQgcmVnZXhwIHRvIG5hbWVzcGFjZVxuICAqXG4gICogQHBhcmFtIHtSZWdFeHB9IHJlZ3hlcFxuICAqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlXG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cblxuICBmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcbiAgICByZXR1cm4gcmVnZXhwLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIsIHJlZ2V4cC50b1N0cmluZygpLmxlbmd0aCAtIDIpLnJlcGxhY2UoL1xcLlxcKlxcPyQvLCAnKicpO1xuICB9XG4gIC8qKlxuICAqIENvZXJjZSBgdmFsYC5cbiAgKlxuICAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICAqIEByZXR1cm4ge01peGVkfVxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuXG5cbiAgZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgY3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG4gIHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvZ2xvYmFsVGhpcy5icm93c2VyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi9nbG9iYWxUaGlzLmJyb3dzZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gc2VsZjtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuICB9XG59KCk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBTb2NrZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NvY2tldCAqLyBcIi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3NvY2tldC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXJpLCBvcHRzKSB7XG4gIHJldHVybiBuZXcgU29ja2V0KHVyaSwgb3B0cyk7XG59O1xuLyoqXG4gKiBFeHBvc2UgZGVwcyBmb3IgbGVnYWN5IGNvbXBhdGliaWxpdHlcbiAqIGFuZCBzdGFuZGFsb25lIGJyb3dzZXIgYWNjZXNzLlxuICovXG5cblxubW9kdWxlLmV4cG9ydHMuU29ja2V0ID0gU29ja2V0O1xubW9kdWxlLmV4cG9ydHMucHJvdG9jb2wgPSBTb2NrZXQucHJvdG9jb2w7IC8vIHRoaXMgaXMgYW4gaW50XG5cbm1vZHVsZS5leHBvcnRzLlRyYW5zcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNwb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0LmpzXCIpO1xubW9kdWxlLmV4cG9ydHMudHJhbnNwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNwb3J0cy9pbmRleCAqLyBcIi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvaW5kZXguanNcIik7XG5tb2R1bGUuZXhwb3J0cy5wYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBlbmdpbmUuaW8tcGFyc2VyICovIFwiLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIvaW5kZXguanNcIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3NvY2tldC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbnZhciB0cmFuc3BvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc3BvcnRzL2luZGV4ICovIFwiLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9pbmRleC5qc1wiKTtcblxudmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb21wb25lbnQtZW1pdHRlciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzXCIpO1xuXG52YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkZWJ1ZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzXCIpKFwiZW5naW5lLmlvLWNsaWVudDpzb2NrZXRcIik7XG5cbnZhciBwYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBlbmdpbmUuaW8tcGFyc2VyICovIFwiLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIvaW5kZXguanNcIik7XG5cbnZhciBwYXJzZXVyaSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHBhcnNldXJpICovIFwiLi9ub2RlX21vZHVsZXMvcGFyc2V1cmkvaW5kZXguanNcIik7XG5cbnZhciBwYXJzZXFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcGFyc2VxcyAqLyBcIi4vbm9kZV9tb2R1bGVzL3BhcnNlcXMvaW5kZXguanNcIik7XG5cbnZhciBTb2NrZXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbWl0dGVyKSB7XG4gIF9pbmhlcml0cyhTb2NrZXQsIF9FbWl0dGVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFNvY2tldCk7XG5cbiAgLyoqXG4gICAqIFNvY2tldCBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB1cmkgb3Igb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgZnVuY3Rpb24gU29ja2V0KHVyaSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTb2NrZXQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcblxuICAgIGlmICh1cmkgJiYgXCJvYmplY3RcIiA9PT0gX3R5cGVvZih1cmkpKSB7XG4gICAgICBvcHRzID0gdXJpO1xuICAgICAgdXJpID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodXJpKSB7XG4gICAgICB1cmkgPSBwYXJzZXVyaSh1cmkpO1xuICAgICAgb3B0cy5ob3N0bmFtZSA9IHVyaS5ob3N0O1xuICAgICAgb3B0cy5zZWN1cmUgPSB1cmkucHJvdG9jb2wgPT09IFwiaHR0cHNcIiB8fCB1cmkucHJvdG9jb2wgPT09IFwid3NzXCI7XG4gICAgICBvcHRzLnBvcnQgPSB1cmkucG9ydDtcbiAgICAgIGlmICh1cmkucXVlcnkpIG9wdHMucXVlcnkgPSB1cmkucXVlcnk7XG4gICAgfSBlbHNlIGlmIChvcHRzLmhvc3QpIHtcbiAgICAgIG9wdHMuaG9zdG5hbWUgPSBwYXJzZXVyaShvcHRzLmhvc3QpLmhvc3Q7XG4gICAgfVxuXG4gICAgX3RoaXMuc2VjdXJlID0gbnVsbCAhPSBvcHRzLnNlY3VyZSA/IG9wdHMuc2VjdXJlIDogdHlwZW9mIGxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiICYmIFwiaHR0cHM6XCIgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuXG4gICAgaWYgKG9wdHMuaG9zdG5hbWUgJiYgIW9wdHMucG9ydCkge1xuICAgICAgLy8gaWYgbm8gcG9ydCBpcyBzcGVjaWZpZWQgbWFudWFsbHksIHVzZSB0aGUgcHJvdG9jb2wgZGVmYXVsdFxuICAgICAgb3B0cy5wb3J0ID0gX3RoaXMuc2VjdXJlID8gXCI0NDNcIiA6IFwiODBcIjtcbiAgICB9XG5cbiAgICBfdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWUgfHwgKHR5cGVvZiBsb2NhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIiA/IGxvY2F0aW9uLmhvc3RuYW1lIDogXCJsb2NhbGhvc3RcIik7XG4gICAgX3RoaXMucG9ydCA9IG9wdHMucG9ydCB8fCAodHlwZW9mIGxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiICYmIGxvY2F0aW9uLnBvcnQgPyBsb2NhdGlvbi5wb3J0IDogX3RoaXMuc2VjdXJlID8gNDQzIDogODApO1xuICAgIF90aGlzLnRyYW5zcG9ydHMgPSBvcHRzLnRyYW5zcG9ydHMgfHwgW1wicG9sbGluZ1wiLCBcIndlYnNvY2tldFwiXTtcbiAgICBfdGhpcy5yZWFkeVN0YXRlID0gXCJcIjtcbiAgICBfdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICAgIF90aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuICAgIF90aGlzLm9wdHMgPSBfZXh0ZW5kcyh7XG4gICAgICBwYXRoOiBcIi9lbmdpbmUuaW9cIixcbiAgICAgIGFnZW50OiBmYWxzZSxcbiAgICAgIHdpdGhDcmVkZW50aWFsczogZmFsc2UsXG4gICAgICB1cGdyYWRlOiB0cnVlLFxuICAgICAganNvbnA6IHRydWUsXG4gICAgICB0aW1lc3RhbXBQYXJhbTogXCJ0XCIsXG4gICAgICBwb2xpY3lQb3J0OiA4NDMsXG4gICAgICByZW1lbWJlclVwZ3JhZGU6IGZhbHNlLFxuICAgICAgcmVqZWN0VW5hdXRob3JpemVkOiB0cnVlLFxuICAgICAgcGVyTWVzc2FnZURlZmxhdGU6IHtcbiAgICAgICAgdGhyZXNob2xkOiAxMDI0XG4gICAgICB9LFxuICAgICAgdHJhbnNwb3J0T3B0aW9uczoge31cbiAgICB9LCBvcHRzKTtcbiAgICBfdGhpcy5vcHRzLnBhdGggPSBfdGhpcy5vcHRzLnBhdGgucmVwbGFjZSgvXFwvJC8sIFwiXCIpICsgXCIvXCI7XG5cbiAgICBpZiAodHlwZW9mIF90aGlzLm9wdHMucXVlcnkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIF90aGlzLm9wdHMucXVlcnkgPSBwYXJzZXFzLmRlY29kZShfdGhpcy5vcHRzLnF1ZXJ5KTtcbiAgICB9IC8vIHNldCBvbiBoYW5kc2hha2VcblxuXG4gICAgX3RoaXMuaWQgPSBudWxsO1xuICAgIF90aGlzLnVwZ3JhZGVzID0gbnVsbDtcbiAgICBfdGhpcy5waW5nSW50ZXJ2YWwgPSBudWxsO1xuICAgIF90aGlzLnBpbmdUaW1lb3V0ID0gbnVsbDsgLy8gc2V0IG9uIGhlYXJ0YmVhdFxuXG4gICAgX3RoaXMucGluZ1RpbWVvdXRUaW1lciA9IG51bGw7XG5cbiAgICBfdGhpcy5vcGVuKCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdHJhbnNwb3J0IG9mIHRoZSBnaXZlbiB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAgICogQHJldHVybiB7VHJhbnNwb3J0fVxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoU29ja2V0LCBbe1xuICAgIGtleTogXCJjcmVhdGVUcmFuc3BvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlVHJhbnNwb3J0KG5hbWUpIHtcbiAgICAgIGRlYnVnKCdjcmVhdGluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gICAgICB2YXIgcXVlcnkgPSBjbG9uZSh0aGlzLm9wdHMucXVlcnkpOyAvLyBhcHBlbmQgZW5naW5lLmlvIHByb3RvY29sIGlkZW50aWZpZXJcblxuICAgICAgcXVlcnkuRUlPID0gcGFyc2VyLnByb3RvY29sOyAvLyB0cmFuc3BvcnQgbmFtZVxuXG4gICAgICBxdWVyeS50cmFuc3BvcnQgPSBuYW1lOyAvLyBzZXNzaW9uIGlkIGlmIHdlIGFscmVhZHkgaGF2ZSBvbmVcblxuICAgICAgaWYgKHRoaXMuaWQpIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG5cbiAgICAgIHZhciBvcHRzID0gX2V4dGVuZHMoe30sIHRoaXMub3B0cy50cmFuc3BvcnRPcHRpb25zW25hbWVdLCB0aGlzLm9wdHMsIHtcbiAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICBzb2NrZXQ6IHRoaXMsXG4gICAgICAgIGhvc3RuYW1lOiB0aGlzLmhvc3RuYW1lLFxuICAgICAgICBzZWN1cmU6IHRoaXMuc2VjdXJlLFxuICAgICAgICBwb3J0OiB0aGlzLnBvcnRcbiAgICAgIH0pO1xuXG4gICAgICBkZWJ1ZyhcIm9wdGlvbnM6ICVqXCIsIG9wdHMpO1xuICAgICAgcmV0dXJuIG5ldyB0cmFuc3BvcnRzW25hbWVdKG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0cmFuc3BvcnQgdG8gdXNlIGFuZCBzdGFydHMgcHJvYmUuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9wZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgIHZhciB0cmFuc3BvcnQ7XG5cbiAgICAgIGlmICh0aGlzLm9wdHMucmVtZW1iZXJVcGdyYWRlICYmIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgJiYgdGhpcy50cmFuc3BvcnRzLmluZGV4T2YoXCJ3ZWJzb2NrZXRcIikgIT09IC0xKSB7XG4gICAgICAgIHRyYW5zcG9ydCA9IFwid2Vic29ja2V0XCI7XG4gICAgICB9IGVsc2UgaWYgKDAgPT09IHRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gRW1pdCBlcnJvciBvbiBuZXh0IHRpY2sgc28gaXQgY2FuIGJlIGxpc3RlbmVkIHRvXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgXCJObyB0cmFuc3BvcnRzIGF2YWlsYWJsZVwiKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zcG9ydCA9IHRoaXMudHJhbnNwb3J0c1swXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJvcGVuaW5nXCI7IC8vIFJldHJ5IHdpdGggdGhlIG5leHQgdHJhbnNwb3J0IGlmIHRoZSB0cmFuc3BvcnQgaXMgZGlzYWJsZWQgKGpzb25wOiBmYWxzZSlcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVidWcoXCJlcnJvciB3aGlsZSBjcmVhdGluZyB0cmFuc3BvcnQ6ICVzXCIsIGUpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydHMuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdHJhbnNwb3J0Lm9wZW4oKTtcbiAgICAgIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0LiBEaXNhYmxlcyB0aGUgZXhpc3Rpbmcgb25lIChpZiBhbnkpLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRUcmFuc3BvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCkge1xuICAgICAgZGVidWcoXCJzZXR0aW5nIHRyYW5zcG9ydCAlc1wiLCB0cmFuc3BvcnQubmFtZSk7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuICAgICAgICBkZWJ1ZyhcImNsZWFyaW5nIGV4aXN0aW5nIHRyYW5zcG9ydCAlc1wiLCB0aGlzLnRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICB9IC8vIHNldCB1cCB0cmFuc3BvcnRcblxuXG4gICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDsgLy8gc2V0IHVwIHRyYW5zcG9ydCBsaXN0ZW5lcnNcblxuICAgICAgdHJhbnNwb3J0Lm9uKFwiZHJhaW5cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLm9uRHJhaW4oKTtcbiAgICAgIH0pLm9uKFwicGFja2V0XCIsIGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgICAgICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuICAgICAgfSkub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBzZWxmLm9uRXJyb3IoZSk7XG4gICAgICB9KS5vbihcImNsb3NlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5vbkNsb3NlKFwidHJhbnNwb3J0IGNsb3NlXCIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2JlcyBhIHRyYW5zcG9ydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJvYmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvYmUobmFtZSkge1xuICAgICAgZGVidWcoJ3Byb2JpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICAgICAgdmFyIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KG5hbWUsIHtcbiAgICAgICAgcHJvYmU6IDFcbiAgICAgIH0pO1xuICAgICAgdmFyIGZhaWxlZCA9IGZhbHNlO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4gICAgICBmdW5jdGlvbiBvblRyYW5zcG9ydE9wZW4oKSB7XG4gICAgICAgIGlmIChzZWxmLm9ubHlCaW5hcnlVcGdyYWRlcykge1xuICAgICAgICAgIHZhciB1cGdyYWRlTG9zZXNCaW5hcnkgPSAhdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiBzZWxmLnRyYW5zcG9ydC5zdXBwb3J0c0JpbmFyeTtcbiAgICAgICAgICBmYWlsZWQgPSBmYWlsZWQgfHwgdXBncmFkZUxvc2VzQmluYXJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBvcGVuZWQnLCBuYW1lKTtcbiAgICAgICAgdHJhbnNwb3J0LnNlbmQoW3tcbiAgICAgICAgICB0eXBlOiBcInBpbmdcIixcbiAgICAgICAgICBkYXRhOiBcInByb2JlXCJcbiAgICAgICAgfV0pO1xuICAgICAgICB0cmFuc3BvcnQub25jZShcInBhY2tldFwiLCBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgICAgICAgaWYgKFwicG9uZ1wiID09PSBtc2cudHlwZSAmJiBcInByb2JlXCIgPT09IG1zZy5kYXRhKSB7XG4gICAgICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBwb25nJywgbmFtZSk7XG4gICAgICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IHRydWU7XG4gICAgICAgICAgICBzZWxmLmVtaXQoXCJ1cGdyYWRpbmdcIiwgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgIGlmICghdHJhbnNwb3J0KSByZXR1cm47XG4gICAgICAgICAgICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gXCJ3ZWJzb2NrZXRcIiA9PT0gdHJhbnNwb3J0Lm5hbWU7XG4gICAgICAgICAgICBkZWJ1ZygncGF1c2luZyBjdXJyZW50IHRyYW5zcG9ydCBcIiVzXCInLCBzZWxmLnRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgICAgIHNlbGYudHJhbnNwb3J0LnBhdXNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgICBpZiAoXCJjbG9zZWRcIiA9PT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgICAgICAgIGRlYnVnKFwiY2hhbmdpbmcgdHJhbnNwb3J0IGFuZCBzZW5kaW5nIHVwZ3JhZGUgcGFja2V0XCIpO1xuICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgIHNlbGYuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKFt7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1cGdyYWRlXCJcbiAgICAgICAgICAgICAgfV0pO1xuICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJ1cGdyYWRlXCIsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgICAgIHNlbGYudXBncmFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgIHNlbGYuZmx1c2goKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQnLCBuYW1lKTtcbiAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXCJwcm9iZSBlcnJvclwiKTtcbiAgICAgICAgICAgIGVyci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcbiAgICAgICAgICAgIHNlbGYuZW1pdChcInVwZ3JhZGVFcnJvclwiLCBlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZyZWV6ZVRyYW5zcG9ydCgpIHtcbiAgICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuOyAvLyBBbnkgY2FsbGJhY2sgY2FsbGVkIGJ5IHRyYW5zcG9ydCBzaG91bGQgYmUgaWdub3JlZCBzaW5jZSBub3dcblxuICAgICAgICBmYWlsZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICB0cmFuc3BvcnQgPSBudWxsO1xuICAgICAgfSAvLyBIYW5kbGUgYW55IGVycm9yIHRoYXQgaGFwcGVucyB3aGlsZSBwcm9iaW5nXG5cblxuICAgICAgZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwicHJvYmUgZXJyb3I6IFwiICsgZXJyKTtcbiAgICAgICAgZXJyb3IudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG4gICAgICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQgYmVjYXVzZSBvZiBlcnJvcjogJXMnLCBuYW1lLCBlcnIpO1xuICAgICAgICBzZWxmLmVtaXQoXCJ1cGdyYWRlRXJyb3JcIiwgZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblRyYW5zcG9ydENsb3NlKCkge1xuICAgICAgICBvbmVycm9yKFwidHJhbnNwb3J0IGNsb3NlZFwiKTtcbiAgICAgIH0gLy8gV2hlbiB0aGUgc29ja2V0IGlzIGNsb3NlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG5cblxuICAgICAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICAgICAgb25lcnJvcihcInNvY2tldCBjbG9zZWRcIik7XG4gICAgICB9IC8vIFdoZW4gdGhlIHNvY2tldCBpcyB1cGdyYWRlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG5cblxuICAgICAgZnVuY3Rpb24gb251cGdyYWRlKHRvKSB7XG4gICAgICAgIGlmICh0cmFuc3BvcnQgJiYgdG8ubmFtZSAhPT0gdHJhbnNwb3J0Lm5hbWUpIHtcbiAgICAgICAgICBkZWJ1ZygnXCIlc1wiIHdvcmtzIC0gYWJvcnRpbmcgXCIlc1wiJywgdG8ubmFtZSwgdHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuICAgICAgICB9XG4gICAgICB9IC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzIG9uIHRoZSB0cmFuc3BvcnQgYW5kIG9uIHNlbGZcblxuXG4gICAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJvcGVuXCIsIG9uVHJhbnNwb3J0T3Blbik7XG4gICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIG9uZXJyb3IpO1xuICAgICAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICAgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIG9uY2xvc2UpO1xuICAgICAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKFwidXBncmFkaW5nXCIsIG9udXBncmFkZSk7XG4gICAgICB9XG5cbiAgICAgIHRyYW5zcG9ydC5vbmNlKFwib3BlblwiLCBvblRyYW5zcG9ydE9wZW4pO1xuICAgICAgdHJhbnNwb3J0Lm9uY2UoXCJlcnJvclwiLCBvbmVycm9yKTtcbiAgICAgIHRyYW5zcG9ydC5vbmNlKFwiY2xvc2VcIiwgb25UcmFuc3BvcnRDbG9zZSk7XG4gICAgICB0aGlzLm9uY2UoXCJjbG9zZVwiLCBvbmNsb3NlKTtcbiAgICAgIHRoaXMub25jZShcInVwZ3JhZGluZ1wiLCBvbnVwZ3JhZGUpO1xuICAgICAgdHJhbnNwb3J0Lm9wZW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gY29ubmVjdGlvbiBpcyBkZWVtZWQgb3Blbi5cbiAgICAgKlxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbk9wZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25PcGVuKCkge1xuICAgICAgZGVidWcoXCJzb2NrZXQgb3BlblwiKTtcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwib3BlblwiO1xuICAgICAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IFwid2Vic29ja2V0XCIgPT09IHRoaXMudHJhbnNwb3J0Lm5hbWU7XG4gICAgICB0aGlzLmVtaXQoXCJvcGVuXCIpO1xuICAgICAgdGhpcy5mbHVzaCgpOyAvLyB3ZSBjaGVjayBmb3IgYHJlYWR5U3RhdGVgIGluIGNhc2UgYW4gYG9wZW5gXG4gICAgICAvLyBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlZCB0aGUgc29ja2V0XG5cbiAgICAgIGlmIChcIm9wZW5cIiA9PT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMub3B0cy51cGdyYWRlICYmIHRoaXMudHJhbnNwb3J0LnBhdXNlKSB7XG4gICAgICAgIGRlYnVnKFwic3RhcnRpbmcgdXBncmFkZSBwcm9iZXNcIik7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGwgPSB0aGlzLnVwZ3JhZGVzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMucHJvYmUodGhpcy51cGdyYWRlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25QYWNrZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25QYWNrZXQocGFja2V0KSB7XG4gICAgICBpZiAoXCJvcGVuaW5nXCIgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCBcIm9wZW5cIiA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8IFwiY2xvc2luZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgZGVidWcoJ3NvY2tldCByZWNlaXZlOiB0eXBlIFwiJXNcIiwgZGF0YSBcIiVzXCInLCBwYWNrZXQudHlwZSwgcGFja2V0LmRhdGEpO1xuICAgICAgICB0aGlzLmVtaXQoXCJwYWNrZXRcIiwgcGFja2V0KTsgLy8gU29ja2V0IGlzIGxpdmUgLSBhbnkgcGFja2V0IGNvdW50c1xuXG4gICAgICAgIHRoaXMuZW1pdChcImhlYXJ0YmVhdFwiKTtcblxuICAgICAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIm9wZW5cIjpcbiAgICAgICAgICAgIHRoaXMub25IYW5kc2hha2UoSlNPTi5wYXJzZShwYWNrZXQuZGF0YSkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwicGluZ1wiOlxuICAgICAgICAgICAgdGhpcy5yZXNldFBpbmdUaW1lb3V0KCk7XG4gICAgICAgICAgICB0aGlzLnNlbmRQYWNrZXQoXCJwb25nXCIpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwicG9uZ1wiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKFwic2VydmVyIGVycm9yXCIpO1xuICAgICAgICAgICAgZXJyLmNvZGUgPSBwYWNrZXQuZGF0YTtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihlcnIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGF0YVwiLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJtZXNzYWdlXCIsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygncGFja2V0IHJlY2VpdmVkIHdpdGggc29ja2V0IHJlYWR5U3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gaGFuZHNoYWtlIGNvbXBsZXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFuZHNoYWtlIG9ialxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25IYW5kc2hha2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25IYW5kc2hha2UoZGF0YSkge1xuICAgICAgdGhpcy5lbWl0KFwiaGFuZHNoYWtlXCIsIGRhdGEpO1xuICAgICAgdGhpcy5pZCA9IGRhdGEuc2lkO1xuICAgICAgdGhpcy50cmFuc3BvcnQucXVlcnkuc2lkID0gZGF0YS5zaWQ7XG4gICAgICB0aGlzLnVwZ3JhZGVzID0gdGhpcy5maWx0ZXJVcGdyYWRlcyhkYXRhLnVwZ3JhZGVzKTtcbiAgICAgIHRoaXMucGluZ0ludGVydmFsID0gZGF0YS5waW5nSW50ZXJ2YWw7XG4gICAgICB0aGlzLnBpbmdUaW1lb3V0ID0gZGF0YS5waW5nVGltZW91dDtcbiAgICAgIHRoaXMub25PcGVuKCk7IC8vIEluIGNhc2Ugb3BlbiBoYW5kbGVyIGNsb3NlcyBzb2NrZXRcblxuICAgICAgaWYgKFwiY2xvc2VkXCIgPT09IHRoaXMucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgdGhpcy5yZXNldFBpbmdUaW1lb3V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYW5kIHJlc2V0cyBwaW5nIHRpbWVvdXQgdGltZXIgYmFzZWQgb24gc2VydmVyIHBpbmdzLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXNldFBpbmdUaW1lb3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0UGluZ1RpbWVvdXQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG4gICAgICB0aGlzLnBpbmdUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLm9uQ2xvc2UoXCJwaW5nIHRpbWVvdXRcIik7XG4gICAgICB9LCB0aGlzLnBpbmdJbnRlcnZhbCArIHRoaXMucGluZ1RpbWVvdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgb24gYGRyYWluYCBldmVudFxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbkRyYWluXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRHJhaW4oKSB7XG4gICAgICB0aGlzLndyaXRlQnVmZmVyLnNwbGljZSgwLCB0aGlzLnByZXZCdWZmZXJMZW4pOyAvLyBzZXR0aW5nIHByZXZCdWZmZXJMZW4gPSAwIGlzIHZlcnkgaW1wb3J0YW50XG4gICAgICAvLyBmb3IgZXhhbXBsZSwgd2hlbiB1cGdyYWRpbmcsIHVwZ3JhZGUgcGFja2V0IGlzIHNlbnQgb3ZlcixcbiAgICAgIC8vIGFuZCBhIG5vbnplcm8gcHJldkJ1ZmZlckxlbiBjb3VsZCBjYXVzZSBwcm9ibGVtcyBvbiBgZHJhaW5gXG5cbiAgICAgIHRoaXMucHJldkJ1ZmZlckxlbiA9IDA7XG5cbiAgICAgIGlmICgwID09PSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJkcmFpblwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRmx1c2ggd3JpdGUgYnVmZmVycy5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmx1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICBpZiAoXCJjbG9zZWRcIiAhPT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudHJhbnNwb3J0LndyaXRhYmxlICYmICF0aGlzLnVwZ3JhZGluZyAmJiB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICBkZWJ1ZyhcImZsdXNoaW5nICVkIHBhY2tldHMgaW4gc29ja2V0XCIsIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLndyaXRlQnVmZmVyKTsgLy8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGxlbmd0aCBvZiB3cml0ZUJ1ZmZlclxuICAgICAgICAvLyBzcGxpY2Ugd3JpdGVCdWZmZXIgYW5kIGNhbGxiYWNrQnVmZmVyIG9uIGBkcmFpbmBcblxuICAgICAgICB0aGlzLnByZXZCdWZmZXJMZW4gPSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aDtcbiAgICAgICAgdGhpcy5lbWl0KFwiZmx1c2hcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICAgICAqIEByZXR1cm4ge1NvY2tldH0gZm9yIGNoYWluaW5nLlxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3cml0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3cml0ZShtc2csIG9wdGlvbnMsIGZuKSB7XG4gICAgICB0aGlzLnNlbmRQYWNrZXQoXCJtZXNzYWdlXCIsIG1zZywgb3B0aW9ucywgZm4pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZChtc2csIG9wdGlvbnMsIGZuKSB7XG4gICAgICB0aGlzLnNlbmRQYWNrZXQoXCJtZXNzYWdlXCIsIG1zZywgb3B0aW9ucywgZm4pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhY2tldCB0eXBlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2VuZFBhY2tldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kUGFja2V0KHR5cGUsIGRhdGEsIG9wdGlvbnMsIGZuKSB7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZGF0YSkge1xuICAgICAgICBmbiA9IGRhdGE7XG4gICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgICAgIGZuID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChcImNsb3NpbmdcIiA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8IFwiY2xvc2VkXCIgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgb3B0aW9ucy5jb21wcmVzcyA9IGZhbHNlICE9PSBvcHRpb25zLmNvbXByZXNzO1xuICAgICAgdmFyIHBhY2tldCA9IHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgfTtcbiAgICAgIHRoaXMuZW1pdChcInBhY2tldENyZWF0ZVwiLCBwYWNrZXQpO1xuICAgICAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gICAgICBpZiAoZm4pIHRoaXMub25jZShcImZsdXNoXCIsIGZuKTtcbiAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYgKFwib3BlbmluZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgXCJvcGVuXCIgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcImNsb3NpbmdcIjtcblxuICAgICAgICBpZiAodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLm9uY2UoXCJkcmFpblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy51cGdyYWRpbmcpIHtcbiAgICAgICAgICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy51cGdyYWRpbmcpIHtcbiAgICAgICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIHNlbGYub25DbG9zZShcImZvcmNlZCBjbG9zZVwiKTtcbiAgICAgICAgZGVidWcoXCJzb2NrZXQgY2xvc2luZyAtIHRlbGxpbmcgdHJhbnNwb3J0IHRvIGNsb3NlXCIpO1xuICAgICAgICBzZWxmLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjbGVhbnVwQW5kQ2xvc2UoKSB7XG4gICAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoXCJ1cGdyYWRlXCIsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoXCJ1cGdyYWRlRXJyb3JcIiwgY2xlYW51cEFuZENsb3NlKTtcbiAgICAgICAgY2xvc2UoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gd2FpdEZvclVwZ3JhZGUoKSB7XG4gICAgICAgIC8vIHdhaXQgZm9yIHVwZ3JhZGUgdG8gZmluaXNoIHNpbmNlIHdlIGNhbid0IHNlbmQgcGFja2V0cyB3aGlsZSBwYXVzaW5nIGEgdHJhbnNwb3J0XG4gICAgICAgIHNlbGYub25jZShcInVwZ3JhZGVcIiwgY2xlYW51cEFuZENsb3NlKTtcbiAgICAgICAgc2VsZi5vbmNlKFwidXBncmFkZUVycm9yXCIsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgZXJyb3JcbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25FcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkVycm9yKGVycikge1xuICAgICAgZGVidWcoXCJzb2NrZXQgZXJyb3IgJWpcIiwgZXJyKTtcbiAgICAgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycik7XG4gICAgICB0aGlzLm9uQ2xvc2UoXCJ0cmFuc3BvcnQgZXJyb3JcIiwgZXJyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbkNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2xvc2UocmVhc29uLCBkZXNjKSB7XG4gICAgICBpZiAoXCJvcGVuaW5nXCIgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCBcIm9wZW5cIiA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8IFwiY2xvc2luZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgZGVidWcoJ3NvY2tldCBjbG9zZSB3aXRoIHJlYXNvbjogXCIlc1wiJywgcmVhc29uKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzOyAvLyBjbGVhciB0aW1lcnNcblxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nSW50ZXJ2YWxUaW1lcik7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpOyAvLyBzdG9wIGV2ZW50IGZyb20gZmlyaW5nIGFnYWluIGZvciB0cmFuc3BvcnRcblxuICAgICAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJjbG9zZVwiKTsgLy8gZW5zdXJlIHRyYW5zcG9ydCB3b24ndCBzdGF5IG9wZW5cblxuICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpOyAvLyBpZ25vcmUgZnVydGhlciB0cmFuc3BvcnQgY29tbXVuaWNhdGlvblxuXG4gICAgICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpOyAvLyBzZXQgcmVhZHkgc3RhdGVcblxuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcImNsb3NlZFwiOyAvLyBjbGVhciBzZXNzaW9uIGlkXG5cbiAgICAgICAgdGhpcy5pZCA9IG51bGw7IC8vIGVtaXQgY2xvc2UgZXZlbnRcblxuICAgICAgICB0aGlzLmVtaXQoXCJjbG9zZVwiLCByZWFzb24sIGRlc2MpOyAvLyBjbGVhbiBidWZmZXJzIGFmdGVyLCBzbyB1c2VycyBjYW4gc3RpbGxcbiAgICAgICAgLy8gZ3JhYiB0aGUgYnVmZmVycyBvbiBgY2xvc2VgIGV2ZW50XG5cbiAgICAgICAgc2VsZi53cml0ZUJ1ZmZlciA9IFtdO1xuICAgICAgICBzZWxmLnByZXZCdWZmZXJMZW4gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaWx0ZXJzIHVwZ3JhZGVzLCByZXR1cm5pbmcgb25seSB0aG9zZSBtYXRjaGluZyBjbGllbnQgdHJhbnNwb3J0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNlcnZlciB1cGdyYWRlc1xuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaWx0ZXJVcGdyYWRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWx0ZXJVcGdyYWRlcyh1cGdyYWRlcykge1xuICAgICAgdmFyIGZpbHRlcmVkVXBncmFkZXMgPSBbXTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBqID0gdXBncmFkZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKDsgaSA8IGo7IGkrKykge1xuICAgICAgICBpZiAofnRoaXMudHJhbnNwb3J0cy5pbmRleE9mKHVwZ3JhZGVzW2ldKSkgZmlsdGVyZWRVcGdyYWRlcy5wdXNoKHVwZ3JhZGVzW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZpbHRlcmVkVXBncmFkZXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNvY2tldDtcbn0oRW1pdHRlcik7XG5cblNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDsgLy8gdGhpcyBpcyBhbiBpbnRcblxuZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gIHZhciBvID0ge307XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBvW2ldID0gb2JqW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxudmFyIHBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGVuZ2luZS5pby1wYXJzZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9pbmRleC5qc1wiKTtcblxudmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb21wb25lbnQtZW1pdHRlciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzXCIpO1xuXG52YXIgVHJhbnNwb3J0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRW1pdHRlcikge1xuICBfaW5oZXJpdHMoVHJhbnNwb3J0LCBfRW1pdHRlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihUcmFuc3BvcnQpO1xuXG4gIC8qKlxuICAgKiBUcmFuc3BvcnQgYWJzdHJhY3QgY29uc3RydWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIFRyYW5zcG9ydChvcHRzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zcG9ydCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIF90aGlzLm9wdHMgPSBvcHRzO1xuICAgIF90aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeTtcbiAgICBfdGhpcy5yZWFkeVN0YXRlID0gXCJcIjtcbiAgICBfdGhpcy5zb2NrZXQgPSBvcHRzLnNvY2tldDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEVtaXRzIGFuIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqIEByZXR1cm4ge1RyYW5zcG9ydH0gZm9yIGNoYWluaW5nXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFRyYW5zcG9ydCwgW3tcbiAgICBrZXk6IFwib25FcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkVycm9yKG1zZywgZGVzYykge1xuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICAgICAgZXJyLnR5cGUgPSBcIlRyYW5zcG9ydEVycm9yXCI7XG4gICAgICBlcnIuZGVzY3JpcHRpb24gPSBkZXNjO1xuICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9wZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgIGlmIChcImNsb3NlZFwiID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgXCJcIiA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwib3BlbmluZ1wiO1xuICAgICAgICB0aGlzLmRvT3BlbigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgaWYgKFwib3BlbmluZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgXCJvcGVuXCIgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICB0aGlzLmRvQ2xvc2UoKTtcbiAgICAgICAgdGhpcy5vbkNsb3NlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBtdWx0aXBsZSBwYWNrZXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kKHBhY2tldHMpIHtcbiAgICAgIGlmIChcIm9wZW5cIiA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgIHRoaXMud3JpdGUocGFja2V0cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3BvcnQgbm90IG9wZW5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIG9wZW5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25PcGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uT3BlbigpIHtcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwib3BlblwiO1xuICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgICB0aGlzLmVtaXQoXCJvcGVuXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRhdGEoZGF0YSkge1xuICAgICAgdmFyIHBhY2tldCA9IHBhcnNlci5kZWNvZGVQYWNrZXQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSk7XG4gICAgICB0aGlzLm9uUGFja2V0KHBhY2tldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIGEgZGVjb2RlZCBwYWNrZXQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblBhY2tldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblBhY2tldChwYWNrZXQpIHtcbiAgICAgIHRoaXMuZW1pdChcInBhY2tldFwiLCBwYWNrZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBjbG9zZS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25DbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNsb3NlKCkge1xuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJjbG9zZWRcIjtcbiAgICAgIHRoaXMuZW1pdChcImNsb3NlXCIpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUcmFuc3BvcnQ7XG59KEVtaXR0ZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zcG9ydDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB4bWxodHRwcmVxdWVzdC1zc2wgKi8gXCIuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi94bWxodHRwcmVxdWVzdC5qc1wiKTtcblxudmFyIFhIUiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcG9sbGluZy14aHIgKi8gXCIuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcteGhyLmpzXCIpO1xuXG52YXIgSlNPTlAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3BvbGxpbmctanNvbnAgKi8gXCIuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmctanNvbnAuanNcIik7XG5cbnZhciB3ZWJzb2NrZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3dlYnNvY2tldCAqLyBcIi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvd2Vic29ja2V0LmpzXCIpO1xuXG5leHBvcnRzLnBvbGxpbmcgPSBwb2xsaW5nO1xuZXhwb3J0cy53ZWJzb2NrZXQgPSB3ZWJzb2NrZXQ7XG4vKipcbiAqIFBvbGxpbmcgdHJhbnNwb3J0IHBvbHltb3JwaGljIGNvbnN0cnVjdG9yLlxuICogRGVjaWRlcyBvbiB4aHIgdnMganNvbnAgYmFzZWQgb24gZmVhdHVyZSBkZXRlY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcG9sbGluZyhvcHRzKSB7XG4gIHZhciB4aHI7XG4gIHZhciB4ZCA9IGZhbHNlO1xuICB2YXIgeHMgPSBmYWxzZTtcbiAgdmFyIGpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG5cbiAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBpc1NTTCA9IFwiaHR0cHM6XCIgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDsgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB4ZCA9IG9wdHMuaG9zdG5hbWUgIT09IGxvY2F0aW9uLmhvc3RuYW1lIHx8IHBvcnQgIT09IG9wdHMucG9ydDtcbiAgICB4cyA9IG9wdHMuc2VjdXJlICE9PSBpc1NTTDtcbiAgfVxuXG4gIG9wdHMueGRvbWFpbiA9IHhkO1xuICBvcHRzLnhzY2hlbWUgPSB4cztcbiAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuXG4gIGlmIChcIm9wZW5cIiBpbiB4aHIgJiYgIW9wdHMuZm9yY2VKU09OUCkge1xuICAgIHJldHVybiBuZXcgWEhSKG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghanNvbnApIHRocm93IG5ldyBFcnJvcihcIkpTT05QIGRpc2FibGVkXCIpO1xuICAgIHJldHVybiBuZXcgSlNPTlAob3B0cyk7XG4gIH1cbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLWpzb25wLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmctanNvbnAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxudmFyIFBvbGxpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3BvbGxpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcuanNcIik7XG5cbnZhciBnbG9iYWxUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZ2xvYmFsVGhpcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL2dsb2JhbFRoaXMuYnJvd3Nlci5qc1wiKTtcblxudmFyIHJOZXdsaW5lID0gL1xcbi9nO1xudmFyIHJFc2NhcGVkTmV3bGluZSA9IC9cXFxcbi9nO1xuLyoqXG4gKiBHbG9iYWwgSlNPTlAgY2FsbGJhY2tzLlxuICovXG5cbnZhciBjYWxsYmFja3M7XG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkoKSB7fVxuXG52YXIgSlNPTlBQb2xsaW5nID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUG9sbGluZykge1xuICBfaW5oZXJpdHMoSlNPTlBQb2xsaW5nLCBfUG9sbGluZyk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihKU09OUFBvbGxpbmcpO1xuXG4gIC8qKlxuICAgKiBKU09OUCBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG4gIGZ1bmN0aW9uIEpTT05QUG9sbGluZyhvcHRzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEpTT05QUG9sbGluZyk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdHMpO1xuICAgIF90aGlzLnF1ZXJ5ID0gX3RoaXMucXVlcnkgfHwge307IC8vIGRlZmluZSBnbG9iYWwgY2FsbGJhY2tzIGFycmF5IGlmIG5vdCBwcmVzZW50XG4gICAgLy8gd2UgZG8gdGhpcyBoZXJlIChsYXppbHkpIHRvIGF2b2lkIHVubmVlZGVkIGdsb2JhbCBwb2xsdXRpb25cblxuICAgIGlmICghY2FsbGJhY2tzKSB7XG4gICAgICAvLyB3ZSBuZWVkIHRvIGNvbnNpZGVyIG11bHRpcGxlIGVuZ2luZXMgaW4gdGhlIHNhbWUgcGFnZVxuICAgICAgY2FsbGJhY2tzID0gZ2xvYmFsVGhpcy5fX19laW8gPSBnbG9iYWxUaGlzLl9fX2VpbyB8fCBbXTtcbiAgICB9IC8vIGNhbGxiYWNrIGlkZW50aWZpZXJcblxuXG4gICAgX3RoaXMuaW5kZXggPSBjYWxsYmFja3MubGVuZ3RoOyAvLyBhZGQgY2FsbGJhY2sgdG8ganNvbnAgZ2xvYmFsXG5cbiAgICB2YXIgc2VsZiA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpO1xuXG4gICAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKG1zZykge1xuICAgICAgc2VsZi5vbkRhdGEobXNnKTtcbiAgICB9KTsgLy8gYXBwZW5kIHRvIHF1ZXJ5IHN0cmluZ1xuXG4gICAgX3RoaXMucXVlcnkuaiA9IF90aGlzLmluZGV4OyAvLyBwcmV2ZW50IHNwdXJpb3VzIGVycm9ycyBmcm9tIGJlaW5nIGVtaXR0ZWQgd2hlbiB0aGUgd2luZG93IGlzIHVubG9hZGVkXG5cbiAgICBpZiAodHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzZWxmLnNjcmlwdCkgc2VsZi5zY3JpcHQub25lcnJvciA9IGVtcHR5O1xuICAgICAgfSwgZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogSlNPTlAgb25seSBzdXBwb3J0cyBiaW5hcnkgYXMgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhKU09OUFBvbGxpbmcsIFt7XG4gICAga2V5OiBcImRvQ2xvc2VcIixcblxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgc29ja2V0LlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvQ2xvc2UoKSB7XG4gICAgICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICAgICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZm9ybSkge1xuICAgICAgICB0aGlzLmZvcm0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZvcm0pO1xuICAgICAgICB0aGlzLmZvcm0gPSBudWxsO1xuICAgICAgICB0aGlzLmlmcmFtZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKEpTT05QUG9sbGluZy5wcm90b3R5cGUpLCBcImRvQ2xvc2VcIiwgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZG9Qb2xsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvUG9sbCgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuXG4gICAgICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICAgICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICAgIHNjcmlwdC5zcmMgPSB0aGlzLnVyaSgpO1xuXG4gICAgICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHNlbGYub25FcnJvcihcImpzb25wIHBvbGwgZXJyb3JcIiwgZSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgaW5zZXJ0QXQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKVswXTtcblxuICAgICAgaWYgKGluc2VydEF0KSB7XG4gICAgICAgIGluc2VydEF0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaW5zZXJ0QXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zY3JpcHQgPSBzY3JpcHQ7XG4gICAgICB2YXIgaXNVQWdlY2tvID0gXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIG5hdmlnYXRvciAmJiAvZ2Vja28vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4gICAgICBpZiAoaXNVQWdlY2tvKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyB3aXRoIGEgaGlkZGVuIGlmcmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRvV3JpdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG9Xcml0ZShkYXRhLCBmbikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGlmcmFtZTtcblxuICAgICAgaWYgKCF0aGlzLmZvcm0pIHtcbiAgICAgICAgdmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKTtcbiAgICAgICAgdmFyIGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIik7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuaWZyYW1lSWQgPSBcImVpb19pZnJhbWVfXCIgKyB0aGlzLmluZGV4O1xuICAgICAgICBmb3JtLmNsYXNzTmFtZSA9IFwic29ja2V0aW9cIjtcbiAgICAgICAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgZm9ybS5zdHlsZS50b3AgPSBcIi0xMDAwcHhcIjtcbiAgICAgICAgZm9ybS5zdHlsZS5sZWZ0ID0gXCItMTAwMHB4XCI7XG4gICAgICAgIGZvcm0udGFyZ2V0ID0gaWQ7XG4gICAgICAgIGZvcm0ubWV0aG9kID0gXCJQT1NUXCI7XG4gICAgICAgIGZvcm0uc2V0QXR0cmlidXRlKFwiYWNjZXB0LWNoYXJzZXRcIiwgXCJ1dGYtOFwiKTtcbiAgICAgICAgYXJlYS5uYW1lID0gXCJkXCI7XG4gICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG4gICAgICAgIHRoaXMuZm9ybSA9IGZvcm07XG4gICAgICAgIHRoaXMuYXJlYSA9IGFyZWE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZm9ybS5hY3Rpb24gPSB0aGlzLnVyaSgpO1xuXG4gICAgICBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgaW5pdElmcmFtZSgpO1xuICAgICAgICBmbigpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbml0SWZyYW1lKCkge1xuICAgICAgICBpZiAoc2VsZi5pZnJhbWUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2VsZi5mb3JtLnJlbW92ZUNoaWxkKHNlbGYuaWZyYW1lKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBzZWxmLm9uRXJyb3IoXCJqc29ucCBwb2xsaW5nIGlmcmFtZSByZW1vdmFsIGVycm9yXCIsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gaWU2IGR5bmFtaWMgaWZyYW1lcyB3aXRoIHRhcmdldD1cIlwiIHN1cHBvcnQgKHRoYW5rcyBDaHJpcyBMYW1iYWNoZXIpXG4gICAgICAgICAgdmFyIGh0bWwgPSAnPGlmcmFtZSBzcmM9XCJqYXZhc2NyaXB0OjBcIiBuYW1lPVwiJyArIHNlbGYuaWZyYW1lSWQgKyAnXCI+JztcbiAgICAgICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGh0bWwpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICAgICAgICBpZnJhbWUubmFtZSA9IHNlbGYuaWZyYW1lSWQ7XG4gICAgICAgICAgaWZyYW1lLnNyYyA9IFwiamF2YXNjcmlwdDowXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZnJhbWUuaWQgPSBzZWxmLmlmcmFtZUlkO1xuICAgICAgICBzZWxmLmZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgc2VsZi5pZnJhbWUgPSBpZnJhbWU7XG4gICAgICB9XG5cbiAgICAgIGluaXRJZnJhbWUoKTsgLy8gZXNjYXBlIFxcbiB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgY29udmVydGVkIGludG8gXFxyXFxuIGJ5IHNvbWUgVUFzXG4gICAgICAvLyBkb3VibGUgZXNjYXBpbmcgaXMgcmVxdWlyZWQgZm9yIGVzY2FwZWQgbmV3IGxpbmVzIGJlY2F1c2UgdW5lc2NhcGluZyBvZiBuZXcgbGluZXMgY2FuIGJlIGRvbmUgc2FmZWx5IG9uIHNlcnZlci1zaWRlXG5cbiAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UockVzY2FwZWROZXdsaW5lLCBcIlxcXFxcXG5cIik7XG4gICAgICB0aGlzLmFyZWEudmFsdWUgPSBkYXRhLnJlcGxhY2Uock5ld2xpbmUsIFwiXFxcXG5cIik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZm9ybS5zdWJtaXQoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgIGlmICh0aGlzLmlmcmFtZS5hdHRhY2hFdmVudCkge1xuICAgICAgICB0aGlzLmlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHNlbGYuaWZyYW1lLnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlmcmFtZS5vbmxvYWQgPSBjb21wbGV0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3VwcG9ydHNCaW5hcnlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSlNPTlBQb2xsaW5nO1xufShQb2xsaW5nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBKU09OUFBvbGxpbmc7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy14aHIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcteGhyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vKiBnbG9iYWwgYXR0YWNoRXZlbnQgKi9cbnZhciBYTUxIdHRwUmVxdWVzdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHhtbGh0dHByZXF1ZXN0LXNzbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3htbGh0dHByZXF1ZXN0LmpzXCIpO1xuXG52YXIgUG9sbGluZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcG9sbGluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy5qc1wiKTtcblxudmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb21wb25lbnQtZW1pdHRlciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzXCIpO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdXRpbC5qc1wiKSxcbiAgICBwaWNrID0gX3JlcXVpcmUucGljaztcblxudmFyIGdsb2JhbFRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9nbG9iYWxUaGlzICovIFwiLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvZ2xvYmFsVGhpcy5icm93c2VyLmpzXCIpO1xuXG52YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkZWJ1ZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzXCIpKFwiZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nLXhoclwiKTtcbi8qKlxuICogRW1wdHkgZnVuY3Rpb25cbiAqL1xuXG5cbmZ1bmN0aW9uIGVtcHR5KCkge31cblxudmFyIGhhc1hIUjIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBYTUxIdHRwUmVxdWVzdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHhtbGh0dHByZXF1ZXN0LXNzbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3htbGh0dHByZXF1ZXN0LmpzXCIpO1xuXG4gIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qoe1xuICAgIHhkb21haW46IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gbnVsbCAhPSB4aHIucmVzcG9uc2VUeXBlO1xufSgpO1xuXG52YXIgWEhSID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUG9sbGluZykge1xuICBfaW5oZXJpdHMoWEhSLCBfUG9sbGluZyk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihYSFIpO1xuXG4gIC8qKlxuICAgKiBYSFIgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG4gIGZ1bmN0aW9uIFhIUihvcHRzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFhIUik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdmFyIGlzU1NMID0gXCJodHRwczpcIiA9PT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7IC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcblxuICAgICAgaWYgKCFwb3J0KSB7XG4gICAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy54ZCA9IHR5cGVvZiBsb2NhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvcHRzLmhvc3RuYW1lICE9PSBsb2NhdGlvbi5ob3N0bmFtZSB8fCBwb3J0ICE9PSBvcHRzLnBvcnQ7XG4gICAgICBfdGhpcy54cyA9IG9wdHMuc2VjdXJlICE9PSBpc1NTTDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogWEhSIHN1cHBvcnRzIGJpbmFyeVxuICAgICAqL1xuXG5cbiAgICB2YXIgZm9yY2VCYXNlNjQgPSBvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQ7XG4gICAgX3RoaXMuc3VwcG9ydHNCaW5hcnkgPSBoYXNYSFIyICYmICFmb3JjZUJhc2U2NDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSByZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhYSFIsIFt7XG4gICAga2V5OiBcInJlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVxdWVzdCgpIHtcbiAgICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgX2V4dGVuZHMob3B0cywge1xuICAgICAgICB4ZDogdGhpcy54ZCxcbiAgICAgICAgeHM6IHRoaXMueHNcbiAgICAgIH0sIHRoaXMub3B0cyk7XG5cbiAgICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLnVyaSgpLCBvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkb1dyaXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvV3JpdGUoZGF0YSwgZm4pIHtcbiAgICAgIHZhciByZXEgPSB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9KTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJlcS5vbihcInN1Y2Nlc3NcIiwgZm4pO1xuICAgICAgcmVxLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBzZWxmLm9uRXJyb3IoXCJ4aHIgcG9zdCBlcnJvclwiLCBlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRvUG9sbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb1BvbGwoKSB7XG4gICAgICBkZWJ1ZyhcInhociBwb2xsXCIpO1xuICAgICAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCgpO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgcmVxLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBzZWxmLm9uRGF0YShkYXRhKTtcbiAgICAgIH0pO1xuICAgICAgcmVxLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBzZWxmLm9uRXJyb3IoXCJ4aHIgcG9sbCBlcnJvclwiLCBlcnIpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnBvbGxYaHIgPSByZXE7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFhIUjtcbn0oUG9sbGluZyk7XG5cbnZhciBSZXF1ZXN0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRW1pdHRlcikge1xuICBfaW5oZXJpdHMoUmVxdWVzdCwgX0VtaXR0ZXIpO1xuXG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKFJlcXVlc3QpO1xuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuICBmdW5jdGlvbiBSZXF1ZXN0KHVyaSwgb3B0cykge1xuICAgIHZhciBfdGhpczI7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVxdWVzdCk7XG5cbiAgICBfdGhpczIgPSBfc3VwZXIyLmNhbGwodGhpcyk7XG4gICAgX3RoaXMyLm9wdHMgPSBvcHRzO1xuICAgIF90aGlzMi5tZXRob2QgPSBvcHRzLm1ldGhvZCB8fCBcIkdFVFwiO1xuICAgIF90aGlzMi51cmkgPSB1cmk7XG4gICAgX3RoaXMyLmFzeW5jID0gZmFsc2UgIT09IG9wdHMuYXN5bmM7XG4gICAgX3RoaXMyLmRhdGEgPSB1bmRlZmluZWQgIT09IG9wdHMuZGF0YSA/IG9wdHMuZGF0YSA6IG51bGw7XG5cbiAgICBfdGhpczIuY3JlYXRlKCk7XG5cbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBYSFIgb2JqZWN0IGFuZCBzZW5kcyB0aGUgcmVxdWVzdC5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFJlcXVlc3QsIFt7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICB2YXIgb3B0cyA9IHBpY2sodGhpcy5vcHRzLCBcImFnZW50XCIsIFwiZW5hYmxlc1hEUlwiLCBcInBmeFwiLCBcImtleVwiLCBcInBhc3NwaHJhc2VcIiwgXCJjZXJ0XCIsIFwiY2FcIiwgXCJjaXBoZXJzXCIsIFwicmVqZWN0VW5hdXRob3JpemVkXCIpO1xuICAgICAgb3B0cy54ZG9tYWluID0gISF0aGlzLm9wdHMueGQ7XG4gICAgICBvcHRzLnhzY2hlbWUgPSAhIXRoaXMub3B0cy54cztcbiAgICAgIHZhciB4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZGVidWcoXCJ4aHIgb3BlbiAlczogJXNcIiwgdGhpcy5tZXRob2QsIHRoaXMudXJpKTtcbiAgICAgICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJpLCB0aGlzLmFzeW5jKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdHMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgICAgICB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrICYmIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sodHJ1ZSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5vcHRzLmV4dHJhSGVhZGVycykge1xuICAgICAgICAgICAgICBpZiAodGhpcy5vcHRzLmV4dHJhSGVhZGVycy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGksIHRoaXMub3B0cy5leHRyYUhlYWRlcnNbaV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICAgIGlmIChcIlBPU1RcIiA9PT0gdGhpcy5tZXRob2QpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LXR5cGVcIiwgXCJ0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThcIik7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIiwgXCIqLypcIik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9IC8vIGllNiBjaGVja1xuXG5cbiAgICAgICAgaWYgKFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyKSB7XG4gICAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRoaXMub3B0cy53aXRoQ3JlZGVudGlhbHM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRzLnJlcXVlc3RUaW1lb3V0KSB7XG4gICAgICAgICAgeGhyLnRpbWVvdXQgPSB0aGlzLm9wdHMucmVxdWVzdFRpbWVvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oYXNYRFIoKSkge1xuICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYub25FcnJvcih4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoNCAhPT0geGhyLnJlYWR5U3RhdGUpIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKDIwMCA9PT0geGhyLnN0YXR1cyB8fCAxMjIzID09PSB4aHIuc3RhdHVzKSB7XG4gICAgICAgICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGBlcnJvcmAgZXZlbnQgaGFuZGxlciB0aGF0J3MgdXNlci1zZXRcbiAgICAgICAgICAgICAgLy8gZG9lcyBub3QgdGhyb3cgaW4gdGhlIHNhbWUgdGljayBhbmQgZ2V0cyBjYXVnaHQgaGVyZVxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9uRXJyb3IodHlwZW9mIHhoci5zdGF0dXMgPT09IFwibnVtYmVyXCIgPyB4aHIuc3RhdHVzIDogMCk7XG4gICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBkZWJ1ZyhcInhociBkYXRhICVzXCIsIHRoaXMuZGF0YSk7XG4gICAgICAgIHhoci5zZW5kKHRoaXMuZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIE5lZWQgdG8gZGVmZXIgc2luY2UgLmNyZWF0ZSgpIGlzIGNhbGxlZCBkaXJlY3RseSBmcm9tIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICAvLyBhbmQgdGh1cyB0aGUgJ2Vycm9yJyBldmVudCBjYW4gb25seSBiZSBvbmx5IGJvdW5kICphZnRlciogdGhpcyBleGNlcHRpb25cbiAgICAgICAgLy8gb2NjdXJzLiAgVGhlcmVmb3JlLCBhbHNvLCB3ZSBjYW5ub3QgdGhyb3cgaGVyZSBhdCBhbGwuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYub25FcnJvcihlKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLmluZGV4ID0gUmVxdWVzdC5yZXF1ZXN0c0NvdW50Kys7XG4gICAgICAgIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF0gPSB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblN1Y2Nlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25TdWNjZXNzKCkge1xuICAgICAgdGhpcy5lbWl0KFwic3VjY2Vzc1wiKTtcbiAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgaWYgd2UgaGF2ZSBkYXRhLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbkRhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25EYXRhKGRhdGEpIHtcbiAgICAgIHRoaXMuZW1pdChcImRhdGFcIiwgZGF0YSk7XG4gICAgICB0aGlzLm9uU3VjY2VzcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBlcnJvci5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25FcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkVycm9yKGVycikge1xuICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgIHRoaXMuY2xlYW51cCh0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIGhvdXNlLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbGVhbnVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFudXAoZnJvbUVycm9yKSB7XG4gICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIHRoaXMueGhyIHx8IG51bGwgPT09IHRoaXMueGhyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8geG1saHR0cHJlcXVlc3RcblxuXG4gICAgICBpZiAodGhpcy5oYXNYRFIoKSkge1xuICAgICAgICB0aGlzLnhoci5vbmxvYWQgPSB0aGlzLnhoci5vbmVycm9yID0gZW1wdHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlbXB0eTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZyb21FcnJvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgZGVsZXRlIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF07XG4gICAgICB9XG5cbiAgICAgIHRoaXMueGhyID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gbG9hZC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25Mb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTG9hZCgpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy54aHIucmVzcG9uc2VUZXh0O1xuXG4gICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgaXQgaGFzIFhEb21haW5SZXF1ZXN0LlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJoYXNYRFJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzWERSKCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBYRG9tYWluUmVxdWVzdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhdGhpcy54cyAmJiB0aGlzLmVuYWJsZXNYRFI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFib3J0cyB0aGUgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhYm9ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZXF1ZXN0O1xufShFbWl0dGVyKTtcbi8qKlxuICogQWJvcnRzIHBlbmRpbmcgcmVxdWVzdHMgd2hlbiB1bmxvYWRpbmcgdGhlIHdpbmRvdy4gVGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudFxuICogbWVtb3J5IGxlYWtzIChlLmcuIHdoZW4gdXNpbmcgSUUpIGFuZCB0byBlbnN1cmUgdGhhdCBubyBzcHVyaW91cyBlcnJvciBpc1xuICogZW1pdHRlZC5cbiAqL1xuXG5cblJlcXVlc3QucmVxdWVzdHNDb3VudCA9IDA7XG5SZXF1ZXN0LnJlcXVlc3RzID0ge307XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgaWYgKHR5cGVvZiBhdHRhY2hFdmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgYXR0YWNoRXZlbnQoXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIHRlcm1pbmF0aW9uRXZlbnQgPSBcIm9ucGFnZWhpZGVcIiBpbiBnbG9iYWxUaGlzID8gXCJwYWdlaGlkZVwiIDogXCJ1bmxvYWRcIjtcbiAgICBhZGRFdmVudExpc3RlbmVyKHRlcm1pbmF0aW9uRXZlbnQsIHVubG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bmxvYWRIYW5kbGVyKCkge1xuICBmb3IgKHZhciBpIGluIFJlcXVlc3QucmVxdWVzdHMpIHtcbiAgICBpZiAoUmVxdWVzdC5yZXF1ZXN0cy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgUmVxdWVzdC5yZXF1ZXN0c1tpXS5hYm9ydCgpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUjtcbm1vZHVsZS5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG52YXIgVHJhbnNwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdHJhbnNwb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0LmpzXCIpO1xuXG52YXIgcGFyc2VxcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHBhcnNlcXMgKi8gXCIuL25vZGVfbW9kdWxlcy9wYXJzZXFzL2luZGV4LmpzXCIpO1xuXG52YXIgcGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZW5naW5lLmlvLXBhcnNlciAqLyBcIi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbGliL2luZGV4LmpzXCIpO1xuXG52YXIgeWVhc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB5ZWFzdCAqLyBcIi4vbm9kZV9tb2R1bGVzL3llYXN0L2luZGV4LmpzXCIpO1xuXG52YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkZWJ1ZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzXCIpKFwiZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nXCIpO1xuXG52YXIgUG9sbGluZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RyYW5zcG9ydCkge1xuICBfaW5oZXJpdHMoUG9sbGluZywgX1RyYW5zcG9ydCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihQb2xsaW5nKTtcblxuICBmdW5jdGlvbiBQb2xsaW5nKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb2xsaW5nKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQb2xsaW5nLCBbe1xuICAgIGtleTogXCJkb09wZW5cIixcblxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSBzb2NrZXQgKHRyaWdnZXJzIHBvbGxpbmcpLiBXZSB3cml0ZSBhIFBJTkcgbWVzc2FnZSB0byBkZXRlcm1pbmVcbiAgICAgKiB3aGVuIHRoZSB0cmFuc3BvcnQgaXMgb3Blbi5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkb09wZW4oKSB7XG4gICAgICB0aGlzLnBvbGwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGF1c2VzIHBvbGxpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB1cG9uIGJ1ZmZlcnMgYXJlIGZsdXNoZWQgYW5kIHRyYW5zcG9ydCBpcyBwYXVzZWRcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhdXNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdXNlKG9uUGF1c2UpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwicGF1c2luZ1wiO1xuXG4gICAgICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgICAgZGVidWcoXCJwYXVzZWRcIik7XG4gICAgICAgIHNlbGYucmVhZHlTdGF0ZSA9IFwicGF1c2VkXCI7XG4gICAgICAgIG9uUGF1c2UoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucG9sbGluZyB8fCAhdGhpcy53cml0YWJsZSkge1xuICAgICAgICB2YXIgdG90YWwgPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLnBvbGxpbmcpIHtcbiAgICAgICAgICBkZWJ1ZyhcIndlIGFyZSBjdXJyZW50bHkgcG9sbGluZyAtIHdhaXRpbmcgdG8gcGF1c2VcIik7XG4gICAgICAgICAgdG90YWwrKztcbiAgICAgICAgICB0aGlzLm9uY2UoXCJwb2xsQ29tcGxldGVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGVidWcoXCJwcmUtcGF1c2UgcG9sbGluZyBjb21wbGV0ZVwiKTtcbiAgICAgICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy53cml0YWJsZSkge1xuICAgICAgICAgIGRlYnVnKFwid2UgYXJlIGN1cnJlbnRseSB3cml0aW5nIC0gd2FpdGluZyB0byBwYXVzZVwiKTtcbiAgICAgICAgICB0b3RhbCsrO1xuICAgICAgICAgIHRoaXMub25jZShcImRyYWluXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlYnVnKFwicHJlLXBhdXNlIHdyaXRpbmcgY29tcGxldGVcIik7XG4gICAgICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBwb2xsaW5nIGN5Y2xlLlxuICAgICAqXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBvbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9sbCgpIHtcbiAgICAgIGRlYnVnKFwicG9sbGluZ1wiKTtcbiAgICAgIHRoaXMucG9sbGluZyA9IHRydWU7XG4gICAgICB0aGlzLmRvUG9sbCgpO1xuICAgICAgdGhpcy5lbWl0KFwicG9sbFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcmxvYWRzIG9uRGF0YSB0byBkZXRlY3QgcGF5bG9hZHMuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRhdGEoZGF0YSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgZGVidWcoXCJwb2xsaW5nIGdvdCBkYXRhICVzXCIsIGRhdGEpO1xuXG4gICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjayhwYWNrZXQsIGluZGV4LCB0b3RhbCkge1xuICAgICAgICAvLyBpZiBpdHMgdGhlIGZpcnN0IG1lc3NhZ2Ugd2UgY29uc2lkZXIgdGhlIHRyYW5zcG9ydCBvcGVuXG4gICAgICAgIGlmIChcIm9wZW5pbmdcIiA9PT0gc2VsZi5yZWFkeVN0YXRlICYmIHBhY2tldC50eXBlID09PSBcIm9wZW5cIikge1xuICAgICAgICAgIHNlbGYub25PcGVuKCk7XG4gICAgICAgIH0gLy8gaWYgaXRzIGEgY2xvc2UgcGFja2V0LCB3ZSBjbG9zZSB0aGUgb25nb2luZyByZXF1ZXN0c1xuXG5cbiAgICAgICAgaWYgKFwiY2xvc2VcIiA9PT0gcGFja2V0LnR5cGUpIHtcbiAgICAgICAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gLy8gb3RoZXJ3aXNlIGJ5cGFzcyBvbkRhdGEgYW5kIGhhbmRsZSB0aGUgbWVzc2FnZVxuXG5cbiAgICAgICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuICAgICAgfTsgLy8gZGVjb2RlIHBheWxvYWRcblxuXG4gICAgICBwYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlKS5mb3JFYWNoKGNhbGxiYWNrKTsgLy8gaWYgYW4gZXZlbnQgZGlkIG5vdCB0cmlnZ2VyIGNsb3NpbmdcblxuICAgICAgaWYgKFwiY2xvc2VkXCIgIT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICAvLyBpZiB3ZSBnb3QgZGF0YSB3ZSdyZSBub3QgcG9sbGluZ1xuICAgICAgICB0aGlzLnBvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0KFwicG9sbENvbXBsZXRlXCIpO1xuXG4gICAgICAgIGlmIChcIm9wZW5cIiA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoJ2lnbm9yaW5nIHBvbGwgLSB0cmFuc3BvcnQgc3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3IgcG9sbGluZywgc2VuZCBhIGNsb3NlIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZG9DbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb0Nsb3NlKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgZGVidWcoXCJ3cml0aW5nIGNsb3NlIHBhY2tldFwiKTtcbiAgICAgICAgc2VsZi53cml0ZShbe1xuICAgICAgICAgIHR5cGU6IFwiY2xvc2VcIlxuICAgICAgICB9XSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChcIm9wZW5cIiA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IG9wZW4gLSBjbG9zaW5nXCIpO1xuICAgICAgICBjbG9zZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaW4gY2FzZSB3ZSdyZSB0cnlpbmcgdG8gY2xvc2Ugd2hpbGVcbiAgICAgICAgLy8gaGFuZHNoYWtpbmcgaXMgaW4gcHJvZ3Jlc3MgKEdILTE2NClcbiAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgbm90IG9wZW4gLSBkZWZlcnJpbmcgY2xvc2VcIik7XG4gICAgICAgIHRoaXMub25jZShcIm9wZW5cIiwgY2xvc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBwYWNrZXRzIHBheWxvYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIHBhY2tldHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmFpbiBjYWxsYmFja1xuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid3JpdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGUocGFja2V0cykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgcGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgX3RoaXMuZG9Xcml0ZShkYXRhLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gICAgICAgICAgX3RoaXMuZW1pdChcImRyYWluXCIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdXJpIGZvciBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cmlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXJpKCkge1xuICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgICAgIHZhciBzY2hlbWEgPSB0aGlzLm9wdHMuc2VjdXJlID8gXCJodHRwc1wiIDogXCJodHRwXCI7XG4gICAgICB2YXIgcG9ydCA9IFwiXCI7IC8vIGNhY2hlIGJ1c3RpbmcgaXMgZm9yY2VkXG5cbiAgICAgIGlmIChmYWxzZSAhPT0gdGhpcy5vcHRzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgICAgIHF1ZXJ5W3RoaXMub3B0cy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgIXF1ZXJ5LnNpZCkge1xuICAgICAgICBxdWVyeS5iNjQgPSAxO1xuICAgICAgfVxuXG4gICAgICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTsgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcblxuICAgICAgaWYgKHRoaXMub3B0cy5wb3J0ICYmIChcImh0dHBzXCIgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5vcHRzLnBvcnQpICE9PSA0NDMgfHwgXCJodHRwXCIgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5vcHRzLnBvcnQpICE9PSA4MCkpIHtcbiAgICAgICAgcG9ydCA9IFwiOlwiICsgdGhpcy5vcHRzLnBvcnQ7XG4gICAgICB9IC8vIHByZXBlbmQgPyB0byBxdWVyeVxuXG5cbiAgICAgIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICAgICAgcXVlcnkgPSBcIj9cIiArIHF1ZXJ5O1xuICAgICAgfVxuXG4gICAgICB2YXIgaXB2NiA9IHRoaXMub3B0cy5ob3N0bmFtZS5pbmRleE9mKFwiOlwiKSAhPT0gLTE7XG4gICAgICByZXR1cm4gc2NoZW1hICsgXCI6Ly9cIiArIChpcHY2ID8gXCJbXCIgKyB0aGlzLm9wdHMuaG9zdG5hbWUgKyBcIl1cIiA6IHRoaXMub3B0cy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5vcHRzLnBhdGggKyBxdWVyeTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmFtZVwiLFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNwb3J0IG5hbWUuXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gXCJwb2xsaW5nXCI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBvbGxpbmc7XG59KFRyYW5zcG9ydCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy93ZWJzb2NrZXQtY29uc3RydWN0b3IuYnJvd3Nlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvd2Vic29ja2V0LWNvbnN0cnVjdG9yLmJyb3dzZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2dsb2JhbFRoaXMgKi8gXCIuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi9nbG9iYWxUaGlzLmJyb3dzZXIuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJTb2NrZXQ6IGdsb2JhbFRoaXMuV2ViU29ja2V0IHx8IGdsb2JhbFRoaXMuTW96V2ViU29ja2V0LFxuICB1c2luZ0Jyb3dzZXJXZWJTb2NrZXQ6IHRydWUsXG4gIGRlZmF1bHRCaW5hcnlUeXBlOiBcImFycmF5YnVmZmVyXCJcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvd2Vic29ja2V0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvd2Vic29ja2V0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxudmFyIFRyYW5zcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3RyYW5zcG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydC5qc1wiKTtcblxudmFyIHBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGVuZ2luZS5pby1wYXJzZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9pbmRleC5qc1wiKTtcblxudmFyIHBhcnNlcXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBwYXJzZXFzICovIFwiLi9ub2RlX21vZHVsZXMvcGFyc2Vxcy9pbmRleC5qc1wiKTtcblxudmFyIHllYXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgeWVhc3QgKi8gXCIuL25vZGVfbW9kdWxlcy95ZWFzdC9pbmRleC5qc1wiKTtcblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3V0aWwuanNcIiksXG4gICAgcGljayA9IF9yZXF1aXJlLnBpY2s7XG5cbnZhciBfcmVxdWlyZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3dlYnNvY2tldC1jb25zdHJ1Y3RvciAqLyBcIi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvd2Vic29ja2V0LWNvbnN0cnVjdG9yLmJyb3dzZXIuanNcIiksXG4gICAgV2ViU29ja2V0ID0gX3JlcXVpcmUyLldlYlNvY2tldCxcbiAgICB1c2luZ0Jyb3dzZXJXZWJTb2NrZXQgPSBfcmVxdWlyZTIudXNpbmdCcm93c2VyV2ViU29ja2V0LFxuICAgIGRlZmF1bHRCaW5hcnlUeXBlID0gX3JlcXVpcmUyLmRlZmF1bHRCaW5hcnlUeXBlO1xuXG52YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkZWJ1ZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzXCIpKFwiZW5naW5lLmlvLWNsaWVudDp3ZWJzb2NrZXRcIik7IC8vIGRldGVjdCBSZWFjdE5hdGl2ZSBlbnZpcm9ubWVudFxuXG5cbnZhciBpc1JlYWN0TmF0aXZlID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgbmF2aWdhdG9yLnByb2R1Y3QgPT09IFwic3RyaW5nXCIgJiYgbmF2aWdhdG9yLnByb2R1Y3QudG9Mb3dlckNhc2UoKSA9PT0gXCJyZWFjdG5hdGl2ZVwiO1xuXG52YXIgV1MgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UcmFuc3BvcnQpIHtcbiAgX2luaGVyaXRzKFdTLCBfVHJhbnNwb3J0KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFdTKTtcblxuICAvKipcbiAgICogV2ViU29ja2V0IHRyYW5zcG9ydCBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQGFwaSB7T2JqZWN0fSBjb25uZWN0aW9uIG9wdGlvbnNcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG4gIGZ1bmN0aW9uIFdTKG9wdHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV1MpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICBfdGhpcy5zdXBwb3J0c0JpbmFyeSA9ICFvcHRzLmZvcmNlQmFzZTY0O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogVHJhbnNwb3J0IG5hbWUuXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFdTLCBbe1xuICAgIGtleTogXCJkb09wZW5cIixcblxuICAgIC8qKlxuICAgICAqIE9wZW5zIHNvY2tldC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkb09wZW4oKSB7XG4gICAgICBpZiAoIXRoaXMuY2hlY2soKSkge1xuICAgICAgICAvLyBsZXQgcHJvYmUgdGltZW91dFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB1cmkgPSB0aGlzLnVyaSgpO1xuICAgICAgdmFyIHByb3RvY29scyA9IHRoaXMub3B0cy5wcm90b2NvbHM7IC8vIFJlYWN0IE5hdGl2ZSBvbmx5IHN1cHBvcnRzIHRoZSAnaGVhZGVycycgb3B0aW9uLCBhbmQgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgYW55dGhpbmcgZWxzZSBpcyBwYXNzZWRcblxuICAgICAgdmFyIG9wdHMgPSBpc1JlYWN0TmF0aXZlID8ge30gOiBwaWNrKHRoaXMub3B0cywgXCJhZ2VudFwiLCBcInBlck1lc3NhZ2VEZWZsYXRlXCIsIFwicGZ4XCIsIFwia2V5XCIsIFwicGFzc3BocmFzZVwiLCBcImNlcnRcIiwgXCJjYVwiLCBcImNpcGhlcnNcIiwgXCJyZWplY3RVbmF1dGhvcml6ZWRcIiwgXCJsb2NhbEFkZHJlc3NcIik7XG5cbiAgICAgIGlmICh0aGlzLm9wdHMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgIG9wdHMuaGVhZGVycyA9IHRoaXMub3B0cy5leHRyYUhlYWRlcnM7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMud3MgPSB1c2luZ0Jyb3dzZXJXZWJTb2NrZXQgJiYgIWlzUmVhY3ROYXRpdmUgPyBwcm90b2NvbHMgPyBuZXcgV2ViU29ja2V0KHVyaSwgcHJvdG9jb2xzKSA6IG5ldyBXZWJTb2NrZXQodXJpKSA6IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSB0aGlzLnNvY2tldC5iaW5hcnlUeXBlIHx8IGRlZmF1bHRCaW5hcnlUeXBlO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc29ja2V0XG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZEV2ZW50TGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICB0aGlzLndzLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5vbk9wZW4oKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMud3Mub25jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5vbkNsb3NlKCk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICBzZWxmLm9uRGF0YShldi5kYXRhKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHNlbGYub25FcnJvcihcIndlYnNvY2tldCBlcnJvclwiLCBlKTtcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBkYXRhIHRvIHNvY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IG9mIHBhY2tldHMuXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3cml0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3cml0ZShwYWNrZXRzKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7IC8vIGVuY29kZVBhY2tldCBlZmZpY2llbnQgYXMgaXQgdXNlcyBXUyBmcmFtaW5nXG4gICAgICAvLyBubyBuZWVkIGZvciBlbmNvZGVQYXlsb2FkXG5cbiAgICAgIHZhciB0b3RhbCA9IHBhY2tldHMubGVuZ3RoO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGwgPSB0b3RhbDtcblxuICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgKGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgICAgICAgICBwYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldCwgc2VsZi5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIC8vIGFsd2F5cyBjcmVhdGUgYSBuZXcgb2JqZWN0IChHSC00MzcpXG4gICAgICAgICAgICB2YXIgb3B0cyA9IHt9O1xuXG4gICAgICAgICAgICBpZiAoIXVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgICAgICBpZiAocGFja2V0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gcGFja2V0Lm9wdGlvbnMuY29tcHJlc3M7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoc2VsZi5vcHRzLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IFwic3RyaW5nXCIgPT09IHR5cGVvZiBkYXRhID8gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgOiBkYXRhLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGlmIChsZW4gPCBzZWxmLm9wdHMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIFNvbWV0aW1lcyB0aGUgd2Vic29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ1dCB0aGUgYnJvd3NlciBkaWRuJ3RcbiAgICAgICAgICAgIC8vIGhhdmUgYSBjaGFuY2Ugb2YgaW5mb3JtaW5nIHVzIGFib3V0IGl0IHlldCwgaW4gdGhhdCBjYXNlIHNlbmQgd2lsbFxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3JcblxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAodXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gVHlwZUVycm9yIGlzIHRocm93biB3aGVuIHBhc3NpbmcgdGhlIHNlY29uZCBhcmd1bWVudCBvbiBTYWZhcmlcbiAgICAgICAgICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEsIG9wdHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGRlYnVnKFwid2Vic29ja2V0IGNsb3NlZCBiZWZvcmUgb25jbG9zZSBldmVudFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLS10b3RhbCB8fCBkb25lKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKHBhY2tldHNbaV0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgICBzZWxmLmVtaXQoXCJmbHVzaFwiKTsgLy8gZmFrZSBkcmFpblxuICAgICAgICAvLyBkZWZlciB0byBuZXh0IHRpY2sgdG8gYWxsb3cgU29ja2V0IHRvIGNsZWFyIHdyaXRlQnVmZmVyXG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgc2VsZi5lbWl0KFwiZHJhaW5cIik7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBjbG9zZVxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbkNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2xvc2UoKSB7XG4gICAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHNvY2tldC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZG9DbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb0Nsb3NlKCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLndzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXJpXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVyaSgpIHtcbiAgICAgIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gICAgICB2YXIgc2NoZW1hID0gdGhpcy5vcHRzLnNlY3VyZSA/IFwid3NzXCIgOiBcIndzXCI7XG4gICAgICB2YXIgcG9ydCA9IFwiXCI7IC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG5cbiAgICAgIGlmICh0aGlzLm9wdHMucG9ydCAmJiAoXCJ3c3NcIiA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLm9wdHMucG9ydCkgIT09IDQ0MyB8fCBcIndzXCIgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5vcHRzLnBvcnQpICE9PSA4MCkpIHtcbiAgICAgICAgcG9ydCA9IFwiOlwiICsgdGhpcy5vcHRzLnBvcnQ7XG4gICAgICB9IC8vIGFwcGVuZCB0aW1lc3RhbXAgdG8gVVJJXG5cblxuICAgICAgaWYgKHRoaXMub3B0cy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgICAgICBxdWVyeVt0aGlzLm9wdHMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcbiAgICAgIH0gLy8gY29tbXVuaWNhdGUgYmluYXJ5IHN1cHBvcnQgY2FwYWJpbGl0aWVzXG5cblxuICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAgIHF1ZXJ5LmI2NCA9IDE7XG4gICAgICB9XG5cbiAgICAgIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpOyAvLyBwcmVwZW5kID8gdG8gcXVlcnlcblxuICAgICAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgICAgICBxdWVyeSA9IFwiP1wiICsgcXVlcnk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpcHY2ID0gdGhpcy5vcHRzLmhvc3RuYW1lLmluZGV4T2YoXCI6XCIpICE9PSAtMTtcbiAgICAgIHJldHVybiBzY2hlbWEgKyBcIjovL1wiICsgKGlwdjYgPyBcIltcIiArIHRoaXMub3B0cy5ob3N0bmFtZSArIFwiXVwiIDogdGhpcy5vcHRzLmhvc3RuYW1lKSArIHBvcnQgKyB0aGlzLm9wdHMucGF0aCArIHF1ZXJ5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZWF0dXJlIGRldGVjdGlvbiBmb3IgV2ViU29ja2V0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciB0aGlzIHRyYW5zcG9ydCBpcyBhdmFpbGFibGUuXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrKCkge1xuICAgICAgcmV0dXJuICEhV2ViU29ja2V0ICYmICEoXCJfX2luaXRpYWxpemVcIiBpbiBXZWJTb2NrZXQgJiYgdGhpcy5uYW1lID09PSBXUy5wcm90b3R5cGUubmFtZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5hbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBcIndlYnNvY2tldFwiO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBXUztcbn0oVHJhbnNwb3J0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBXUztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdXRpbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3V0aWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cy5waWNrID0gZnVuY3Rpb24gKG9iaikge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXR0ciA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXR0cltfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gYXR0ci5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgaykge1xuICAgIGFjY1trXSA9IG9ialtrXTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi94bWxodHRwcmVxdWVzdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi94bWxodHRwcmVxdWVzdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBicm93c2VyIHNoaW0gZm9yIHhtbGh0dHByZXF1ZXN0IG1vZHVsZVxudmFyIGhhc0NPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBoYXMtY29ycyAqLyBcIi4vbm9kZV9tb2R1bGVzL2hhcy1jb3JzL2luZGV4LmpzXCIpO1xuXG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2xvYmFsVGhpcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL2dsb2JhbFRoaXMuYnJvd3Nlci5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgeGRvbWFpbiA9IG9wdHMueGRvbWFpbjsgLy8gc2NoZW1lIG11c3QgYmUgc2FtZSB3aGVuIHVzaWduIFhEb21haW5SZXF1ZXN0XG4gIC8vIGh0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llaW50ZXJuYWxzL2FyY2hpdmUvMjAxMC8wNS8xMy94ZG9tYWlucmVxdWVzdC1yZXN0cmljdGlvbnMtbGltaXRhdGlvbnMtYW5kLXdvcmthcm91bmRzLmFzcHhcblxuICB2YXIgeHNjaGVtZSA9IG9wdHMueHNjaGVtZTsgLy8gWERvbWFpblJlcXVlc3QgaGFzIGEgZmxvdyBvZiBub3Qgc2VuZGluZyBjb29raWUsIHRoZXJlZm9yZSBpdCBzaG91bGQgYmUgZGlzYWJsZWQgYXMgYSBkZWZhdWx0LlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9lbmdpbmUuaW8tY2xpZW50L3B1bGwvMjE3XG5cbiAgdmFyIGVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7IC8vIFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBvbiBJRVxuXG4gIHRyeSB7XG4gICAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAmJiAoIXhkb21haW4gfHwgaGFzQ09SUykpIHtcbiAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHt9IC8vIFVzZSBYRG9tYWluUmVxdWVzdCBmb3IgSUU4IGlmIGVuYWJsZXNYRFIgaXMgdHJ1ZVxuICAvLyBiZWNhdXNlIGxvYWRpbmcgYmFyIGtlZXBzIGZsYXNoaW5nIHdoZW4gdXNpbmcganNvbnAtcG9sbGluZ1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20veXVqaW9zYWthL3NvY2tlLmlvLWllOC1sb2FkaW5nLWV4YW1wbGVcblxuXG4gIHRyeSB7XG4gICAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBYRG9tYWluUmVxdWVzdCAmJiAheHNjaGVtZSAmJiBlbmFibGVzWERSKSB7XG4gICAgICByZXR1cm4gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7fVxuXG4gIGlmICgheGRvbWFpbikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IGdsb2JhbFRoaXNbW1wiQWN0aXZlXCJdLmNvbmNhdChcIk9iamVjdFwiKS5qb2luKFwiWFwiKV0oXCJNaWNyb3NvZnQuWE1MSFRUUFwiKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9jb21tb25zLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIvY29tbW9ucy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBQQUNLRVRfVFlQRVMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyAvLyBubyBNYXAgPSBubyBwb2x5ZmlsbFxuXG5QQUNLRVRfVFlQRVNbXCJvcGVuXCJdID0gXCIwXCI7XG5QQUNLRVRfVFlQRVNbXCJjbG9zZVwiXSA9IFwiMVwiO1xuUEFDS0VUX1RZUEVTW1wicGluZ1wiXSA9IFwiMlwiO1xuUEFDS0VUX1RZUEVTW1wicG9uZ1wiXSA9IFwiM1wiO1xuUEFDS0VUX1RZUEVTW1wibWVzc2FnZVwiXSA9IFwiNFwiO1xuUEFDS0VUX1RZUEVTW1widXBncmFkZVwiXSA9IFwiNVwiO1xuUEFDS0VUX1RZUEVTW1wibm9vcFwiXSA9IFwiNlwiO1xudmFyIFBBQ0tFVF9UWVBFU19SRVZFUlNFID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbk9iamVjdC5rZXlzKFBBQ0tFVF9UWVBFUykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFBBQ0tFVF9UWVBFU19SRVZFUlNFW1BBQ0tFVF9UWVBFU1trZXldXSA9IGtleTtcbn0pO1xudmFyIEVSUk9SX1BBQ0tFVCA9IHtcbiAgdHlwZTogXCJlcnJvclwiLFxuICBkYXRhOiBcInBhcnNlciBlcnJvclwiXG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFBBQ0tFVF9UWVBFUzogUEFDS0VUX1RZUEVTLFxuICBQQUNLRVRfVFlQRVNfUkVWRVJTRTogUEFDS0VUX1RZUEVTX1JFVkVSU0UsXG4gIEVSUk9SX1BBQ0tFVDogRVJST1JfUEFDS0VUXG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9kZWNvZGVQYWNrZXQuYnJvd3Nlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9kZWNvZGVQYWNrZXQuYnJvd3Nlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbW1vbnMgKi8gXCIuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9jb21tb25zLmpzXCIpLFxuICAgIFBBQ0tFVF9UWVBFU19SRVZFUlNFID0gX3JlcXVpcmUuUEFDS0VUX1RZUEVTX1JFVkVSU0UsXG4gICAgRVJST1JfUEFDS0VUID0gX3JlcXVpcmUuRVJST1JfUEFDS0VUO1xuXG52YXIgd2l0aE5hdGl2ZUFycmF5QnVmZmVyID0gdHlwZW9mIEFycmF5QnVmZmVyID09PSBcImZ1bmN0aW9uXCI7XG52YXIgYmFzZTY0ZGVjb2RlcjtcblxuaWYgKHdpdGhOYXRpdmVBcnJheUJ1ZmZlcikge1xuICBiYXNlNjRkZWNvZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgYmFzZTY0LWFycmF5YnVmZmVyICovIFwiLi9ub2RlX21vZHVsZXMvYmFzZTY0LWFycmF5YnVmZmVyL2xpYi9iYXNlNjQtYXJyYXlidWZmZXIuanNcIik7XG59XG5cbnZhciBkZWNvZGVQYWNrZXQgPSBmdW5jdGlvbiBkZWNvZGVQYWNrZXQoZW5jb2RlZFBhY2tldCwgYmluYXJ5VHlwZSkge1xuICBpZiAodHlwZW9mIGVuY29kZWRQYWNrZXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJtZXNzYWdlXCIsXG4gICAgICBkYXRhOiBtYXBCaW5hcnkoZW5jb2RlZFBhY2tldCwgYmluYXJ5VHlwZSlcbiAgICB9O1xuICB9XG5cbiAgdmFyIHR5cGUgPSBlbmNvZGVkUGFja2V0LmNoYXJBdCgwKTtcblxuICBpZiAodHlwZSA9PT0gXCJiXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJtZXNzYWdlXCIsXG4gICAgICBkYXRhOiBkZWNvZGVCYXNlNjRQYWNrZXQoZW5jb2RlZFBhY2tldC5zdWJzdHJpbmcoMSksIGJpbmFyeVR5cGUpXG4gICAgfTtcbiAgfVxuXG4gIHZhciBwYWNrZXRUeXBlID0gUEFDS0VUX1RZUEVTX1JFVkVSU0VbdHlwZV07XG5cbiAgaWYgKCFwYWNrZXRUeXBlKSB7XG4gICAgcmV0dXJuIEVSUk9SX1BBQ0tFVDtcbiAgfVxuXG4gIHJldHVybiBlbmNvZGVkUGFja2V0Lmxlbmd0aCA+IDEgPyB7XG4gICAgdHlwZTogUEFDS0VUX1RZUEVTX1JFVkVSU0VbdHlwZV0sXG4gICAgZGF0YTogZW5jb2RlZFBhY2tldC5zdWJzdHJpbmcoMSlcbiAgfSA6IHtcbiAgICB0eXBlOiBQQUNLRVRfVFlQRVNfUkVWRVJTRVt0eXBlXVxuICB9O1xufTtcblxudmFyIGRlY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uIGRlY29kZUJhc2U2NFBhY2tldChkYXRhLCBiaW5hcnlUeXBlKSB7XG4gIGlmIChiYXNlNjRkZWNvZGVyKSB7XG4gICAgdmFyIGRlY29kZWQgPSBiYXNlNjRkZWNvZGVyLmRlY29kZShkYXRhKTtcbiAgICByZXR1cm4gbWFwQmluYXJ5KGRlY29kZWQsIGJpbmFyeVR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBiYXNlNjQ6IHRydWUsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfTsgLy8gZmFsbGJhY2sgZm9yIG9sZCBicm93c2Vyc1xuICB9XG59O1xuXG52YXIgbWFwQmluYXJ5ID0gZnVuY3Rpb24gbWFwQmluYXJ5KGRhdGEsIGJpbmFyeVR5cGUpIHtcbiAgc3dpdGNoIChiaW5hcnlUeXBlKSB7XG4gICAgY2FzZSBcImJsb2JcIjpcbiAgICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBuZXcgQmxvYihbZGF0YV0pIDogZGF0YTtcblxuICAgIGNhc2UgXCJhcnJheWJ1ZmZlclwiOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICAvLyBhc3N1bWluZyB0aGUgZGF0YSBpcyBhbHJlYWR5IGFuIEFycmF5QnVmZmVyXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZGVjb2RlUGFja2V0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9lbmNvZGVQYWNrZXQuYnJvd3Nlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9lbmNvZGVQYWNrZXQuYnJvd3Nlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbW1vbnMgKi8gXCIuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9jb21tb25zLmpzXCIpLFxuICAgIFBBQ0tFVF9UWVBFUyA9IF9yZXF1aXJlLlBBQ0tFVF9UWVBFUztcblxudmFyIHdpdGhOYXRpdmVCbG9iID0gdHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgQmxvYiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoQmxvYikgPT09IFwiW29iamVjdCBCbG9iQ29uc3RydWN0b3JdXCI7XG52YXIgd2l0aE5hdGl2ZUFycmF5QnVmZmVyID0gdHlwZW9mIEFycmF5QnVmZmVyID09PSBcImZ1bmN0aW9uXCI7IC8vIEFycmF5QnVmZmVyLmlzVmlldyBtZXRob2QgaXMgbm90IGRlZmluZWQgaW4gSUUxMFxuXG52YXIgaXNWaWV3ID0gZnVuY3Rpb24gaXNWaWV3KG9iaikge1xuICByZXR1cm4gdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gXCJmdW5jdGlvblwiID8gQXJyYXlCdWZmZXIuaXNWaWV3KG9iaikgOiBvYmogJiYgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufTtcblxudmFyIGVuY29kZVBhY2tldCA9IGZ1bmN0aW9uIGVuY29kZVBhY2tldChfcmVmLCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgdmFyIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICBkYXRhID0gX3JlZi5kYXRhO1xuXG4gIGlmICh3aXRoTmF0aXZlQmxvYiAmJiBkYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgIGlmIChzdXBwb3J0c0JpbmFyeSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZW5jb2RlQmxvYkFzQmFzZTY0KGRhdGEsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAod2l0aE5hdGl2ZUFycmF5QnVmZmVyICYmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgaXNWaWV3KGRhdGEpKSkge1xuICAgIGlmIChzdXBwb3J0c0JpbmFyeSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IGRhdGEgOiBkYXRhLmJ1ZmZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbmNvZGVCbG9iQXNCYXNlNjQobmV3IEJsb2IoW2RhdGFdKSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfSAvLyBwbGFpbiBzdHJpbmdcblxuXG4gIHJldHVybiBjYWxsYmFjayhQQUNLRVRfVFlQRVNbdHlwZV0gKyAoZGF0YSB8fCBcIlwiKSk7XG59O1xuXG52YXIgZW5jb2RlQmxvYkFzQmFzZTY0ID0gZnVuY3Rpb24gZW5jb2RlQmxvYkFzQmFzZTY0KGRhdGEsIGNhbGxiYWNrKSB7XG4gIHZhciBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udGVudCA9IGZpbGVSZWFkZXIucmVzdWx0LnNwbGl0KFwiLFwiKVsxXTtcbiAgICBjYWxsYmFjayhcImJcIiArIGNvbnRlbnQpO1xuICB9O1xuXG4gIHJldHVybiBmaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwoZGF0YSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVuY29kZVBhY2tldDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGVuY29kZVBhY2tldCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZW5jb2RlUGFja2V0ICovIFwiLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIvZW5jb2RlUGFja2V0LmJyb3dzZXIuanNcIik7XG5cbnZhciBkZWNvZGVQYWNrZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RlY29kZVBhY2tldCAqLyBcIi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbGliL2RlY29kZVBhY2tldC5icm93c2VyLmpzXCIpO1xuXG52YXIgU0VQQVJBVE9SID0gU3RyaW5nLmZyb21DaGFyQ29kZSgzMCk7IC8vIHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EZWxpbWl0ZXIjQVNDSUlfZGVsaW1pdGVkX3RleHRcblxudmFyIGVuY29kZVBheWxvYWQgPSBmdW5jdGlvbiBlbmNvZGVQYXlsb2FkKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIC8vIHNvbWUgcGFja2V0cyBtYXkgYmUgYWRkZWQgdG8gdGhlIGFycmF5IHdoaWxlIGVuY29kaW5nLCBzbyB0aGUgaW5pdGlhbCBsZW5ndGggbXVzdCBiZSBzYXZlZFxuICB2YXIgbGVuZ3RoID0gcGFja2V0cy5sZW5ndGg7XG4gIHZhciBlbmNvZGVkUGFja2V0cyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICB2YXIgY291bnQgPSAwO1xuICBwYWNrZXRzLmZvckVhY2goZnVuY3Rpb24gKHBhY2tldCwgaSkge1xuICAgIC8vIGZvcmNlIGJhc2U2NCBlbmNvZGluZyBmb3IgYmluYXJ5IHBhY2tldHNcbiAgICBlbmNvZGVQYWNrZXQocGFja2V0LCBmYWxzZSwgZnVuY3Rpb24gKGVuY29kZWRQYWNrZXQpIHtcbiAgICAgIGVuY29kZWRQYWNrZXRzW2ldID0gZW5jb2RlZFBhY2tldDtcblxuICAgICAgaWYgKCsrY291bnQgPT09IGxlbmd0aCkge1xuICAgICAgICBjYWxsYmFjayhlbmNvZGVkUGFja2V0cy5qb2luKFNFUEFSQVRPUikpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG5cbnZhciBkZWNvZGVQYXlsb2FkID0gZnVuY3Rpb24gZGVjb2RlUGF5bG9hZChlbmNvZGVkUGF5bG9hZCwgYmluYXJ5VHlwZSkge1xuICB2YXIgZW5jb2RlZFBhY2tldHMgPSBlbmNvZGVkUGF5bG9hZC5zcGxpdChTRVBBUkFUT1IpO1xuICB2YXIgcGFja2V0cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVjb2RlZFBhY2tldCA9IGRlY29kZVBhY2tldChlbmNvZGVkUGFja2V0c1tpXSwgYmluYXJ5VHlwZSk7XG4gICAgcGFja2V0cy5wdXNoKGRlY29kZWRQYWNrZXQpO1xuXG4gICAgaWYgKGRlY29kZWRQYWNrZXQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFja2V0cztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwcm90b2NvbDogNCxcbiAgZW5jb2RlUGFja2V0OiBlbmNvZGVQYWNrZXQsXG4gIGVuY29kZVBheWxvYWQ6IGVuY29kZVBheWxvYWQsXG4gIGRlY29kZVBhY2tldDogZGVjb2RlUGFja2V0LFxuICBkZWNvZGVQYXlsb2FkOiBkZWNvZGVQYXlsb2FkXG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9oYXMtY29ycy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9oYXMtY29ycy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICpcbiAqIExvZ2ljIGJvcnJvd2VkIGZyb20gTW9kZXJuaXpyOlxuICpcbiAqICAgLSBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvY29ycy5qc1xuICovXG50cnkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG59IGNhdGNoIChlcnIpIHtcbiAgLy8gaWYgWE1MSHR0cCBzdXBwb3J0IGlzIGRpc2FibGVkIGluIElFIHRoZW4gaXQgd2lsbCB0aHJvd1xuICAvLyB3aGVuIHRyeWluZyB0byBjcmVhdGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG4vKipcbiAqIEhlbHBlcnMuXG4gKi9cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHR5cGUgPSBfdHlwZW9mKHZhbCk7XG5cbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgIHJldHVybiBvcHRpb25zW1wibG9uZ1wiXSA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArIEpTT04uc3RyaW5naWZ5KHZhbCkpO1xufTtcbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuXG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKHN0cik7XG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuXG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuXG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcblxuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcblxuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcblxuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcblxuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuXG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuXG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuXG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuXG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuXG4gIHJldHVybiBtcyArICdtcyc7XG59XG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcblxuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cblxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG5cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG5cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG5cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcGFyc2Vxcy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3BhcnNlcXMvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIENvbXBpbGVzIGEgcXVlcnlzdHJpbmdcbiAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHN0ciA9ICcnO1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgaWYgKHN0ci5sZW5ndGgpIHN0ciArPSAnJic7XG4gICAgICBzdHIgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG4vKipcbiAqIFBhcnNlcyBhIHNpbXBsZSBxdWVyeXN0cmluZyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChxcykge1xuICB2YXIgcXJ5ID0ge307XG4gIHZhciBwYWlycyA9IHFzLnNwbGl0KCcmJyk7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYWlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XG4gICAgcXJ5W2RlY29kZVVSSUNvbXBvbmVudChwYWlyWzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSk7XG4gIH1cblxuICByZXR1cm4gcXJ5O1xufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcGFyc2V1cmkvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcGFyc2V1cmkvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBQYXJzZXMgYW4gVVJJXG4gKlxuICogQGF1dGhvciBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT4gKE1JVCBsaWNlbnNlKVxuICogQGFwaSBwcml2YXRlXG4gKi9cbnZhciByZSA9IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKGh0dHB8aHR0cHN8d3N8d3NzKTpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xudmFyIHBhcnRzID0gWydzb3VyY2UnLCAncHJvdG9jb2wnLCAnYXV0aG9yaXR5JywgJ3VzZXJJbmZvJywgJ3VzZXInLCAncGFzc3dvcmQnLCAnaG9zdCcsICdwb3J0JywgJ3JlbGF0aXZlJywgJ3BhdGgnLCAnZGlyZWN0b3J5JywgJ2ZpbGUnLCAncXVlcnknLCAnYW5jaG9yJ107XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2V1cmkoc3RyKSB7XG4gIHZhciBzcmMgPSBzdHIsXG4gICAgICBiID0gc3RyLmluZGV4T2YoJ1snKSxcbiAgICAgIGUgPSBzdHIuaW5kZXhPZignXScpO1xuXG4gIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGIpICsgc3RyLnN1YnN0cmluZyhiLCBlKS5yZXBsYWNlKC86L2csICc7JykgKyBzdHIuc3Vic3RyaW5nKGUsIHN0ci5sZW5ndGgpO1xuICB9XG5cbiAgdmFyIG0gPSByZS5leGVjKHN0ciB8fCAnJyksXG4gICAgICB1cmkgPSB7fSxcbiAgICAgIGkgPSAxNDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgdXJpW3BhcnRzW2ldXSA9IG1baV0gfHwgJyc7XG4gIH1cblxuICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XG4gICAgdXJpLnNvdXJjZSA9IHNyYztcbiAgICB1cmkuaG9zdCA9IHVyaS5ob3N0LnN1YnN0cmluZygxLCB1cmkuaG9zdC5sZW5ndGggLSAxKS5yZXBsYWNlKC87L2csICc6Jyk7XG4gICAgdXJpLmF1dGhvcml0eSA9IHVyaS5hdXRob3JpdHkucmVwbGFjZSgnWycsICcnKS5yZXBsYWNlKCddJywgJycpLnJlcGxhY2UoLzsvZywgJzonKTtcbiAgICB1cmkuaXB2NnVyaSA9IHRydWU7XG4gIH1cblxuICB1cmkucGF0aE5hbWVzID0gcGF0aE5hbWVzKHVyaSwgdXJpWydwYXRoJ10pO1xuICB1cmkucXVlcnlLZXkgPSBxdWVyeUtleSh1cmksIHVyaVsncXVlcnknXSk7XG4gIHJldHVybiB1cmk7XG59O1xuXG5mdW5jdGlvbiBwYXRoTmFtZXMob2JqLCBwYXRoKSB7XG4gIHZhciByZWd4ID0gL1xcL3syLDl9L2csXG4gICAgICBuYW1lcyA9IHBhdGgucmVwbGFjZShyZWd4LCBcIi9cIikuc3BsaXQoXCIvXCIpO1xuXG4gIGlmIChwYXRoLnN1YnN0cigwLCAxKSA9PSAnLycgfHwgcGF0aC5sZW5ndGggPT09IDApIHtcbiAgICBuYW1lcy5zcGxpY2UoMCwgMSk7XG4gIH1cblxuICBpZiAocGF0aC5zdWJzdHIocGF0aC5sZW5ndGggLSAxLCAxKSA9PSAnLycpIHtcbiAgICBuYW1lcy5zcGxpY2UobmFtZXMubGVuZ3RoIC0gMSwgMSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59XG5cbmZ1bmN0aW9uIHF1ZXJ5S2V5KHVyaSwgcXVlcnkpIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgcXVlcnkucmVwbGFjZSgvKD86XnwmKShbXiY9XSopPT8oW14mXSopL2csIGZ1bmN0aW9uICgkMCwgJDEsICQyKSB7XG4gICAgaWYgKCQxKSB7XG4gICAgICBkYXRhWyQxXSA9ICQyO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307IC8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gIH1cbn0pKCk7XG5cbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgfSAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuXG5cbiAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0cnkge1xuICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gIH0gLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuXG5cbiAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRyeSB7XG4gICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZHJhaW5pbmcgPSBmYWxzZTtcblxuICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWVJbmRleCA9IC0xO1xuICB9XG5cbiAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgIGRyYWluUXVldWUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICBpZiAoZHJhaW5pbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgZHJhaW5pbmcgPSB0cnVlO1xuICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW4pIHtcbiAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICBxdWV1ZSA9IFtdO1xuXG4gICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcXVldWVJbmRleCA9IC0xO1xuICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgfVxuXG4gIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gIGRyYWluaW5nID0gZmFsc2U7XG4gIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gIH1cblxuICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuXG4gIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgfVxufTsgLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuXG5cbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICB0aGlzLmZ1biA9IGZ1bjtcbiAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuXG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcblxucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBbXTtcbn07XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJy8nO1xufTtcblxucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAwO1xufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9kaXN0L2JpbmFyeS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvZGlzdC9iaW5hcnkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJlY29uc3RydWN0UGFja2V0ID0gZXhwb3J0cy5kZWNvbnN0cnVjdFBhY2tldCA9IHZvaWQgMDtcblxudmFyIGlzX2JpbmFyeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1iaW5hcnkgKi8gXCIuL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2Rpc3QvaXMtYmluYXJ5LmpzXCIpO1xuLyoqXG4gKiBSZXBsYWNlcyBldmVyeSBCdWZmZXIgfCBBcnJheUJ1ZmZlciB8IEJsb2IgfCBGaWxlIGluIHBhY2tldCB3aXRoIGEgbnVtYmVyZWQgcGxhY2Vob2xkZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIHNvY2tldC5pbyBldmVudCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBkZWNvbnN0cnVjdGVkIHBhY2tldCBhbmQgbGlzdCBvZiBidWZmZXJzXG4gKiBAcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBkZWNvbnN0cnVjdFBhY2tldChwYWNrZXQpIHtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgdmFyIHBhY2tldERhdGEgPSBwYWNrZXQuZGF0YTtcbiAgdmFyIHBhY2sgPSBwYWNrZXQ7XG4gIHBhY2suZGF0YSA9IF9kZWNvbnN0cnVjdFBhY2tldChwYWNrZXREYXRhLCBidWZmZXJzKTtcbiAgcGFjay5hdHRhY2htZW50cyA9IGJ1ZmZlcnMubGVuZ3RoOyAvLyBudW1iZXIgb2YgYmluYXJ5ICdhdHRhY2htZW50cydcblxuICByZXR1cm4ge1xuICAgIHBhY2tldDogcGFjayxcbiAgICBidWZmZXJzOiBidWZmZXJzXG4gIH07XG59XG5cbmV4cG9ydHMuZGVjb25zdHJ1Y3RQYWNrZXQgPSBkZWNvbnN0cnVjdFBhY2tldDtcblxuZnVuY3Rpb24gX2RlY29uc3RydWN0UGFja2V0KGRhdGEsIGJ1ZmZlcnMpIHtcbiAgaWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcblxuICBpZiAoaXNfYmluYXJ5XzEuaXNCaW5hcnkoZGF0YSkpIHtcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSB7XG4gICAgICBfcGxhY2Vob2xkZXI6IHRydWUsXG4gICAgICBudW06IGJ1ZmZlcnMubGVuZ3RoXG4gICAgfTtcbiAgICBidWZmZXJzLnB1c2goZGF0YSk7XG4gICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICB2YXIgbmV3RGF0YSA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ld0RhdGFbaV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSwgYnVmZmVycyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0RhdGE7XG4gIH0gZWxzZSBpZiAoX3R5cGVvZihkYXRhKSA9PT0gXCJvYmplY3RcIiAmJiAhKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgIHZhciBfbmV3RGF0YSA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgX25ld0RhdGFba2V5XSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0sIGJ1ZmZlcnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfbmV3RGF0YTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBSZWNvbnN0cnVjdHMgYSBiaW5hcnkgcGFja2V0IGZyb20gaXRzIHBsYWNlaG9sZGVyIHBhY2tldCBhbmQgYnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBldmVudCBwYWNrZXQgd2l0aCBwbGFjZWhvbGRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlcnMgLSBiaW5hcnkgYnVmZmVycyB0byBwdXQgaW4gcGxhY2Vob2xkZXIgcG9zaXRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY29uc3RydWN0ZWQgcGFja2V0XG4gKiBAcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiByZWNvbnN0cnVjdFBhY2tldChwYWNrZXQsIGJ1ZmZlcnMpIHtcbiAgcGFja2V0LmRhdGEgPSBfcmVjb25zdHJ1Y3RQYWNrZXQocGFja2V0LmRhdGEsIGJ1ZmZlcnMpO1xuICBwYWNrZXQuYXR0YWNobWVudHMgPSB1bmRlZmluZWQ7IC8vIG5vIGxvbmdlciB1c2VmdWxcblxuICByZXR1cm4gcGFja2V0O1xufVxuXG5leHBvcnRzLnJlY29uc3RydWN0UGFja2V0ID0gcmVjb25zdHJ1Y3RQYWNrZXQ7XG5cbmZ1bmN0aW9uIF9yZWNvbnN0cnVjdFBhY2tldChkYXRhLCBidWZmZXJzKSB7XG4gIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cbiAgaWYgKGRhdGEgJiYgZGF0YS5fcGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm4gYnVmZmVyc1tkYXRhLm51bV07IC8vIGFwcHJvcHJpYXRlIGJ1ZmZlciAoc2hvdWxkIGJlIG5hdHVyYWwgb3JkZXIgYW55d2F5KVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGFbaV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSwgYnVmZmVycyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKF90eXBlb2YoZGF0YSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBkYXRhW2tleV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldLCBidWZmZXJzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9kaXN0L2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2Rpc3QvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRGVjb2RlciA9IGV4cG9ydHMuRW5jb2RlciA9IGV4cG9ydHMuUGFja2V0VHlwZSA9IGV4cG9ydHMucHJvdG9jb2wgPSB2b2lkIDA7XG5cbnZhciBFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29tcG9uZW50LWVtaXR0ZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qc1wiKTtcblxudmFyIGJpbmFyeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9iaW5hcnkgKi8gXCIuL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2Rpc3QvYmluYXJ5LmpzXCIpO1xuXG52YXIgaXNfYmluYXJ5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWJpbmFyeSAqLyBcIi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvZGlzdC9pcy1iaW5hcnkuanNcIik7XG5cbnZhciBkZWJ1ZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGRlYnVnICovIFwiLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanNcIikoXCJzb2NrZXQuaW8tcGFyc2VyXCIpO1xuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG5cbmV4cG9ydHMucHJvdG9jb2wgPSA1O1xudmFyIFBhY2tldFR5cGU7XG5cbihmdW5jdGlvbiAoUGFja2V0VHlwZSkge1xuICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJDT05ORUNUXCJdID0gMF0gPSBcIkNPTk5FQ1RcIjtcbiAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiRElTQ09OTkVDVFwiXSA9IDFdID0gXCJESVNDT05ORUNUXCI7XG4gIFBhY2tldFR5cGVbUGFja2V0VHlwZVtcIkVWRU5UXCJdID0gMl0gPSBcIkVWRU5UXCI7XG4gIFBhY2tldFR5cGVbUGFja2V0VHlwZVtcIkFDS1wiXSA9IDNdID0gXCJBQ0tcIjtcbiAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiQ09OTkVDVF9FUlJPUlwiXSA9IDRdID0gXCJDT05ORUNUX0VSUk9SXCI7XG4gIFBhY2tldFR5cGVbUGFja2V0VHlwZVtcIkJJTkFSWV9FVkVOVFwiXSA9IDVdID0gXCJCSU5BUllfRVZFTlRcIjtcbiAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiQklOQVJZX0FDS1wiXSA9IDZdID0gXCJCSU5BUllfQUNLXCI7XG59KShQYWNrZXRUeXBlID0gZXhwb3J0cy5QYWNrZXRUeXBlIHx8IChleHBvcnRzLlBhY2tldFR5cGUgPSB7fSkpO1xuLyoqXG4gKiBBIHNvY2tldC5pbyBFbmNvZGVyIGluc3RhbmNlXG4gKi9cblxuXG52YXIgRW5jb2RlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVuY29kZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVuY29kZXIpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEVuY29kZXIsIFt7XG4gICAga2V5OiBcImVuY29kZVwiLFxuXG4gICAgLyoqXG4gICAgICogRW5jb2RlIGEgcGFja2V0IGFzIGEgc2luZ2xlIHN0cmluZyBpZiBub24tYmluYXJ5LCBvciBhcyBhXG4gICAgICogYnVmZmVyIHNlcXVlbmNlLCBkZXBlbmRpbmcgb24gcGFja2V0IHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gcGFja2V0IG9iamVjdFxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmNvZGUob2JqKSB7XG4gICAgICBkZWJ1ZyhcImVuY29kaW5nIHBhY2tldCAlalwiLCBvYmopO1xuXG4gICAgICBpZiAob2JqLnR5cGUgPT09IFBhY2tldFR5cGUuRVZFTlQgfHwgb2JqLnR5cGUgPT09IFBhY2tldFR5cGUuQUNLKSB7XG4gICAgICAgIGlmIChpc19iaW5hcnlfMS5oYXNCaW5hcnkob2JqKSkge1xuICAgICAgICAgIG9iai50eXBlID0gb2JqLnR5cGUgPT09IFBhY2tldFR5cGUuRVZFTlQgPyBQYWNrZXRUeXBlLkJJTkFSWV9FVkVOVCA6IFBhY2tldFR5cGUuQklOQVJZX0FDSztcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVBc0JpbmFyeShvYmopO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbdGhpcy5lbmNvZGVBc1N0cmluZyhvYmopXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlIHBhY2tldCBhcyBzdHJpbmcuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbmNvZGVBc1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmNvZGVBc1N0cmluZyhvYmopIHtcbiAgICAgIC8vIGZpcnN0IGlzIHR5cGVcbiAgICAgIHZhciBzdHIgPSBcIlwiICsgb2JqLnR5cGU7IC8vIGF0dGFjaG1lbnRzIGlmIHdlIGhhdmUgdGhlbVxuXG4gICAgICBpZiAob2JqLnR5cGUgPT09IFBhY2tldFR5cGUuQklOQVJZX0VWRU5UIHx8IG9iai50eXBlID09PSBQYWNrZXRUeXBlLkJJTkFSWV9BQ0spIHtcbiAgICAgICAgc3RyICs9IG9iai5hdHRhY2htZW50cyArIFwiLVwiO1xuICAgICAgfSAvLyBpZiB3ZSBoYXZlIGEgbmFtZXNwYWNlIG90aGVyIHRoYW4gYC9gXG4gICAgICAvLyB3ZSBhcHBlbmQgaXQgZm9sbG93ZWQgYnkgYSBjb21tYSBgLGBcblxuXG4gICAgICBpZiAob2JqLm5zcCAmJiBcIi9cIiAhPT0gb2JqLm5zcCkge1xuICAgICAgICBzdHIgKz0gb2JqLm5zcCArIFwiLFwiO1xuICAgICAgfSAvLyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSB0aGUgaWRcblxuXG4gICAgICBpZiAobnVsbCAhPSBvYmouaWQpIHtcbiAgICAgICAgc3RyICs9IG9iai5pZDtcbiAgICAgIH0gLy8ganNvbiBkYXRhXG5cblxuICAgICAgaWYgKG51bGwgIT0gb2JqLmRhdGEpIHtcbiAgICAgICAgc3RyICs9IEpTT04uc3RyaW5naWZ5KG9iai5kYXRhKTtcbiAgICAgIH1cblxuICAgICAgZGVidWcoXCJlbmNvZGVkICVqIGFzICVzXCIsIG9iaiwgc3RyKTtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuICAgICAqIGRlY29uc3RydWN0aW5nIHBhY2tldCBpbnRvIG9iamVjdCB3aXRoIHBsYWNlaG9sZGVycyBhbmRcbiAgICAgKiBhIGxpc3Qgb2YgYnVmZmVycy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVuY29kZUFzQmluYXJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuY29kZUFzQmluYXJ5KG9iaikge1xuICAgICAgdmFyIGRlY29uc3RydWN0aW9uID0gYmluYXJ5XzEuZGVjb25zdHJ1Y3RQYWNrZXQob2JqKTtcbiAgICAgIHZhciBwYWNrID0gdGhpcy5lbmNvZGVBc1N0cmluZyhkZWNvbnN0cnVjdGlvbi5wYWNrZXQpO1xuICAgICAgdmFyIGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuICAgICAgYnVmZmVycy51bnNoaWZ0KHBhY2spOyAvLyBhZGQgcGFja2V0IGluZm8gdG8gYmVnaW5uaW5nIG9mIGRhdGEgbGlzdFxuXG4gICAgICByZXR1cm4gYnVmZmVyczsgLy8gd3JpdGUgYWxsIHRoZSBidWZmZXJzXG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVuY29kZXI7XG59KCk7XG5cbmV4cG9ydHMuRW5jb2RlciA9IEVuY29kZXI7XG4vKipcbiAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcbiAqL1xuXG52YXIgRGVjb2RlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VtaXR0ZXIpIHtcbiAgX2luaGVyaXRzKERlY29kZXIsIF9FbWl0dGVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKERlY29kZXIpO1xuXG4gIGZ1bmN0aW9uIERlY29kZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERlY29kZXIpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBEZWNvZGVzIGFuIGVuY29kZWQgcGFja2V0IHN0cmluZyBpbnRvIHBhY2tldCBKU09OLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gb2JqIC0gZW5jb2RlZCBwYWNrZXRcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRGVjb2RlciwgW3tcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChvYmopIHtcbiAgICAgIHZhciBwYWNrZXQ7XG5cbiAgICAgIGlmICh0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHBhY2tldCA9IHRoaXMuZGVjb2RlU3RyaW5nKG9iaik7XG5cbiAgICAgICAgaWYgKHBhY2tldC50eXBlID09PSBQYWNrZXRUeXBlLkJJTkFSWV9FVkVOVCB8fCBwYWNrZXQudHlwZSA9PT0gUGFja2V0VHlwZS5CSU5BUllfQUNLKSB7XG4gICAgICAgICAgLy8gYmluYXJ5IHBhY2tldCdzIGpzb25cbiAgICAgICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBuZXcgQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpOyAvLyBubyBhdHRhY2htZW50cywgbGFiZWxlZCBiaW5hcnkgYnV0IG5vIGJpbmFyeSBkYXRhIHRvIGZvbGxvd1xuXG4gICAgICAgICAgaWYgKHBhY2tldC5hdHRhY2htZW50cyA9PT0gMCkge1xuICAgICAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoRGVjb2Rlci5wcm90b3R5cGUpLCBcImVtaXRcIiwgdGhpcykuY2FsbCh0aGlzLCBcImRlY29kZWRcIiwgcGFja2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm9uLWJpbmFyeSBmdWxsIHBhY2tldFxuICAgICAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKERlY29kZXIucHJvdG90eXBlKSwgXCJlbWl0XCIsIHRoaXMpLmNhbGwodGhpcywgXCJkZWNvZGVkXCIsIHBhY2tldCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNfYmluYXJ5XzEuaXNCaW5hcnkob2JqKSB8fCBvYmouYmFzZTY0KSB7XG4gICAgICAgIC8vIHJhdyBiaW5hcnkgZGF0YVxuICAgICAgICBpZiAoIXRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImdvdCBiaW5hcnkgZGF0YSB3aGVuIG5vdCByZWNvbnN0cnVjdGluZyBhIHBhY2tldFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYWNrZXQgPSB0aGlzLnJlY29uc3RydWN0b3IudGFrZUJpbmFyeURhdGEob2JqKTtcblxuICAgICAgICAgIGlmIChwYWNrZXQpIHtcbiAgICAgICAgICAgIC8vIHJlY2VpdmVkIGZpbmFsIGJ1ZmZlclxuICAgICAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcblxuICAgICAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoRGVjb2Rlci5wcm90b3R5cGUpLCBcImVtaXRcIiwgdGhpcykuY2FsbCh0aGlzLCBcImRlY29kZWRcIiwgcGFja2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZTogXCIgKyBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYSBwYWNrZXQgU3RyaW5nIChKU09OIGRhdGEpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlY29kZVN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVTdHJpbmcoc3RyKSB7XG4gICAgICB2YXIgaSA9IDA7IC8vIGxvb2sgdXAgdHlwZVxuXG4gICAgICB2YXIgcCA9IHtcbiAgICAgICAgdHlwZTogTnVtYmVyKHN0ci5jaGFyQXQoMCkpXG4gICAgICB9O1xuXG4gICAgICBpZiAoUGFja2V0VHlwZVtwLnR5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBwYWNrZXQgdHlwZSBcIiArIHAudHlwZSk7XG4gICAgICB9IC8vIGxvb2sgdXAgYXR0YWNobWVudHMgaWYgdHlwZSBiaW5hcnlcblxuXG4gICAgICBpZiAocC50eXBlID09PSBQYWNrZXRUeXBlLkJJTkFSWV9FVkVOVCB8fCBwLnR5cGUgPT09IFBhY2tldFR5cGUuQklOQVJZX0FDSykge1xuICAgICAgICB2YXIgc3RhcnQgPSBpICsgMTtcblxuICAgICAgICB3aGlsZSAoc3RyLmNoYXJBdCgrK2kpICE9PSBcIi1cIiAmJiBpICE9IHN0ci5sZW5ndGgpIHt9XG5cbiAgICAgICAgdmFyIGJ1ZiA9IHN0ci5zdWJzdHJpbmcoc3RhcnQsIGkpO1xuXG4gICAgICAgIGlmIChidWYgIT0gTnVtYmVyKGJ1ZikgfHwgc3RyLmNoYXJBdChpKSAhPT0gXCItXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGF0dGFjaG1lbnRzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcC5hdHRhY2htZW50cyA9IE51bWJlcihidWYpO1xuICAgICAgfSAvLyBsb29rIHVwIG5hbWVzcGFjZSAoaWYgYW55KVxuXG5cbiAgICAgIGlmIChcIi9cIiA9PT0gc3RyLmNoYXJBdChpICsgMSkpIHtcbiAgICAgICAgdmFyIF9zdGFydCA9IGkgKyAxO1xuXG4gICAgICAgIHdoaWxlICgrK2kpIHtcbiAgICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgICAgaWYgKFwiLFwiID09PSBjKSBicmVhaztcbiAgICAgICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBwLm5zcCA9IHN0ci5zdWJzdHJpbmcoX3N0YXJ0LCBpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHAubnNwID0gXCIvXCI7XG4gICAgICB9IC8vIGxvb2sgdXAgaWRcblxuXG4gICAgICB2YXIgbmV4dCA9IHN0ci5jaGFyQXQoaSArIDEpO1xuXG4gICAgICBpZiAoXCJcIiAhPT0gbmV4dCAmJiBOdW1iZXIobmV4dCkgPT0gbmV4dCkge1xuICAgICAgICB2YXIgX3N0YXJ0MiA9IGkgKyAxO1xuXG4gICAgICAgIHdoaWxlICgrK2kpIHtcbiAgICAgICAgICB2YXIgX2MgPSBzdHIuY2hhckF0KGkpO1xuXG4gICAgICAgICAgaWYgKG51bGwgPT0gX2MgfHwgTnVtYmVyKF9jKSAhPSBfYykge1xuICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGkgPT09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcC5pZCA9IE51bWJlcihzdHIuc3Vic3RyaW5nKF9zdGFydDIsIGkgKyAxKSk7XG4gICAgICB9IC8vIGxvb2sgdXAganNvbiBkYXRhXG5cblxuICAgICAgaWYgKHN0ci5jaGFyQXQoKytpKSkge1xuICAgICAgICB2YXIgcGF5bG9hZCA9IHRyeVBhcnNlKHN0ci5zdWJzdHIoaSkpO1xuXG4gICAgICAgIGlmIChEZWNvZGVyLmlzUGF5bG9hZFZhbGlkKHAudHlwZSwgcGF5bG9hZCkpIHtcbiAgICAgICAgICBwLmRhdGEgPSBwYXlsb2FkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGF5bG9hZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkZWJ1ZyhcImRlY29kZWQgJXMgYXMgJWpcIiwgc3RyLCBwKTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG5cbiAgICAvKipcbiAgICAgKiBEZWFsbG9jYXRlcyBhIHBhcnNlcidzIHJlc291cmNlc1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImlzUGF5bG9hZFZhbGlkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzUGF5bG9hZFZhbGlkKHR5cGUsIHBheWxvYWQpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFBhY2tldFR5cGUuQ09OTkVDVDpcbiAgICAgICAgICByZXR1cm4gX3R5cGVvZihwYXlsb2FkKSA9PT0gXCJvYmplY3RcIjtcblxuICAgICAgICBjYXNlIFBhY2tldFR5cGUuRElTQ09OTkVDVDpcbiAgICAgICAgICByZXR1cm4gcGF5bG9hZCA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGNhc2UgUGFja2V0VHlwZS5DT05ORUNUX0VSUk9SOlxuICAgICAgICAgIHJldHVybiB0eXBlb2YgcGF5bG9hZCA9PT0gXCJzdHJpbmdcIiB8fCBfdHlwZW9mKHBheWxvYWQpID09PSBcIm9iamVjdFwiO1xuXG4gICAgICAgIGNhc2UgUGFja2V0VHlwZS5FVkVOVDpcbiAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkJJTkFSWV9FVkVOVDpcbiAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwYXlsb2FkKSAmJiB0eXBlb2YgcGF5bG9hZFswXSA9PT0gXCJzdHJpbmdcIjtcblxuICAgICAgICBjYXNlIFBhY2tldFR5cGUuQUNLOlxuICAgICAgICBjYXNlIFBhY2tldFR5cGUuQklOQVJZX0FDSzpcbiAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwYXlsb2FkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGVjb2Rlcjtcbn0oRW1pdHRlcik7XG5cbmV4cG9ydHMuRGVjb2RlciA9IERlY29kZXI7XG5cbmZ1bmN0aW9uIHRyeVBhcnNlKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHN0cik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbi8qKlxuICogQSBtYW5hZ2VyIG9mIGEgYmluYXJ5IGV2ZW50J3MgJ2J1ZmZlciBzZXF1ZW5jZScuIFNob3VsZFxuICogYmUgY29uc3RydWN0ZWQgd2hlbmV2ZXIgYSBwYWNrZXQgb2YgdHlwZSBCSU5BUllfRVZFTlQgaXNcbiAqIGRlY29kZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QmluYXJ5UmVjb25zdHJ1Y3Rvcn0gaW5pdGlhbGl6ZWQgcmVjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIEJpbmFyeVJlY29uc3RydWN0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCaW5hcnlSZWNvbnN0cnVjdG9yKTtcblxuICAgIHRoaXMucGFja2V0ID0gcGFja2V0O1xuICAgIHRoaXMuYnVmZmVycyA9IFtdO1xuICAgIHRoaXMucmVjb25QYWNrID0gcGFja2V0O1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gYmluYXJ5IGRhdGEgcmVjZWl2ZWQgZnJvbSBjb25uZWN0aW9uXG4gICAqIGFmdGVyIGEgQklOQVJZX0VWRU5UIHBhY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXIgfCBBcnJheUJ1ZmZlcn0gYmluRGF0YSAtIHRoZSByYXcgYmluYXJ5IGRhdGEgcmVjZWl2ZWRcbiAgICogQHJldHVybiB7bnVsbCB8IE9iamVjdH0gcmV0dXJucyBudWxsIGlmIG1vcmUgYmluYXJ5IGRhdGEgaXMgZXhwZWN0ZWQgb3JcbiAgICogICBhIHJlY29uc3RydWN0ZWQgcGFja2V0IG9iamVjdCBpZiBhbGwgYnVmZmVycyBoYXZlIGJlZW4gcmVjZWl2ZWQuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEJpbmFyeVJlY29uc3RydWN0b3IsIFt7XG4gICAga2V5OiBcInRha2VCaW5hcnlEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRha2VCaW5hcnlEYXRhKGJpbkRhdGEpIHtcbiAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGJpbkRhdGEpO1xuXG4gICAgICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PT0gdGhpcy5yZWNvblBhY2suYXR0YWNobWVudHMpIHtcbiAgICAgICAgLy8gZG9uZSB3aXRoIGJ1ZmZlciBsaXN0XG4gICAgICAgIHZhciBwYWNrZXQgPSBiaW5hcnlfMS5yZWNvbnN0cnVjdFBhY2tldCh0aGlzLnJlY29uUGFjaywgdGhpcy5idWZmZXJzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gICAgICAgIHJldHVybiBwYWNrZXQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdXAgYmluYXJ5IHBhY2tldCByZWNvbnN0cnVjdGlvbiB2YXJpYWJsZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaW5pc2hlZFJlY29uc3RydWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKSB7XG4gICAgICB0aGlzLnJlY29uUGFjayA9IG51bGw7XG4gICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmluYXJ5UmVjb25zdHJ1Y3Rvcjtcbn0oKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9kaXN0L2lzLWJpbmFyeS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvZGlzdC9pcy1iaW5hcnkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmhhc0JpbmFyeSA9IGV4cG9ydHMuaXNCaW5hcnkgPSB2b2lkIDA7XG52YXIgd2l0aE5hdGl2ZUFycmF5QnVmZmVyID0gdHlwZW9mIEFycmF5QnVmZmVyID09PSBcImZ1bmN0aW9uXCI7XG5cbnZhciBpc1ZpZXcgPSBmdW5jdGlvbiBpc1ZpZXcob2JqKSB7XG4gIHJldHVybiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSBcImZ1bmN0aW9uXCIgPyBBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKSA6IG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn07XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgd2l0aE5hdGl2ZUJsb2IgPSB0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBCbG9iICE9PSBcInVuZGVmaW5lZFwiICYmIHRvU3RyaW5nLmNhbGwoQmxvYikgPT09IFwiW29iamVjdCBCbG9iQ29uc3RydWN0b3JdXCI7XG52YXIgd2l0aE5hdGl2ZUZpbGUgPSB0eXBlb2YgRmlsZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBGaWxlICE9PSBcInVuZGVmaW5lZFwiICYmIHRvU3RyaW5nLmNhbGwoRmlsZSkgPT09IFwiW29iamVjdCBGaWxlQ29uc3RydWN0b3JdXCI7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmogaXMgYSBCdWZmZXIsIGFuIEFycmF5QnVmZmVyLCBhIEJsb2Igb3IgYSBGaWxlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNCaW5hcnkob2JqKSB7XG4gIHJldHVybiB3aXRoTmF0aXZlQXJyYXlCdWZmZXIgJiYgKG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IGlzVmlldyhvYmopKSB8fCB3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iIHx8IHdpdGhOYXRpdmVGaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGU7XG59XG5cbmV4cG9ydHMuaXNCaW5hcnkgPSBpc0JpbmFyeTtcblxuZnVuY3Rpb24gaGFzQmluYXJ5KG9iaiwgdG9KU09OKSB7XG4gIGlmICghb2JqIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChoYXNCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNCaW5hcnkob2JqKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKG9iai50b0pTT04gJiYgdHlwZW9mIG9iai50b0pTT04gPT09IFwiZnVuY3Rpb25cIiAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGhhc0JpbmFyeShvYmoudG9KU09OKCksIHRydWUpO1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIGhhc0JpbmFyeShvYmpba2V5XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0cy5oYXNCaW5hcnkgPSBoYXNCaW5hcnk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3llYXN0L2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3llYXN0L2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei1fJy5zcGxpdCgnJyksXG4gICAgbGVuZ3RoID0gNjQsXG4gICAgbWFwID0ge30sXG4gICAgc2VlZCA9IDAsXG4gICAgaSA9IDAsXG4gICAgcHJldjtcbi8qKlxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtIFRoZSBudW1iZXIgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG51bWJlci5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlKG51bSkge1xuICB2YXIgZW5jb2RlZCA9ICcnO1xuXG4gIGRvIHtcbiAgICBlbmNvZGVkID0gYWxwaGFiZXRbbnVtICUgbGVuZ3RoXSArIGVuY29kZWQ7XG4gICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBsZW5ndGgpO1xuICB9IHdoaWxlIChudW0gPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn1cbi8qKlxuICogUmV0dXJuIHRoZSBpbnRlZ2VyIHZhbHVlIHNwZWNpZmllZCBieSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge051bWJlcn0gVGhlIGludGVnZXIgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIHN0cmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBkZWNvZGUoc3RyKSB7XG4gIHZhciBkZWNvZGVkID0gMDtcblxuICBmb3IgKGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVjb2RlZCA9IGRlY29kZWQgKiBsZW5ndGggKyBtYXBbc3RyLmNoYXJBdChpKV07XG4gIH1cblxuICByZXR1cm4gZGVjb2RlZDtcbn1cbi8qKlxuICogWWVhc3Q6IEEgdGlueSBncm93aW5nIGlkIGdlbmVyYXRvci5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIHVuaXF1ZSBpZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiB5ZWFzdCgpIHtcbiAgdmFyIG5vdyA9IGVuY29kZSgrbmV3IERhdGUoKSk7XG4gIGlmIChub3cgIT09IHByZXYpIHJldHVybiBzZWVkID0gMCwgcHJldiA9IG5vdztcbiAgcmV0dXJuIG5vdyArICcuJyArIGVuY29kZShzZWVkKyspO1xufSAvL1xuLy8gTWFwIGVhY2ggY2hhcmFjdGVyIHRvIGl0cyBpbmRleC5cbi8vXG5cblxuZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICBtYXBbYWxwaGFiZXRbaV1dID0gaTtcbn0gLy9cbi8vIEV4cG9zZSB0aGUgYHllYXN0YCwgYGVuY29kZWAgYW5kIGBkZWNvZGVgIGZ1bmN0aW9ucy5cbi8vXG5cblxueWVhc3QuZW5jb2RlID0gZW5jb2RlO1xueWVhc3QuZGVjb2RlID0gZGVjb2RlO1xubW9kdWxlLmV4cG9ydHMgPSB5ZWFzdDtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvY2tldC5pby5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/socket.io-client.js\n");

/***/ }),

/***/ 3:
/*!************************************************!*\
  !*** multi ./resources/js/socket.io-client.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! /opt/lampp/htdocs/LantuuWeb/resources/js/socket.io-client.js */"./resources/js/socket.io-client.js");


/***/ })

/******/ });